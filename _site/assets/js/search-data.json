{"0": {
    "doc": "Week 1",
    "title": "Week 1",
    "content": " ",
    "url": "/week/1.html",
    "relUrl": "/week/1.html"
  },"1": {
    "doc": "Week 10",
    "title": "Week 10",
    "content": " ",
    "url": "/week/10.html",
    "relUrl": "/week/10.html"
  },"2": {
    "doc": "Week 11",
    "title": "Week 11",
    "content": " ",
    "url": "/week/11.html",
    "relUrl": "/week/11.html"
  },"3": {
    "doc": "Week 12",
    "title": "Week 12",
    "content": " ",
    "url": "/week/12.html",
    "relUrl": "/week/12.html"
  },"4": {
    "doc": "Week 13",
    "title": "Week 13",
    "content": " ",
    "url": "/week/13.html",
    "relUrl": "/week/13.html"
  },"5": {
    "doc": "Week 2",
    "title": "Week 2",
    "content": " ",
    "url": "/week/2.html",
    "relUrl": "/week/2.html"
  },"6": {
    "doc": "Week 3",
    "title": "Week 3",
    "content": " ",
    "url": "/week/3.html",
    "relUrl": "/week/3.html"
  },"7": {
    "doc": "Week 4",
    "title": "Week 4",
    "content": " ",
    "url": "/week/4.html",
    "relUrl": "/week/4.html"
  },"8": {
    "doc": "Week 5",
    "title": "Week 5",
    "content": " ",
    "url": "/week/5.html",
    "relUrl": "/week/5.html"
  },"9": {
    "doc": "Week 6",
    "title": "Week 6",
    "content": " ",
    "url": "/week/6.html",
    "relUrl": "/week/6.html"
  },"10": {
    "doc": "Week 7",
    "title": "Week 7",
    "content": " ",
    "url": "/week/7.html",
    "relUrl": "/week/7.html"
  },"11": {
    "doc": "Week 8",
    "title": "Week 8",
    "content": " ",
    "url": "/week/8.html",
    "relUrl": "/week/8.html"
  },"12": {
    "doc": "Week 9",
    "title": "Week 9",
    "content": " ",
    "url": "/week/9.html",
    "relUrl": "/week/9.html"
  },"13": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Please read the following short articles: . | Gentle Introduction to APIs, part 1 | Python API Tutorial | . Also check out the documentation for one of the APIs we’ll be working with this week: . | TMDB API documentation | . You don’t have to read everything in it, just look around to get a basic idea of what’s in it. There are tons and tons of content-based APIs out there. To get an idea of the kinds of information that can be available in APIs, take a look at this huge list of public APIs available on Github, and an even bigger list of both free and paid APIs on RapidAPI. ",
    "url": "/readings/apis.html",
    "relUrl": "/readings/apis.html"
  },"14": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For this week’s summary, browse through the available APIs (links above). Think about what you might want to use some of these APIs for. Summary prompt: Summarize your thoughts on APIs and what they are (and aren’t) useful for. ",
    "url": "/readings/apis.html#summary",
    "relUrl": "/readings/apis.html#summary"
  },"15": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Tuesday. ",
    "url": "/readings/apis.html#question",
    "relUrl": "/readings/apis.html#question"
  },"16": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. Work together . You should work in small groups on this studio. Groups of 2-3 people. Work together to create the story and to write the code. But don’t divide up the work; that’s no fun. Everyone should work on all parts. If you need to come up with the next step of the story, then get the whole group together and brainstorm the story. If you need to implement a choice in Python, then get the whole group together and work on it until it looks how you want it to. Have one person on the keyboard sharing their screen, and the rest looking over helping (navigating). Some groups like to start out by writing the story in Google Docs or by mapping out the story paths on paper. That’s fine. When you’re writing the code, make sure to switch drivers regularly so everyone gets a chance to work on the program! . Use Git . Remember you can share code using Git and Gitlab. Git is easiest to use when only one person is writing code at any given time; if multiple people are working on the same file, you will run into Git conflicts, which are sometimes hard to resolve. I would recommend approaching it like this: . First driver: . | use git clone or git pull to get the most up to date project onto their computer | write code | use git add, git commit, and git push to save code to the group’s Gitlab repository | . Switch drivers, second driver does the same as above, and so on. If you get stuck with Git, here’s a Git reference that may be helpful. Jack and Caitlin can also help you anytime. Remember all of your code needs to be in Gitlab at the end of class - that’s how you will turn your code in from now on! . Choosing a story . If you are good at coming up with stories, then you don’t need this advice. If you aren’t awesome at it, then the easiest way to start is to start with an existing story and set of characters. Pick a story that you already know a lot about to start with, and begin there. It could be from a movie, a book, a game, a TV show, a fairy tale, or real life. It could be a true story, or it could be made up. The easiest place to start is to tell that story. Then think about different places where people in the story could have made different choices, and things would have turned out differently. Those are great places to ask the user to make a choice. You’ll also have to write the alternative outcomes / stories. Diagram . Once you’ve got an idea for a story, I’d recommend creating a diagram. Put major events in circles on a piece of paper, and then draw a line between them to signify order. Figure out what kinds of choices can be made, and add other outcomes as additional circles. It will really help to have a diagram that you can refer back to as you work on the programming. Here is a very simple example of a diagram. It is perfectly OK to use pencil and paper. It is also OK to find a computer program to draw the diagram, and then share your screen as you do that. It is up to you what tools you want to use, and how you use them. I think you will find that using external tools (like pencil and paper) is a very important part of computer programming. Start simple, then expand . Don’t try to do everything at once. Start with as simple of a story as you can, and then build from there. For example, the first thing you should do is probably just have it print out a single story block, and then end. Get that working first. Then write your first choice – get the coding working for a single choice, that prints out something silly, but different based on the choice the user made. Once that works correctly when you run it, then you can replace the silly text with the actual story you want to be telling. And then you can add more choices. But don’t move on add anything new until everything you’ve already written works correctly. Keep testing small bits of the program as you go! . This also means that you don’t need to have the whole story written before you start writing your program. Get the first bit of it written, then try to make it work as a computer program. Alternate between writing story and writing code. If you try to do it all at once, it’s easy to get bogged down in unimportant details. By going back and forth between story writing and coding, you make sure that each piece works well before you move on. Use code you’ve already worked with . You already did a bit with conditionals (if, else, and elif) in the lab last week. You can always use code from labs as a model to build your own code. For today’s studio, the avengers.py program will be particularly helpful for you to look at. Submit on D2L and Gitlab . Your studio is finished when the class is over - no sooner! You can always continue to add to the story or improve your code. When you are done, please submit screenshots of your code working (that is, of the program running in Powershell or Terminal) on D2L under Assignments. At least one person in the group needs to submit a screenshot. Also make sure all of your most recent code is in Gitlab, and that your Gitlab repository is shared with Caitlin and Jack. This is how you will turn in your code for every studio. See the Git reference if you need pointers on using Git for studios. ",
    "url": "/studios/choose_your_own_adventure.html#advice",
    "relUrl": "/studios/choose_your_own_adventure.html#advice"
  },"17": {
    "doc": "Studio",
    "title": "Studio",
    "content": "The goal for today’s studio is to write an interactive Choose Your Own Adventure story. In these types of stories, the reader gets to choose what happens next in the story based on a set series of choices. When you run the program, it should show the beginning of the story, ask the user to make a choice from a few choices that you give them, and then continue the story based on that choice. And so on. If I run the program again, it will start in the same place, but if I make different choices, the story should go in a different direction. Be creative! There’s a small choose your own adventure program in the code from last week’s lab using the Avengers. You don’t have to write a story about the Avengers; your story can be about anything. But the code from last week might be useful to start with. You must work in a small group on this project. Form a group of 2-3 people and work together on this project. Who you work with is up to you, but you can’t work alone. ",
    "url": "/studios/choose_your_own_adventure.html",
    "relUrl": "/studios/choose_your_own_adventure.html"
  },"18": {
    "doc": "Using command line",
    "title": "Command line applications",
    "content": "Both MacOS and Windows come with command line applications preinstalled. In this class we’ll be using: . Windows: PowerShell MacOS: Terminal . ",
    "url": "/reference/command_line.html#command-line-applications",
    "relUrl": "/reference/command_line.html#command-line-applications"
  },"19": {
    "doc": "Using command line",
    "title": "Navigating through folders",
    "content": "The most important thing to remember about command line is that it only will let you do things with files if it thinks it’s in the same location the file is. That means if the file you want to work with is in the Downloads folder, then command line also needs to be pointed at the Downloads folder before you can do anything with that file. Folder structures on computers are nested on multiple levels. It might look like this: . Caitlin - Desktop - Documents - - Photos - - School - - - MI 250 - Downloads . In this example, the MI 250 folder is inside the School folder, which is inside Documents, which is inside the top level ‘Caitlin’ folder. To navigate to the MI 250 folder, you have to go through all of its ‘parent’ folders first. By default, both PowerShell and Terminal start at a folder named after the computer’s user. Desktop, Downloads, and Documents as well as a few other folders are there by default. When you make a new folder, you need to pay attention to where you’re putting it in this structure so you can find it again. In command line, to navigate to a folder, you use cd, which stands for ‘change directory’. cd is not case sensitive (you don’t have to use capital letters). To get to the MI 250 folder, I would give this command: . cd documents/school/\"mi 250\" . If there are spaces in a folder name, make sure to put quotation marks (“”) around the name of the folder. Getting to a folder fast . There’s a neat trick that works in both Windows and Mac OS to get to the folder you want to go to without typing in the full path to get there. | Type cd in command line - make sure there is a space after cd. | Open up the folder you want in File Explorer (Windows) or Finder (Mac OS) – the normal way of viewing folders. | Drag the folder over to the command line window. When you release your mouse on top of the command line window, that should put the full directory name after cd. | . Other useful commands for navigation . A couple of other useful command line commands: . | You can get a list of the files in the current directory with the ls command | You can move up one directory (to the parent directory) with the command cd .. | If you start typing the name of a file or directory, you can hit the Tab key and it will try to automatically finish typing the name of that file/directory for you. | . To learn more about navigating through folders with command line, you can read Navigating the Command Line (which I recommend if you haven’t worked with the command line before). ",
    "url": "/reference/command_line.html#navigating-through-folders",
    "relUrl": "/reference/command_line.html#navigating-through-folders"
  },"20": {
    "doc": "Using command line",
    "title": "Python’s interactive mode (and getting out of it)",
    "content": "To run Python programs in command line, you type python (Windows) or python3 (MacOS) followed by the name of the program. So to run eliza.py, you’d type python eliza.py and that will run the program. If you only type python without giving it a program to run, it will go into interactive mode. You can use this mode to try out short snippets of code to see if it works. We won’t be using it much in this class, though. You’ll know you’re in this mode if you see three arrows (&gt;&gt;&gt;) on the last line. To get out of this mode, type quit() and hit Enter. On Windows, you can also hit Control+Z and then Enter. On MacOS, you can use Control+D. ",
    "url": "/reference/command_line.html#pythons-interactive-mode-and-getting-out-of-it",
    "relUrl": "/reference/command_line.html#pythons-interactive-mode-and-getting-out-of-it"
  },"21": {
    "doc": "Using command line",
    "title": "More tips",
    "content": "Using previous commands with arrow keys . When the space next to the prompt in command line is empty (you haven’t typed anything yet), you can hit the “up” arrow on your keyboard - this will autopopulate the last command that was given. If you hit the up arrow multiple times, it will cycle through all of the previous commands you’ve given it. The down arrow goes the opposite direction through the commands. ",
    "url": "/reference/command_line.html#more-tips",
    "relUrl": "/reference/command_line.html#more-tips"
  },"22": {
    "doc": "Using command line",
    "title": "More resources",
    "content": "More information about command line (or ‘shell’) commands can be found here. ",
    "url": "/reference/command_line.html#more-resources",
    "relUrl": "/reference/command_line.html#more-resources"
  },"23": {
    "doc": "Using command line",
    "title": "Using command line",
    "content": "You’ll be using command line a lot in this class to run Python programs. Here are some tips and tricks to help you out. ",
    "url": "/reference/command_line.html",
    "relUrl": "/reference/command_line.html"
  },"24": {
    "doc": "Lab",
    "title": "Print - outputting information",
    "content": "You learned a bit about the print statement in the readings this week. You’ll be using it a lot this semester; we’ll start practicing now. Exercise 1: Hello world . The first program that almost everyone writes when they’re learning how to program is called “Hello World”. The idea is to create a program that communicates with a user by giving them a simple piece of information – in this case, it says hello. I’ve already written a simple version of this program, and its called “hello.py”. First, run this program in command line with: . python hello.py . Remember to use python3 if you’re on a Mac! If you need a refresher on running Python programs, go back to Lab 1. Open up the hello.py in your text editor. What does it look like? What do you think print does? . Exercise 2: Say hello to someone . Next we will practice modifying this program. Last week, we opened program files in a text editor, edited them, and then ran them on the command line. We are going to do that again this week; however, this week we are going to be making more careful edits that do more than we did last week. Have the program, when you run it, say hello to a specific person – use the name of the person who is the driver in your pair today. To do this, you want to put the drvier’s name into the print statement. So if the driver’s name is David Bowie, then the program should print out . Hello David Bowie . Exercise 3: Add more information . Next, have hello.py print out some additional information. To do this, you’ll need to add additional print statements. Each print statement prints out one line of output. You want the program to introduce the person who is navigating to the driver, so that when the driver runs the program, they learn more about their partner for the lab. So, for example, the program could output something like: . Hello David Bowie I am Ziggy Stardust and I am a sophomore media and information major. I enjoy helping people use technology. I hope to become a user experience professional when I graduate. You can always go back to the readings and videos from this week to remind yourself about print statements and how to use them. Make sure that all of this information is not on one line, but instead appears on multiple different lines. Also remember that you can print a blank line using print(\"\"). Change places . Now is a good time to switch places with your partner. Before you do, remember to take a screenshot of hello.py with the changes you made running in command line. The new driver will need to download the Git repository for today’s lab on their computer now - go to the top of this page if you need a refresher on how to do that. Exercise 4: New hello program . Make a new program called hello2.py. You can do this by going to File -&gt; New File in your text editor (Visual Studio Code or similar) and then doing File -&gt; Save As and giving it a name - make sure you add the .py at the end of the name so your computer will know it’s a Python program. The file will start out blank - you’ll need to add code to it. Write code to introduce the other person in your pair today - they should be the driver now. When you’re done, your code should look similar to your partner’s edited version of hello.py - it should be a series of print() statements which print out information about you when you run the program. Make sure to run the program to test it! . ",
    "url": "/labs/control_flow.html#print---outputting-information",
    "relUrl": "/labs/control_flow.html#print---outputting-information"
  },"25": {
    "doc": "Lab",
    "title": "Variables – storing information for later use",
    "content": "Now that we’ve had a chance to practice printing out information, let’s use variables to change up what we are displaying. To do this, we will first put pieces of information into variables. Then we’ll use the print command to print out information that fills in blanks with the contents of a variable. We will start with the file mad-libs.py. The first thing you should do is to run the program. What does it print out? . Exercise 5: Words . Now open up the file, and notice that at the top of the file, there are some variables. The name of each variable is a prompt, like “body_part” or “action”. Ask the navigator to come up with new words to respond to the prompts by reading the variable names to them. Replace what’s in there now with the new words. Run the program again, and notice what changed. Why did that happen? . Notice what running the program does – it stores specific words (in \"\" quotes) into variables like body_part and action. Then, when it prints out, instead of printing out the word action, it prints out whatever is stored in the variable named action. This is how variables work – you store something in them, and then Python will substitute whatever is stored in them as it runs. Exercise 6: New Mad-libs . Pick a new movie quote. It can be from any movie you want, though if you like the Guardians of the Galaxy theme, here are some of the memorable quotes. Add a new print statement that prints out the quote. Then choose a word to replace, and create a variable to hold the word that replaces it. Try to get it so that you can change the value of the variable at the top of the file, and it will change what is printed out. Change places . This is another good place to switch from driver to navigator, and vice versa. When the next exercise uses a different file, that’s often a good time to trade places. ",
    "url": "/labs/control_flow.html#variables--storing-information-for-later-use",
    "relUrl": "/labs/control_flow.html#variables--storing-information-for-later-use"
  },"26": {
    "doc": "Lab",
    "title": "Getting input from users",
    "content": "So far, every time we run the programs we’ve worked on, they do the same thing. That’s not a bad thing – some of the most interesting programs do the same thing every time they are run (like display tomorrow’s weather, or figure out a prediction, or render a 3D movie). But the most interesting programs are interactive – they ask the user for input, and then change what they do based on what the user does. Up to this point, the way you made the program do something different was to edit the program. That is, you were both being the programmer (who edits the program) and the user (who tells the program what to do). Starting now, we are going to separate those roles. You will write a program that asks the user – which may be you, or it may be other people – for input. Then the program will do interesting things with that user input. What this means is that, starting now, we are going to be writing programs that are not just for ourselves, but that can also be used by other people for their own purposes. This is one of the most interesting and exciting parts of programming – that other people can take your program and do interesting things with it. Today, we are going to begin with the simplest way to get user input – through the keyboard using input(). First, notice that there is a second mad-libs file, mad-libs-input.py. Run that program using python mad-libs-input.py. Ask the navigator for words based on the prompts, and enter them into the program as it runs. Then observe what comes out. This is a simple interactive program that asks for input (words) and then changes what it says based on what the user inputs. Next, run it again, and type in different things. What happens? . Exercise 7: Update the Mad-Lib . The original source of that mad-lib is the song “Space Oddity” by David Bowie. It’s an old song from the late 60s, written during the space race. For this challenge, change the mad-lib. Pick a different song that YOU like, and use that song to create the mad-lib. Feel free to edit this file; you don’t need to create a whole new program. Your new mad-lib should ask the user for new types of words. They should be words that fit into the song you choose, not the types of words that I asked for. Take what the user enters and have the program store them into variables. Then print out the lyrics to your song, replacing key words with words that the user inputs. Notice how you store things. The code says variable = input(\"...\"). You pick a variable and put it on the left side of the equals sign. Then you put what you want to put into the variable on the right side. Previously, we put actual words in quotation marks – the quotation marks tell Python that we want the words inside to be reproduced as-is. In this program, instead of putting quotation marks, we use the command input(\"...\") to get input from the user. The text inside the parentheses () is the prompt that the user gets when they run the program. Whatever the user types in, it stores into the variable on the left side of the equals sign. (Question: What happens if you put the input(\"...\") command, but don’t include variable = before it? Answer: It asks the user for input, but then the program immediately forgets what the user typed because it didn’t have anywhere to store it.) . Note: The code for your program – the file you edit in your text editor – should not have the actual words in it like it did in exercise 4. Instead, it should just contain instructions to ask the user for words. Change places . This is another good time to change places with your partner. ",
    "url": "/labs/control_flow.html#getting-input-from-users",
    "relUrl": "/labs/control_flow.html#getting-input-from-users"
  },"27": {
    "doc": "Lab",
    "title": "Not always doing the same thing",
    "content": "Next, we will work with basic conditionals. There are three kinds of conditional statements: if, elif, and else. They all cause things to to cause different things to happen in different situations. To begin, let’s run the Avengers program: . python avengers.py . Now go through and read the source code for the Avengers program – open up avengers.py in your text editor. Notice that when you run the program, not every line in the source code gets printed out; instead, it depends on what the user of the program types in. Pay particular attention to how things are indented. Indentation is really important in Python. Indentation controls which lines are part of the if statement and which ones are not. When if, elif, and else statements are all indented at the same level, this connects them together as one big statement with multiple branches of possibility. Exercise 8: Try different inputs . Run the avengers program multiple times. Give different answers to the prompts. Try out all three avengers as an answer to the first prompt. What happens? . Now look at the code. Why is that happening? What is each part of the statement doing? What are the differences between if, elif, and else? (Hint: elif is short for “else if”.) . Also, as you tried things, did anything not work as you expected? Make a list of ‘bugs’ – problems with the program where it doesn’t work the way you expect it to. What you’re doing here is testing the program to understand how it works and thinking about how you could improve it. Exercise 9: What Happens when Captain America tries? . Next, modify the code. What happens when Captain America tries to pick up the hammer? Put some print statements in the right place to tell the story of what happens when Captain America tries to pick up the hammer. Exercise 10: Lowercase . Right now, if you type in Thor’s name or Iron Man’s name, it works even if you don’t capitalize their names. But Captain America’s name has to be capitalized. Modify the code so that you can use lowercase to type in captain america’s name. Exercise 11: Nicknames . What happens if you just type in “cap” instead of “captain america”? It doesn’t work right. Let’s fix that. Make it so that you can enter in nicknames like “cap” or “tony” and it’ll still work. Exercise 12: Black Widow . Black Widow was also hanging out with the rest of her team. Let’s add her in to the story. Create a new branch where she tries to lift the hammer, and print out what happens when she tries. ",
    "url": "/labs/control_flow.html#not-always-doing-the-same-thing",
    "relUrl": "/labs/control_flow.html#not-always-doing-the-same-thing"
  },"28": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you and your partner finish all of the exercises before the end of class, try at least one of the challenges below: . Challenge 1: Two-part Mad-libs . Take the mad-libs program that you worked on, and create a second part of the mad-libs. So you input a bunch of words, and it prints out part of a story / song / something. Then you get a chance to input more words, and it prints out the second half. You’ve already got a first half of the mad-libs program written. Add a second half to your mad-libs program. Challenge 2: Avengers Mad-Libs . Turn the Avengers story into mad-libs. Replace some of the words with variables, and then fill in the variables at the beginning of the program with funny words. Challenge 3: Chat bot . Make a new program called chat.py. Revisit exercise 4 if you need a reminder on how to do this. Your program should ask the user a question, collect input from the user, then give a different answer in response depending on what the user says. For example, if the user says “no”, respond with one phrase. Else if (elif) they say “yes”, respond with a different phrase. You can use as many elifs as you want to catch different types of user input. You can also use else at the end to catch any user response that doesn’t match with your if or elif cases. ",
    "url": "/labs/control_flow.html#challenges",
    "relUrl": "/labs/control_flow.html#challenges"
  },"29": {
    "doc": "Lab",
    "title": "Turn in your work",
    "content": "Today, you’ll turn in screenshots of your code working (programs running in PowerShell or Terminal) and the .py files you edited for today’s exercises. Turn everything in on D2L, under Assignments -&gt; Lab 2 Screenshots and Code. For a refresher on taking screenshots, see the screenshot reference page. ",
    "url": "/labs/control_flow.html#turn-in-your-work",
    "relUrl": "/labs/control_flow.html#turn-in-your-work"
  },"30": {
    "doc": "Lab",
    "title": "Lab",
    "content": "The first thing you need to do today is to create a copy of the files you’ll need for the lab. These files are in the git repository linked above. Last week, you only downloaded one file. This week, download the full repository. Find the download button (next to the blue “Clone” button) on the main repository page and choose the “.zip” option. It will download as a .zip folder on your computer. Once you get the repository on your computer, you may need to unzip it to be able to work with the files inside. On Windows, right click on the file and choose ‘Extract All’ - this will create a new folder with the same name. On Mac, double click on the folder and it will do the same thing. You should have a folder named ‘control-flow-master’ with 5 files in it: . | README.md | avengers.py | hello.py | mad-libs.py | mad-libs-input.py | . The goal of these labs is to practice. Each lab will be a series of exercises and challenge to practice the concepts you were introduced to in the readings/videos for the week. You’ll continue practicing the concepts from this lab in the studio this week, and in future labs and studios. Many of the concepts build on each other and can be used in combination with one another. As with all labs, this lab will be done in pairs. Remember to switch places every so often! Everyone should spend at least part of the class as the driver, and at least part of the class as the navigator. ",
    "url": "/labs/control_flow.html",
    "relUrl": "/labs/control_flow.html"
  },"31": {
    "doc": "Lab",
    "title": "Counting in a loop",
    "content": "Exercise 1: Count . As an example of how to do loops, look at the file counter.py in the Git repository. The program is supposed to count to 5. Run the program to see what it does. Then open the file and look at the code. How does it work? Read the code and see if you can figure out how this program works. Does it do anything you’re not expecting? . Edit the program so that it counts to 5 the way a person would count (that is, starting at 1). Hint: When Python counts using numbers, it starts at 0 by default. Hint 2: There are multiple ways to do this. One way is to use an increment, another is to modify the range. range() can take more than one value at once! Check out this week’s readings for more detail. Exercise 2: Print a random number . Right now when you run counter.py, it only counts to 5. It counts to 5 every single time. Let’s give it a random number to count to instead. First, let’s test out the random module by printing some random numbers outside of the for loop. We have to tell Python we’re using the module first, though. Do this by adding import random at the top of the counter.py program, above the for loop. Let’s generate a random number and print it out (outside of the for loop!) so we know it’s working. Try putting random.random() inside of a print statement: this will print out a number between 0 and 1. Run the program a few times and you’ll notice the number changing. The first number I got when I ran it was 0.4094163341030903. The numbers you get will be different. That’s cool, but counter.py only works well with whole numbers. You can use random.randint(x,y) to generate a whole number inside of a range of numbers, where x is the smallest number and y is the biggest. Try generating a number between 1 and 10 and print it out. Run the program a few times to make sure it’s giving you different numbers. Note: the for loop will still be running whenever you run the program. The first number that prints out when you run it will be the random number. Exercise 3: Count to a random number . The for loop is still running, and still only counts to 5. Let’s make it count to a random number instead. You’re already generating a random whole number, but you’re only printing it out. Let’s add it to the for loop so that instead of running 5 times, it will run a random number of times. You can do this by storing the random number in a variable called count and then using the variable inside of range() in the for loop. Note: You can get this to work without using a variable at all, but it’s good practice to store values in variables before using them in other functions, like print() or range(). You’ll see why in the next exercise! . Exercise 4: Add some text . The program only spits out a bunch of numbers. Let’s make it a little more user friendly by adding some text to tell the person running it what it’s doing. Print out a line of text that says The program is counting to X, but replace X with the random number you’re generating. Hint: This should be easy to do if you stored your random number in a variable! Look at mad-libs.py from the Control Flow lab if you can’t remember how to use a variable inside of a print statement that already has other text in it. Hint 2: You’ll need to figure out where the best place is to put this print statement. Should it be before the loop, after the loop, or inside of it? Do what you think will make the most sense to a user who is running the program. ",
    "url": "/labs/counting_and_loops.html#counting-in-a-loop",
    "relUrl": "/labs/counting_and_loops.html#counting-in-a-loop"
  },"32": {
    "doc": "Lab",
    "title": "Change places with Git",
    "content": "Now is a good time to save your changes to Git and trade driver positions with your partner. The old driver should add, commit, and push their code, and then make sure their changes show up in GitLab. The new driver should use git pull to pull the changes their partner made down to their computer. For a refresher, see Using Git in the reference section on the course site. ",
    "url": "/labs/counting_and_loops.html#change-places-with-git",
    "relUrl": "/labs/counting_and_loops.html#change-places-with-git"
  },"33": {
    "doc": "Lab",
    "title": "Singing a song",
    "content": "Exercise 5: Looping verses . If you run the program bottles.py in the git repository, it will print out the first verse of the song 99 bottles. Let’s start small! Modify the program so it repeats the verse 5 times. Don’t worry about number of bottles in each verse just yet; just get the loop working. Your code should only be 5 lines in total. Hint: range(5) will count from 0 to 4. It always stops just before it gets to the end number. range(1, 5) will count starting at 1, so will count from 1 to 4. range(5, 1, -1) will count by -1, so it will count backwards from 5 down to 1. Hint 2: Python using indentation to figure out which blocks of code belong together. Code that runs inside a loop in Python means the code that will loop will start on the line underneath the loop statement and will be indented. for i in range(x): # this is the loop statement print(i) # code here will repeat with each loop - notice how it's indented print(\"This is outside of the loop\") # this code will NOT repeat because it's not indented . Exercise 6: Make the number of bottles go down . Now modify the code so that the number of bottles counts down with each verse, like in the song. Hint: A for loop uses a variable. In for i in range(10), the i is a variable. You can use that variable inside the loop. Each time through the loop, the for loop fills in that variable with the current number. So the first time through the loop, i is 0; the second time, it is 1, the third time is 2, and so on. i will have different start and end points depending on what you include in range(). Exercise 7: All the verses . Now modify the program to print out all 100 verses of the song. The last verse should have 0 bottles in the last line. At this point, your program should still only have 5 lines of code! . Exercise 8: Change the final verse . Modify your program to change the final verse of the song. Rather than singing zero, have it sing a different ending. For example, here is one alternative ending to the song: . No more bottles of beer on the wall, no more bottles of beer. We've taken them down and passed them around; now we're drunk and passed out! . Feel free to write your own lyrics for the last verse! . Hint: There are multiple ways to do this, and none of them is wrong. A question to ask: should the new verse be inside of the loop or outside? . Exercise 9: Change the 6th-to-last verse . There is an alternative way to sing the 99 bottles song, where the 3rd line is replaced with: . If one of those bottles should happen to fall, 98 bottles of beer on the wall... Modify your program so that the 6th-to-last verse (“5 bottles”) uses this alternative line instead of the normal line. Hint: You can use an if statement inside the loop to check which loop you are on, and print out something different if you are on a specific loop. ",
    "url": "/labs/counting_and_loops.html#singing-a-song",
    "relUrl": "/labs/counting_and_loops.html#singing-a-song"
  },"34": {
    "doc": "Lab",
    "title": "Change places with Git",
    "content": "This is another good time to save your changes to Git and trade driver positions with your partner. The old driver should add, commit, and push their code, and then make sure their changes show up in GitLab. The new driver should use git pull to pull the changes their partner made down to their computer. For a refresher, see Using Git in the reference section on the course site. ",
    "url": "/labs/counting_and_loops.html#change-places-with-git-1",
    "relUrl": "/labs/counting_and_loops.html#change-places-with-git-1"
  },"35": {
    "doc": "Lab",
    "title": "Guessing game",
    "content": "For loops are great if you want a loop to run a set number of times, and to stop once that number is reached. They’re not so great if you want a loop to keep running for some undefined amount of time – usually until something specific happens. That’s where while loops come in. Exercise 10: Play a guessing game . Run question.py. Right now, it asks one question, then tells you if you’re right or wrong. Let’s change the program so it keeps asking the question until the user gets it right. You can do this with a while loop. There are two parts to a while loop: the condition that makes the loop run, and the condition that causes the loop to end. The most basic while loop starts with while True: – everything inside of it will keep running until it reaches a condition which causes the loop to end. The True part of it means everything in the loop is true, until proven false (that is, until it breaks!). Remember: Python sees code as being inside of other code by looking at how the code is indented. The other piece the loop needs to have is a condition in it that causes it to end. Important: The keyword break is used to signal that the loop should end. If you don’t break a while loop somewhere, it will keep running forever! . A basic while loop looks something like this: . while True: stuff to repeat if &lt;condition to be met&gt;: break . Set up question.py so it keeps asking the question, and then end the loop with break when the question is answered correctly. Exercise 11: Ask a different question . Change the question and the answer to something interesting about yourself. My example of my favorite color is very boring. I’m sure you can come up with a more interesting fact about yourself than that. Exercise 12: Ask another question . Ask a second question. Once the user has succesfully answered the first question, the program should start asking the second question. Hint: You’ll need a second loop for this! . Git . At this point, you should have modified versions of all 3 programs for this lab. Make sure all of the modifications you’ve made on your own computers are pushed to your Gitlab repository! This is how you’re turning your code in for this lab, and for all future labs. ",
    "url": "/labs/counting_and_loops.html#guessing-game",
    "relUrl": "/labs/counting_and_loops.html#guessing-game"
  },"36": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you finish the lab before the end of class, please try to do at least one of the challenges. If you can get one or more of the challenges working correctly, then you can leave class early. Check in with Caitlin or Jack first before you leave. Challenge 1: Alternate lines . Modify your bottles program so that every other line uses the alternative version. So the first verse should say take one down, pass it around, the second verse should say if one of those bottles should happen to fall; the third verse should say take one down, pass it around, and so on. Hint: Python has a modulus operator: %. Modulus finds the remainder after division. So 13 % 5 is equal to 3, since when you divide 13 by 5 ,you get 2 with a remainder of 3. You can use this to figure out if a number is even or odd: if the line number divided by 2 has a remainder of 0, then it is an even number. If the line number divided by 2 has a remainder of 1, then it is an odd number. Challenge 2: Random number of bottles . Use the random module to make the song start at a random number of bottles rather than at 100. When you do this, think about practicalities - you need the number it generates to be a whole number, but don’t want it to be too many digits or else your program will take forever to run. Remember to include import random at the top of the program! . Challenge 3: Limited tries . In question.py, change the code so it only lets the user try to answer the first question 3 times before it moves onto the next question. How would you do this with a while loop? (hint: there are examples in this week’s reading on loops.) How would you do it with a for loop? Bonus: use a while loop for the first question, and a for loop for the second question. Remember the loop still needs to end immediately if the user guesses the answer correctly. Challenge 4: Random guessing game . Make a guessing game that generates a random number and then asks the user to guess the number. It should work similarly to question.py in that it keeps asking the user to guess until the user gives the correct answer. Make it user friendly, too - print out some introductory text to introduce the user to the game and describe how to play. Remember to include import random at the top of the program! . I recommend making a new file and calling it random-guess.py for this challenge. Make sure to save the file in the same folder as your other code for this lab. Some of the code you wrote in question.py and counter.py might be helpful to copy+paste into the new file as you write the program. ",
    "url": "/labs/counting_and_loops.html#challenges",
    "relUrl": "/labs/counting_and_loops.html#challenges"
  },"37": {
    "doc": "Lab",
    "title": "Lab",
    "content": "For this lab, we are going to use a Git repository like we did for last week. The first thing you should do is fork this week’s GitLab project (linked above). Only one person needs to create a forked project. Once forked, add your partner to the project (and Caitlin and Jack), and then clone the repository onto your computer. Check out the Git reference for a reminder on how to do this. ",
    "url": "/labs/counting_and_loops.html",
    "relUrl": "/labs/counting_and_loops.html"
  },"38": {
    "doc": "Readings",
    "title": "Readings",
    "content": ". | Using dictionaries to store data as key-value pairs | Automate the Boring Stuff: Chapter 5 - Dictionaries and Structuring Data – skim | Think Python: Chapter 11 – skim up to “11.6 Memos” | . ",
    "url": "/readings/dictionaries.html#readings",
    "relUrl": "/readings/dictionaries.html#readings"
  },"39": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For this week’s summary, think about what you already know about other ways of storing data in Python, like variables and lists. Think about how dictionaries are different from those structures. Summary prompt: What do you think dictionaries might be useful for in Python? . ",
    "url": "/readings/dictionaries.html#summary",
    "relUrl": "/readings/dictionaries.html#summary"
  },"40": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Tuesday. ",
    "url": "/readings/dictionaries.html#question",
    "relUrl": "/readings/dictionaries.html#question"
  },"41": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Dictionaries are another data structure in Python. We’ve used variables, which can store one thing, and lists, which can store many of the same thing. Dictionaries are a little like lists, except more structured. Things stored in dictionaries are stored in pairs. These pairs are called “key-value pairs” and work like actual paper dictionaries, which have words with definitions attached to them. The word is the key, and the definition is the value associated with that key. ",
    "url": "/readings/dictionaries.html",
    "relUrl": "/readings/dictionaries.html"
  },"42": {
    "doc": "Lab",
    "title": "Working with Dictionaries",
    "content": "Dictionaries are key/value stores. They are similar to lists, but differently structured. In a list, values are stored in order: 0, 1, 2, etc. In a dictionary, values are stored by name. The name is called the ‘key’ of the dictionary. To create a dictionary, we use the curly braces: {}. Everything between the curly braces is part of the dictionary. We can create dictionaries in python like this: . my_dictionary = { 'word': 'definition', 'word2': 'definition2' } . Any time you need the definition of a word, you can ask python for my_dictionary['word'] and it will provide the definition for that word. You can also create a blank dictionary and add stuff to it later, like with lists. The process of adding things is slightly different, though. my_dictionary = {} my_dictionary['word'] = 'definition' . The second line adds a single key-value pair to the dictionary called my_dictionary. I’ve used the terms ‘word’ and ‘definition’ - paper dictionaries are structured like this, and that’s loosely what Python dictionaries are based on. But Python dictionaries are more flexible than that. You can have them store anything you like. Today’s lab is long, but some of the exercises are pretty easy. If you get through everything, then great! If you don’t, then that’s OK too. Dictionaries are really useful, but also a somewhat weird way to think. It can take some time to figure out how they work and how to do things with them. ",
    "url": "/labs/dictionaries_as_data_structures.html#working-with-dictionaries",
    "relUrl": "/labs/dictionaries_as_data_structures.html#working-with-dictionaries"
  },"43": {
    "doc": "Lab",
    "title": "Using dictionaries",
    "content": "Exercise 1: Print out a mascot . Start by looking at the program mascots.py. There is a dictionary full of schools and mascots, where the name of each school is associated with its mascot. If you give the dictionary the name of a school, the dictionary will spit back out the mascot for that school (much like if you look in a real-world dictionary for a word, it gives you back the defintion of that word). We use this feature in the first print statement. We give the dictionary the name \"Wisconsin\". When we run the program, it goes into the dictionary and gets the mascot for Wisconsin and prints out “badgers”. Modify this program to print out the mascot for Ohio State. Note: you should not have to change the dictionary for this exercise, and at no point should you have to type “Buckeyes”. You should be able to do this by just changing the print statement on line 10 to use a different school. Exercise 2: Add another mascot . Your next task is to modify the dictionary and add another school’s mascot to the dictionary. The University of Washington was just added to the Big 10 this year. Let’s add “Washington” to the dictionary, along with their mascot (UW folks are called “Huskies”). Modify the dictionary to include Washington and its mascot, and then modify the print statement so it prints out the mascot for Washington. Exercise 3: Ask the User . Right now, all the program does is print out a single mascot for a single university. What if you want to know a different university’s mascot? Let’s modify the program to be a bit more interactive. After creating the dictionary, add some code that uses input() to ask the user which university they want to know the mascot for. Then the program should print out the mascot for whatever university the user entered by looking it up in the dictionary. The output of the program should look similar to this: . What university do you want to know the mascot for? Wisconsin People who go to Wisconsin are called Badgers . Your program should NOT use any if statements. You should be able to do this by collecting input from the user, storing in a variable, and then using that variable to look up the answer in your dictionary. Hint: Don’t forget to change the school’s name in the print statement to whatever the user typed, in addition to printing out the mascot. ",
    "url": "/labs/dictionaries_as_data_structures.html#using-dictionaries",
    "relUrl": "/labs/dictionaries_as_data_structures.html#using-dictionaries"
  },"44": {
    "doc": "Lab",
    "title": "Storing structured data",
    "content": "Exercise 4: Print out favorite food . Next, look at the file student.py. Run it; it should print out some information about me (your instructor). Right now, the program prints out my name and major. But the dictionary stores one more piece of information about me: my favorite food. Modify the program to also print out my favorite food by adding an additional print line. Exercise 5: Change the dictionary to your partner’s information . Now that the program is printing out all of my information, change whose information it prints out. Ask your lab partner for his or her information, and change the information in the dictionary to his or her information. To do this exercise, you should only change the information inside the dictionary; you should not need to change the print statements at all. Exercise 6: Add favorite color . Name, major, and favorite food are great, but that isn’t much information about a person. Add to the program the ability to store the person’s favorite color, and also print out that favorite color. BUT instead of just editing the dictionary directly again, this time we’re going to add the information using a separate line of code. The format dictionary[key] = value will add a new key and value to the dictionary. In this example, dictionary, key, and value are all generic - you’ll need to replace them all with information specific to this program. Make sure to add a new print statement to print out the person’s favorite color. Hint: If you’re not sure the information is being added to the dictionary correctly, you can always print out the dictionary’s structure in the console to check using print(student). Printing things to the console can be a helpful way to troubleshoot your code. Exercise 7: Ask the user for more information . Now let’s ask the program’s user for additional information using input() and add it to the dictionary. Ask them what their favorite movie is, and add that information to the dictionary. Make sure to add a new print statement to print out the person’s favorite movie. Hint: You can use the same structure as in the last exercise, but instead of hard-coding the value, save the user’s input to a variable and use the variable as the value instead. The key should probably be something like 'favorite_movie'. ",
    "url": "/labs/dictionaries_as_data_structures.html#storing-structured-data",
    "relUrl": "/labs/dictionaries_as_data_structures.html#storing-structured-data"
  },"45": {
    "doc": "Lab",
    "title": "Structured data into functions",
    "content": "One of the advantanges of dictionaries is that you can store complex data – such as all of the information about a student – in a single variable. That means that you can pass that single variable into a function. Exercise 8: Passing a dict into a function . Next, let’s order a pizza. Go run the program “pizza.py”. It prints out my normal Monday pizza order. Open of the file and look at it. There is a function called print_pizza_order that takes a single variable as a parameter – the pizza order. This order is a dictionary that contains all of the information needed for the order – the size of the pizza, the type of crust, and any toppings. The function then uses the information in the dictionary to fill in some print statements. Modify the program to print out my normal Friday order. You should be able to do this by changing exactly one word in the program. Exercise 9: Your pizza! . OK, time for you to order a pizza. Add a new variable to the program under friday. That variable should contain a dictionary with your pizza order – whatever type of pizza you like! Then modify the program to have it print out your order instead of mine, by calling print_pizza_order() and passing in the dictionary with your order. Note: There can be multiple values assigned to a single key in a Python dictionary - which means you can theoretically have multiple toppings. We’ll get to this in a later exercise – for now, only add one topping. ",
    "url": "/labs/dictionaries_as_data_structures.html#structured-data-into-functions",
    "relUrl": "/labs/dictionaries_as_data_structures.html#structured-data-into-functions"
  },"46": {
    "doc": "Lab",
    "title": "List of dictionaries",
    "content": "We’ve learned both lists and dictionaries. You can combine these in interesting ways. Exercise 10: Random pizza order . Sometimes I am so hungry I can’t decide what I want on my pizza. That’s when a random pizza ordering program would be useful. We know from previous labs that we can use random.choice() to pick a random item out of a list. Let’s use this with our pizzas. Modify the pizza program to take the three orders that already exist – my Monday order, my Friday order, and your favorite pizza – and put them into a list. Then have the program use random.choice() to pick a random item out of that list, and give that choice to print_pizza_order() to print out the full order. Don’t forget to import random at the top of your program. Hint: You can make a list of dictionaries. The easiest way is to put each dictionary in a variable, and then put those variables into a list: . cheese_pizza = {'crust': 'traditional', 'toppings': \"cheese\"} pepperoni_pizza = {'crust': \"thin\", 'toppings': \"pepperoni\"} pizza_list = [cheese_pizza, pepperoni_pizza] . Exercise 11: Lists inside of dictionaries . Dictionary keys can also be paired with lots of different kinds of things, including lists. Look in the file deluxe.py. This file contains a pizza order inside a dictionary, but instead of having one topping, it has a list attached to the toppings key. The print_pizza_order() function is also in deluxe.py, but it doesn’t quite work with this dictionary. Run the program to see what it prints out. Remember how to access items in a dictionary. Just like pizza['crust'] will give you a string with the type of crust, pizza['toppings'] will give you a list of strings. You can then do the things you would normally do with a list, such as accessing the first item (pizza['toppings'][0]) or looping through the list (for item in pizza['toppings']) or getting the length of the list using len(pizza['toppings']). Modify the function so it loops through the toppings list and prints out each topping one by one, like this: . I would like a extra large pizza on a thin crust With 5 toppings on it: - pepperoni - black olives - green peppers - sausage - mushrooms . Hint: When a list is stored inside of a dictionary (e.g. toppings), you can get the whole list at once using the dictionary syntax pizza['toppings']. Then you can loop through it like any other list using a for loop: . for top in pizza['toppings']: print(top) . Hint 2: Remember you can use len() to get the length of a list - that will be helpful for the “With X toppings on it” line. Exercise 12: Delivery Address . In the previous exercise, you stored a list inside of a dictionary. The key in the key-value pair is always a string, but the value can be anything you want. Here is a dictionary that contains a delivery address for the pizza: . address = { 'street': \"1278 Spartan Dr\", 'city': \"East Lansing\", 'state': \"Michigan\", 'zip': 48864 } . We want to put this address inside of the pizza order, so we know where to deliver this pizza. We can do this by modifying the pizza order: . cheese_pizza = { 'crust': \"traditional\", 'size': \"large\", 'toppings': ['cheese'], 'delivery': address } . Notice that I did not put quotes around the address. In Python, if you put something in quotes, it’s a string. The only information a string stores is the text inside the quotes. But I don’t to delivery to be linked to the word \"address\", I want it to link to the dictionary that is stored in the variable address. So I use address without quotes to point to the variable. You access this is basically the same way as before. If you access cheese_pizza['delivery'], it gives you a dictionary of information. And then you can use the same technique to get items out of that. So cheese_pizza['delivery']['street'] will tell you the street address that you are delivering it to. Add the address dictionary to deluxe.py (you can change the address info if you want) and then reference the address dictionary inside the deluxe_pizza dictionary. Modify the print_pizza_order() function to print out the address the pizza should be delivered to. Your function should still just accept one parameter – a dictionary with the pizza order. Exercise 13: Pretty print . Now that we are getting more and more complicated dictionaries, it is sometimes useful to print out the contents of a dictionary to the terminal so we can better see what it looks like. Modify your program to just call print(pizza) – that is, to use the regular print function and passing it the dictionary. This gives you the information, but it is hard to read. Another, clearer way to do this is called “pretty printing”. This tries to format the dictionary in a way that is easier for humans to read. We can use the ``pprint` library to pretty print. import pprint pprint.pprint(deluxe_pizza) . Modify your deluxe.py program to pretty print the entire dictionary your pizza. We don’t normally do this in code that is intended for other people to use. But pretty printing a dictionary is a great way for us to see what the dictionary looks like, and is a useful tool for writing (or reading!) code that uses dictionaries. ",
    "url": "/labs/dictionaries_as_data_structures.html#list-of-dictionaries",
    "relUrl": "/labs/dictionaries_as_data_structures.html#list-of-dictionaries"
  },"47": {
    "doc": "Lab",
    "title": "Thinking about structured data",
    "content": "All of these exercises today are using dictionaries in a very specific way, and in a way that is different than how we used them before. All of these exercises are using dictionaries to store “structured data” – complex data that is made up of multiple different pieces of information that are grouped into a logical whole. A student is a logical whole, but the information about that student has multiple different pieces. Same with a pizza order. In our structured dictionaries, the keys define the structure of the data. So we have keys that look like “crust”, “toppings”, or “name” – they are words in quotes. The values associated with those keys are the actual data. Dictionary keys provide a template for the types of data that are associated with them. It can be helpful to think of a dictionary as a repeatable template that is full of metadata. Think about fill out a form: a form might have a bunch of items like name, birthdate, address, etc. with blank spaces next to them that you fill out. The same form can be used by a lot of different people, who all will fill the blanks with different data. But the structure of the form – the items that need to be filled in – is the same for everyone. Exercise 14: Structuring Data . Now that you have experience working with dictionaries to store structured data, it is time to create the a structure yourself. Create a new file called songs.py. Think about apps you use to play music - Spotify, iTunes, etc. A playlist in these apps will have a bunch of songs in them, and each song has different pieces of data associated with it so that you can tell what song is playing at any given time. These pieces of data are often called metadata - the song itself is the data, the data associated with the song is data about the data. For songs, this is stuff like the artist, the album the song is on, the length of the song, the year it was released, etc. What other metadata can be associated with a song? . Make a dictionary structure that will store metadata about a song. The structure should be repeatable: that is, you should be able to put the metadata for different kinds of songs into it and the structure will still work. Think of contingencies - for example, what if a song has more than one artist? Create multiple dictionaries to test: each dictionary should have the data for a single song in it. Print out the data for each song in the console using a function similar to the print_pizza_order() function from the previous exercises. Make sure the function works with different songs. ",
    "url": "/labs/dictionaries_as_data_structures.html#thinking-about-structured-data",
    "relUrl": "/labs/dictionaries_as_data_structures.html#thinking-about-structured-data"
  },"48": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "Please complete at least one challenge before leaving for the day. It is up to you which one you do. Have the instructor or TA come over and see the results of your challenge before you leave. Challenge 1: Input pizza order . Right now, the pizza orders are hard-coded into your Python program. Modify your program to instead ask the user what they want to order using input(). You’ll have to ask multiple questions, and then assemble the results into a dictionary. The dictionary should be able to be printed using your existing print_pizza_order() function. Bonus: put your questions and input() commands into a function that returns the complete dictionary. Challenge 2: Calculate GPA . Modify the student program to store a list of grades in the dictionary for the student. Then write a function that goes through the student’s grades and calculates their GPA. Challenge 3: Song randomizer . Modify the the songs.py program you made for exercise 14 to print out a randomized song playlist. Bonus: format the song list nicely using Turtle. ",
    "url": "/labs/dictionaries_as_data_structures.html#challenges",
    "relUrl": "/labs/dictionaries_as_data_structures.html#challenges"
  },"49": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/labs/dictionaries_as_data_structures.html",
    "relUrl": "/labs/dictionaries_as_data_structures.html"
  },"50": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Read the first article in full; it’s short, and will give you a basic idea of what we’ll be doing in the lab. The other two readings go much more in depth. Skim them and read parts that are interesting to you, but don’t spend too much time on them – skim with the goal of getting more familiar with the different things Turtle can do. | The Python Turtle Library, Step by Step | (Skim) Ch 13: Turtle Graphics – Stop reading at 13.5 Visualizing recursion; don’t read that section or anything after it | (Skim) Turtle Documentation – Everything the turtle can do, in way too much detail (this is a great resource!) | . ",
    "url": "/readings/drawing.html#readings",
    "relUrl": "/readings/drawing.html#readings"
  },"51": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For the summary this week, think about all of the different things you’ve learned about what Turtle can do. Summary prompt: Why do you think we’re learning Turtle for this class? What would you like to be able to do with programmatic drawings? . ",
    "url": "/readings/drawing.html#summary",
    "relUrl": "/readings/drawing.html#summary"
  },"52": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Monday. ",
    "url": "/readings/drawing.html#question",
    "relUrl": "/readings/drawing.html#question"
  },"53": {
    "doc": "Readings",
    "title": "Readings",
    "content": "This week we’ll start using Python to draw images on the screen. We will be using a library called Turtle. There are a ton of commands you can use with Turtle - don’t worry about memorizing them all. ",
    "url": "/readings/drawing.html",
    "relUrl": "/readings/drawing.html"
  },"54": {
    "doc": "Lab",
    "title": "Using Functions",
    "content": "In your readings, you learned about functions. Functions are named sections of code that you can “call” from other parts of code. Functions let you use the same chunks of code over and over again without having to write it all out each time. In this section of the lab, we will be using the cards.py program. The top of this program defines 4 functions in it: one that draws a diamond, one that draws a heart, one that draws a club, and one that draws a spade. You shouldn’t need to modify or change these functions; leave them in the program. If you run the program, it just draws a spade right now (because, at the end of the file, we call the spade() function). Exercise 1: Draw a club . Change cards.py to draw a club instead of a spade. This should only involve changing one line of code in the program. Exercise 2: Draw a heart . Next, change the program to draw a heart instead of a spade. Again, this should only involve changing one line. Exercise 3: Draw a spade and a heart next to each other . Next, change the program to draw a spade and a heart next to each other. You shouldn’t need to change the functions at all. Instead, you should call the spade function, then move the turtle, and then call the heart function. Hint: Remember you can use penup() and pendown() so that you don’t draw a line in between drawing the two shapes. Exercise 4: Draw two clubs and a diamond next to each other . Finally, modify your program to draw two clubs and a diamond next to each other. ",
    "url": "/labs/drawing_with_functions.html#using-functions",
    "relUrl": "/labs/drawing_with_functions.html#using-functions"
  },"55": {
    "doc": "Lab",
    "title": "Creating your own functions",
    "content": "In cards.py, the code I gave you used def spade(): to define the spade function. All of the indented lines after that are part of that function. You can use def to create your own functions. Exercise 5: Fill in a function that draws a star . Look at the program stars.py. It has the line def star(): near the top of the program. That is creating a new function that is supposed to draw a star. However, right now, the code for the function (everything indented below it) just says pass. This is a placehoolder: pass is Python’s way of saying “do nothing”. Modify the star function to include the code for drawing a star. When you run the program, it should look like this: . Hint: Remember, it is OK to look at past labs (and the solutions to past labs) for help. You probably drew some stars in the Turtle lab. Hint 2: You can speed up the turtle by putting the command speed(0) near the top of your program. ",
    "url": "/labs/drawing_with_functions.html#creating-your-own-functions",
    "relUrl": "/labs/drawing_with_functions.html#creating-your-own-functions"
  },"56": {
    "doc": "Lab",
    "title": "Functions with parameters",
    "content": "So far in this lab, we have just used functions as a way of organizing our program. Basically, we give a section of our program a name, and then we can “call” that function – which runs the section with the name. This is a really useful feature of functions. Remember how long and confusing the code was for your flags two weeks ago. If we broke it up into logical pieces – the piece that draws a bar, the piece that draws a star, etc. – then we can give each of those pieces a name and make them a function. This would make the code easier to understand, and also allow you to use each chunk of code multiple times. Functions can do more than just that, though. They can also have parameters that modify what they do. The parameter is what goes inside of the parentheses for a function name. For example, forward() is a function that takes one parameter: a number which specifies the distance in pixels that the Turtle should move forward. You can put any number you like into the forward() function, and it will move the Turtle that many pixels forward. Parameters make functions more flexible. Parameters are like variables that you can put different things into to make the function do different things every time you call it. The forward() function in Turtle will move a different distance depending on what number you give it, for example. Exercise 6: Sizes of Stars . Look at the program sizes.py. It has a function called star that draws a star. Except unlike the star function you wrote above, it accepts a parameter – size. This parameter tells it how big of a star to draw. When you define a function that has parameters, you also define the parameters, like this: . def star(size): . This defines a function called star(), with one parameter, called size. The parameter is a variable that is specific to the function: it will be filled in later when you call the function. The code inside the function should say where the parameter is used. Notice where size is used inside of the star() function. Right now that program draws a single star of size 25. Modify the program so that it draws 3 stars next to each other, each one bigger than the other (25, 50, 100). When complete, it should look like this: . Hint: because you’ve added a parameter, when you call the star() function now, you have to call it with the parameter filled in or Python will give you an error. Hint 2: remember you’ll need to write some code to move the turtle between drawing each star so the stars don’t overlap. Exercise 7: Colored bars on a flag . Next, look at the program flag.py. The goal of this program is to draw the flag of Germany, but the program isn’t done yet. Since each of the three bars is the same thing except a different color, I decided to write a bar() function that draws a single bar. That function takes one parameter – bar_color – that tells the function what color to make the bar. We’ll ignore the parameter for now and come back to it in the next exercise. Let’s start by writing a simple bar() function that just draws a 300x50 rectangle. If you put the code to draw a rectange into the bar() function, then it should look like this when it works: . Hint: the code that moves the turtle into position before drawing the next bar expects the turtle (the arrow) to be in the same position and angle it started in before drawing the bar. Exercse 8: German Flag . Let’s continue to modify the flag program to draw the flag of Germany: three colored bars that are black, red, and yellow. The bar() function accepts one parameter – bar_color. When it is used at the bottom of the file, it calls bar() three times, each time asking to draw a different colored bar. Modify the code for the bar function to color that rectangle whatever color the parameter says it should be. Remember the parameter is like a variable; it will be filled in with a ‘real’ value when the function is called. Your program should look like this: . Hint: pencolor() changes the color of the outline, fillcolor() changes the fill color. color() changes the color of both the outline and the fill. Which should you use to get it to look like the screenshot above? Also remember to use begin_fill() and end_fill(). Exercise 9: Flag of Ghana . You now have a function that draws horizontal bars, and a function that draws a star of a different size. As the next exercise in this lab, create a new program called ghana.py and copy both of those functions into it. Use those functions to write a program that draws the Flag of Ghana. Your program should use the bar() function and the star() function to draw the colored bars and the black star. You shouldn’t need to modify the bar function. You will need to modify the star() function so it draws a black star instead of an outline. To draw the flag, you should only need to call the functions with the right colors and write a bit more code to move the turtle to the right places. ",
    "url": "/labs/drawing_with_functions.html#functions-with-parameters",
    "relUrl": "/labs/drawing_with_functions.html#functions-with-parameters"
  },"57": {
    "doc": "Lab",
    "title": "Your own functions",
    "content": "So far in this lab, you have used functions that I wrote, and filled in functions that I created. Next, you need to write your own function. Exercise 10: Next Suit Function . Go back to the cards.py program. Write a move_next() function that moves the turtle to a place to get it ready to draw the next suit. Once your function works, you should be able to use it like this: . spade() move_next() heart() move_next() diamond() . ",
    "url": "/labs/drawing_with_functions.html#your-own-functions",
    "relUrl": "/labs/drawing_with_functions.html#your-own-functions"
  },"58": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you complete all of the exercises before the end of class, try at least one of these challenges: . Challenge 1: Random color stars . Modify stars.py to include a parameter for the color of the star called star_color. Use the list of colors below and random.choice() so that when each star in the circle is drawn, it draws as a random color from the list. You’ll need to modify where star() is called inside the for loop so that it’s called using the parameter. colors = [\"red\",\"orange\",\"green\",\"blue\",\"yellow\",\"light blue\",\"purple\"] . You can put more colors into the list if you want to. Note: remember to add import random to the top of your program. Challenge 2: 5 suits . Go back to your cards.py program and modify it to ask the user which suit it should draw. Then draw the suit that the user specifies. Put this user input into a loop: Ask the user 5 times what suits they want drawn, and then draw those five symbols next to each other on the screen. Bonus: keep drawing suit symbols until the user says to stop. Challenge 3: Different star sizes . Modify the stars program to draw circles of different sized stars. You’ll probably want to use a parameter for the size. You can use the random library to vary the size randomly, but you don’t have to. What are other different ways you could change the sizes of the stars? . Challenge 4: Draw the original U.S. flag . The Betsy Ross varient of the original U.S. flag had 13 stars in a circle on the blue part of the flag. The code in stars.py draws a circle of 13 stars. Use the star() function, the loop that draws the circle of stars, and the bar() function to draw the original U.S. flag. You’ll probably need to modify the bar() function so it draws skinnier bars. ",
    "url": "/labs/drawing_with_functions.html#challenges",
    "relUrl": "/labs/drawing_with_functions.html#challenges"
  },"59": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/labs/drawing_with_functions.html",
    "relUrl": "/labs/drawing_with_functions.html"
  },"60": {
    "doc": "Error messages",
    "title": "Reading error messages",
    "content": "For Python, error messages usually have 3 parts: . | What file the error is in and the line number in the file that the error is on (or near) | The actual line of code causing the error | The type of error and a brief explanation of what the error is | . Example . PS C:\\Users\\geier\\Desktop\\mi250&gt; python avengers.py\" File \"c:\\Users\\geier\\Desktop\\mi250\\avengers.py\", line 2 if (person == \"Thor\") or (person == \"thor\") ^ SyntaxError: expected ':' . From the first two lines, you can tell that the error is in the file avengers.py. You can also tell that the error falls on line 2 in that file. In the next line of the message, it shows the line of code that caused the error to happen. Notice the arrow pointing up at the blank space at the end of the line of code. There will often be arrows underneath the code like this. Sometimes they can be very helpful: in this case, it’s indicating that something is missing. The last line shows the type of error (SyntaxError) and a brief description of what’s wrong. For this error, it says Python is expecting a colon character (:) on that line of code. if statements always need to end with a colon. The arrow on the previous line points to where the colon is supposed to be. ",
    "url": "/reference/error_messages.html#reading-error-messages",
    "relUrl": "/reference/error_messages.html#reading-error-messages"
  },"61": {
    "doc": "Error messages",
    "title": "Tips",
    "content": "Sometimes the error message will give an error for a specific line, but the error is actually before or after that line. If you can’t figure out what’s wrong in the line of code that’s in the error message, look at the lines above and below it in your code. Text editors like Visual Studio Code will highlight issues that will cause errors, usually in red or yellow. That can help you spot and fix issues before you run the program. It can also be helpful to look at the syntax highlighting in your text editor - that is, the different colors text editors use to represent different parts of the code. For examples, VS Code always shows strings in Python files as orange text. If you know a line of text is supposed to be a string but it’s not all in orange, that’s a sign that there’s something wrong that needs fixing - like a missing quote mark (“) at the beginning or end of the string. ",
    "url": "/reference/error_messages.html#tips",
    "relUrl": "/reference/error_messages.html#tips"
  },"62": {
    "doc": "Error messages",
    "title": "Resources",
    "content": "Google (or the search engine of your choise) is one of the best resources for looking up error messages. Here are a couple of other helpful resources: . | Error types in Python | Common Python runtime errors beginners find | . ",
    "url": "/reference/error_messages.html#resources",
    "relUrl": "/reference/error_messages.html#resources"
  },"63": {
    "doc": "Error messages",
    "title": "Error messages",
    "content": "It’s helpful to know how to read and understand the different parts of error messages because those messages are meant to help you figure out a) where the error is and b) how to correct it. ",
    "url": "/reference/error_messages.html",
    "relUrl": "/reference/error_messages.html"
  },"64": {
    "doc": "Readings",
    "title": "Readings",
    "content": ". | Python File Operation | Think Python, Chapter 14: Files (Up through 14.4. Stop at 14.5 Catching Exceptions) | . Also, please re-read (skim) the following readings about dictionaries: . | Using dictionaries to store data as key-value pairs | Automate the Boring Stuff: Chapter 5 - Dictionaries and Structuring Data – skim | Think Python, Chapter 11 - Dictionaries – skim up to “11.6 Memos” | . ",
    "url": "/readings/files.html#readings",
    "relUrl": "/readings/files.html#readings"
  },"65": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For this week’s summary, think about what you already know about other ways of storing data in Python, like variables, lists, and dictionaries. How are files different? . Summary prompt: What kinds of data do you think might be useful to store in a file? Why would you want to use a file rather than storing data in a variable inside of a program? . ",
    "url": "/readings/files.html#summary",
    "relUrl": "/readings/files.html#summary"
  },"66": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Tuesday. ",
    "url": "/readings/files.html#question",
    "relUrl": "/readings/files.html#question"
  },"67": {
    "doc": "Readings",
    "title": "Readings",
    "content": "This week we’re dealing with files. Files are one way to make data persistent - to store data separately from the program, which the program can then access. Files can also be a useful way to separate content (data) from the workings of the program (code). ",
    "url": "/readings/files.html",
    "relUrl": "/readings/files.html"
  },"68": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For this week’s summary, think back over the class. What have you learned? Do you feel somewhat more confident with programming and with computers than you did before? Do you feel like you could talk with other programmers about the work they do? What skills do you think you understand pretty well? What skills do you feel like you still need to learn? . You’ve learned a lot over the course of the semester. One thing that might help you to see how far you’ve come is to look at the code you wrote for the labs and studios early in the semester. You probably understand some of that code better now than you did then. Try to remember what things you found hard to do in January or February. Are those things easier now? . Prompt: Summarize what you feel like you’ve learned in this course. ",
    "url": "/readings/final.html#summary",
    "relUrl": "/readings/final.html#summary"
  },"69": {
    "doc": "Readings",
    "title": "Question",
    "content": "For the question part of the course, think about how you might use these skills in the future. How do you think you might use the skills you learned in your future courses? Or in your future career? Or in your future life? Are you already using the skills from this course in interesting and valuable ways? . ",
    "url": "/readings/final.html#question",
    "relUrl": "/readings/final.html#question"
  },"70": {
    "doc": "Readings",
    "title": "Going Forward",
    "content": "If this course was interesting to you, there are more programming courses you can take in the Media and Information department and elsewhere. You can also learn a lot by practicing programming on your own. This article about teaching yourself to code has a lot of good suggestions and resources if you want to continue practicing your programming skills. ",
    "url": "/readings/final.html#going-forward",
    "relUrl": "/readings/final.html#going-forward"
  },"71": {
    "doc": "Readings",
    "title": "Readings",
    "content": "There are no readings for this week. However, I would like you to think about and submit a summary+question. This is a chance for you to reflect on this course, and on where you see yourself going in the future. ",
    "url": "/readings/final.html",
    "relUrl": "/readings/final.html"
  },"72": {
    "doc": "Lab",
    "title": "Grading and Rubric",
    "content": "In addition to the normal check, check plus, check minus grades for participating in class this week, this project will receive a grade as the final project for the class. This grade is based on how well the program works and how interesting / creative the program is. This class has not only taught you how to program, but also emphasized how programming is a useful tool for expressing creativity. The grade for your final project is 20% of your overall grade for the class. Each student in the group will receive the same grade for the project. Here is a rubric will we use to determine your grade for the project: . Basic necessities (aka the “Minimum Viable Product”) (70% of grade; 10% each) . | Program runs (with minimal effort) | Content exists; the program tells a story | Program is interactive and gives the user multiple paths to follow (those choices matter for the story) | Logic of program separated from content somehow | Option to quit the program exists | Code is stored in Gitlab | Screenshots of final, working program in D2L (or in Gitlab) | . The remaining 30% of the grade is for going beyond the minimum and making an interesting choose-your-own-adventure program. This can be done through creativity, through programming, or through a combination of both: . Creativity . | Tells an interesting story | Story has an interesting setting / millieu | Turtle interface that looks interesting | Turtle interface that adds to the story | Other, unanticipated creative strengths | . Programming . | The program is well commented and easy to read | The code and content is well organized | Uses interesting programming / logic to tell the story | Uses complex-but-not-unnecessarily-complex code/logic (e.g. dictionaries / files) | Other, unanticipated programming strengths | . Each of these can be awarded 0-15 percentage points based on how good / interesting it is. Maximum grade is 100%. Generally, if one of these things is there, it is worth 5%. If it is good, then 10%, and if it is really great, then 15%. Plan to incorprate at least 2 things which go beyond the minimum, and play to your group’s strengths. You will turn your project in the same way as you have been all semester - put the code in Gitlab, and turn in screenshots on D2L. Make sure to add both Jack and Caitlin as maintainers on your GitLab repo, or else we won’t be able to grade your project! . ",
    "url": "/labs/final.html#grading-and-rubric",
    "relUrl": "/labs/final.html#grading-and-rubric"
  },"73": {
    "doc": "Lab",
    "title": "Advice",
    "content": "There are many ways to approach this project and you have a lot of tools as your disposal to make something really interesting. Remember you can use any of the code you’ve written all semester; it might be useful to go back to some of the old labs and studios and see if there’s anything you might want to use in your program. In my experience, every group’s program for this project is very different. There’s no right or wrong way to do things. Write the program in whatever way makes the most sense to you. The advice below is based on my experience, but you can do things differently if you want. Refer to previous labs and studios . Forget how to do something? Remember you can look at the code from previous labs and studios to remind yourself. And you can use any code you’ve written in the past, too. Logic vs content . One of the items on the rubric is that your program should separate the logic from the content somehow. The logic is what the program is doing - how it works, in what order things happen, etc. The content is what you’re showing the user - the text of the story, Turtle illustrations, etc. We’ve used two techniques in class that separate content from logic: files and modules. Files allow you to store information - like story text - in a different place than the code for the program. Using text files to store your content and then pulling it into the program is one way you’ll want to separate the content from the logic. One way to set this up is to have a file for each “path” the user can take in the story. For example, “intro.txt” could contain text that introduces the users to the story, and then gives them two options: stay inside or go outside. If they choose to stay inside, the program will pull the text that describes what happens from “inside.txt”. What happens if they choose to go outside will be in “outside.txt”. Modules are similar to files in that they allow you to store things separately from the logic of the program. We’ve mostly used them to store functions. And we’ve made a lot of functions that draw things out in Turtle. For this project, you might want to illustrate things that happen in Turtle or as ASCII art - those illustrations are also content. You can create a function for each illustration you want to use, store those functions in their own module, and then call them in the main body of the program. Providing an option to quit . The rubric also asked you to provide the user with the option to quit the program while it’s running. You should allow your user to enter “quit” (or some other, equivalent input) and when the program notices that, it should just stop. You can use the function sys.exit() to just stop the whole program. So when the user enters “quit”, call sys.exit(). You will need to import sys at the top of your program so you can use the exit() function. Loop to load the next file . You could write the program similarly to how you did in the first studio, with a bunch of if / else statements. But if you wanted to allow the user to quit the program at any point while it’s running, you’ll likely want to use a loop. One way you might want to use a loop is to have a basic while loop (while True:) with all of the main logic for the program inside it. You can use an if statement to catch if the user wants to quit. You can also use loops to serve up the next piece of content depending on what choice the user makes at each juncture. A basic structure for this kind of loop would be to serve up content, then ask the user what their choice is, then loop again to serve up more content. You’d all have to have some code somewhere that would tell the program which content to serve up and when. Check for valid input . You can also use loops to make sure the user is entering what the program is expecting by catching errors and giving feedback to the user. For example, say your program is expecting the user to enter A or B, and they enter Q - your program can’t do anything but that. But you can use an else: statement to catch bad input, give them a message (like “that’s not one of the choices”) and then loop to give them the same prompt again. Use Turtle to illustrate the story . You can use Turtle in lots of ways for this program. You could have the entire story - all of the text, any illustrations, all of the user input - take place in Turtle. You could also display the text and ask for user input in terimal, but show Turtle illustrations at different points in the story. It’s up to you how much or how little Turtle code you want to write for this project. But creating illustrations in Turtle can go a long way towards making your story more interesting and immersive. Coordinate your work as a group . Everyone in the group should be working on something, but you don’t all have to be working on the same thing. Maybe one person is workong on Turtle illustrations, while another is writing the story and another is working on the engine (the logic of the program.) Or maybe you all write the story together in Google docs, and then split up the coding tasks after the story is written. It’s up to you how you want to do this, but try to split it out so that each person is contributing something at all times, and check in with your groupmates frequently. Comment your code . Remember you’ll be coming back to this project on Thursday. Add comments to your code to explain what it’s doing and how - this will help you pick up the project much faster when you continue working on it later. ",
    "url": "/labs/final.html#advice",
    "relUrl": "/labs/final.html#advice"
  },"74": {
    "doc": "Lab",
    "title": "Ideas for being creative",
    "content": "These are all ideas that can help you make your story creative and interactive. You don’t have to use any of them if you don’t want to: they’re here to help you think about what you might be able to do. Choose an interesting setting: Maybe your story takes place in a haunted house, or on Mars. Deciding on a setting first can help provide focus when you go to write and illustrate your story. Diagram the story: Make a decision tree diagram to plot out the different paths the user can take before you write and illustrate it. This can help you to figure out how to code the logic, and where you might want to include illustrations. Here is a very simple example of a diagram. Collect information from the user: You can make your program more interactive by asking the user for information about themselves and using it somewhere in the program. For example, you could ask them their name, store it in a variable, and then use it throughout the program. What other things could you do? . Use randomness: A lot of role playing games (video or otherwise) use a choose your own adventure type logic - what happens next in the game is determined by what you choose to do. A lot of RPGs also include some element of randomness: if you choose to attack, you roll a 20-sided die and anything you roll that’s above a 5 will be a hit. And then another random number might be used to determine how much damage your hit did. Draw an info panel: Sometimes it can be nice for the user to see what paths they’ve chosen, or what their status is in the came. You could draw an info panel in Turtle that keeps track of the user’s previous choices and displays them. Or maybe the info panel shows what items are in the user’s inventory, or the amount of health they have. ",
    "url": "/labs/final.html#ideas-for-being-creative",
    "relUrl": "/labs/final.html#ideas-for-being-creative"
  },"75": {
    "doc": "Lab",
    "title": "Lab",
    "content": "For all of this week, we will be going back to the beginning of this class. The very first studio assignment was to make a “Choose Your Own Adventure” story – a program that tells an interactive story where the user gets to make meaningful choices that affect the progression of the story. This week, we are going to do that again – but this time, you will be using all the skills you’ve learned throughout the semester to make the program more fun and interesting. Important: This entire week is a studio. You’ll be working in groups of 2-4 people as usual, but you will be continuing this same project on Wednesday with the same group. You’ll have class today and on Thursday to work on the project, and can finish it in that time if you wish. You can also choose to work on it during finals week. Your group’s project will be due at the end of the final period for this class: 12pm on Thursday, December 14. ",
    "url": "/labs/final.html",
    "relUrl": "/labs/final.html"
  },"76": {
    "doc": "Final Week",
    "title": "Final Week",
    "content": " ",
    "url": "/week/final.html",
    "relUrl": "/week/final.html"
  },"77": {
    "doc": "Studio",
    "title": "Grading and rubric",
    "content": "This was also in the instructions for Tuesday, but here it is again. In addition to the normal check, check plus, check minus grades for participating in class this week, this project will receive a grade as the final project for the class. This grade is based on how well the program works and how interesting / creative the program is. This class has not only taught you how to program, but also emphasized how programming is a useful tool for expressing creativity. The grade for your final project is 20% of your overall grade for the class. Each student in the group will receive the same grade for the project. Here is a rubric will we use to determine your grade for the project: . Basic necessities (aka the “Minimum Viable Product”) (70% of grade; 10% each) . | Program runs (with minimal effort) | Content exists; the program tells a story | Program is interactive and gives the user multiple paths to follow (those choices matter for the story) | Logic of program separated from content somehow | Option to quit the program exists | Code is stored in Gitlab | Screenshots of final, working program in D2L (or in Gitlab) | . The remaining 30% of the grade is for going beyond the minimum and making an interesting choose-your-own-adventure program. This can be done through creativity, through programming, or through a combination of both: . Creativity . | Tells an interesting story | Story has an interesting setting / millieu | Turtle interface that looks interesting | Turtle interface that adds to the story | Other, unanticipated creative strengths | . Programming . | The program is well commented and easy to read | The code and content is well organized | Uses interesting programming / logic to tell the story | Uses complex-but-not-unnecessarily-complex code/logic (e.g. dictionaries / files) | Other, unanticipated programming strengths | . Each of these can be awarded 0-15 percentage points based on how good / interesting it is. Maximum grade is 100%. Generally, if one of these things is there, it is worth 5%. If it is good, then 10%, and if it is really great, then 15%. Plan to incorprate at least 2 things which go beyond the minimum, and play to your group’s strengths. You will turn your project in the same way as you have been all semester - put the code in Gitlab, and turn in screenshots on D2L. Make sure to add both Jack and Caitlin as maintainers on your GitLab repo, or else we won’t be able to grade your project! . ",
    "url": "/studios/final.html#grading-and-rubric",
    "relUrl": "/studios/final.html#grading-and-rubric"
  },"78": {
    "doc": "Studio",
    "title": "Collaboration outside of class",
    "content": "You do not have to work outside of class. In past years, many groups have finished their final project during the normal class periods. However, if you would like to continue to work on this project outside of class, you are welcome to do so; you will still have a full week left to work on it after today. I encourage you to continue to use git and GitLab for your collaboration; you’ve been using it all semester, and it is specifically designed for collaboration on programming projects like this. It might be useful to create a WhatsApp group or a group text or exchange email addresses so you can keep in touch with your group. You don’t have to work synchronously with your team, but it is often nice to so do. If it’s too hard to meet in person, you can create your own Zoom meetings for your team by going to https://msu.zoom.us, logging in, and scheduling a new meeting. ",
    "url": "/studios/final.html#collaboration-outside-of-class",
    "relUrl": "/studios/final.html#collaboration-outside-of-class"
  },"79": {
    "doc": "Studio",
    "title": "Studio",
    "content": "We will be continuing to work on our Choose Your Own Adventure engine and story. Please keep working on it today with the same group you had on Tuesday. As you work, think about the code you wrote on Tuesday. Does it still make sense? Is there anything you wish you had done differently so it would be easier to work with today? . Also, think about scope: how much can you get done? You worked for about 2 hours on Tuesday, and you’ve got another 2 hours or so to work today. How much did you get done on Tuesday? What do you still have left to do? Do you think you’ll reasonably be able to complete that work by the end of class today? If you don’t have much left, you might want to expand your scope and add some addtional features or story elements. If you have too much left, you’ll need to prioritize and maybe cut some of the features or story elements you were planning. Remember if you don’t complete the project in class, you will still have time to complete it next week. The project is due at the end of the finals period for this class: 12pm on Thursday, December 14th. ",
    "url": "/studios/final.html",
    "relUrl": "/studios/final.html"
  },"80": {
    "doc": "Readings",
    "title": "Readings",
    "content": ". | Syllabus | What is Computer Programming? | Why Should We Teach Programming? | . ",
    "url": "/readings/first_week.html",
    "relUrl": "/readings/first_week.html"
  },"81": {
    "doc": "Readings",
    "title": "Summary",
    "content": "When writing your summary of this week’s reading, think about what you now know about programming based on the readings and based on your own experiences. There’s probably a lot you don’t fully understand right now, and that’s okay! That’s why you’re in this class. The summaries you write every week are a chance for you to reflect on what you’re learning in the class, and on how what you’re learning might relate to your life. Summary prompt: Why might programming be useful for you to learn? . ",
    "url": "/readings/first_week.html#summary",
    "relUrl": "/readings/first_week.html#summary"
  },"82": {
    "doc": "Readings",
    "title": "Question",
    "content": "Normally, there won’t be a question prompt. But since this is the first week we want to know what specific questions you have about the course. Question prompt: After reading the syllabus, what is a question or concern you have about this class? . ",
    "url": "/readings/first_week.html#question",
    "relUrl": "/readings/first_week.html#question"
  },"83": {
    "doc": "Readings",
    "title": "Turn in",
    "content": "Turn in your summary + question by going to D2L -&gt; Quizzes. This is Week 1. Please turn it in before class starts on Wednesday, January 10. Caitlin will read them all before class starts and answer the most pressing questions at the beginning of class. ",
    "url": "/readings/first_week.html#turn-in",
    "relUrl": "/readings/first_week.html#turn-in"
  },"84": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is just advice for doing it. You don’t have to follow my advice, but some of it might help. Define Your Country . Talk with your group - if you were to create a new country, what would its values be? Who would live there? What kind of climate might it have? Coming up with a backstory for your country will help you design a good flag to represent it. Flag Symbolism . Flags are not easy to design. Flags have a lot of symbolism in them. Figure out what you want your flag to symbolize, and try to make sure that the flag conveys the symbols you want it to convey. It may help to talk with your group to decide what all is important to you and think about how you might represent those things using symbols. Flag Design . Try to design your flag based on good flag design principles. Here is a pamphlet from the North American Vexillography Association that describes their 5 principles for good flag design, with examples: https://nava.org/digital-library/design/GFBF_English.pdf . Also think about what’s easy and hard about using Turtle to draw things, based on your experience with the lab on Tuesday. It’s harder to draw a flower with Turtle than to draw a circle or a square. It might help to draw out ideas on paper or using the whiteboard first. Start Simple . Start simple. First, design a really simple flag (a 2 or three color striped flag like the Flag of Italy?) and write a program to draw that. Then think about how you can make the flag more complicated or more interesting. Change the colors. Change the orientation. Change the size of the flag. If you have specific symbols you want to incorporate, think about how to make them as simple as possible while still conveying meaning. You can also think about how you might make a more complex shape using simple shapes (like squares and circles) that are drawn on top of each other. Test frequently . Test your code often. Write a couple lines and test. Fix any errors that come up. Write another couple of lines and test again. The more code you write at once without testing it, the more likely you’ll have trouble figuring out what isn’t working and why! . Think like a Pen . Turtle graphics are designed to be like drawing with a pen. Draw a line here, lift the pen, move it over here, put it back down, and draw another line. If you get stuck thinking about your program, figure out how you would draw the same thing with a pen. Break down the pen drawing into steps; those steps are the steps for the turtle. Again, using paper and pencil or using the whiteboard might help with this. Turtle Graphics . | Official Turtle Documentation | . If there is something you would do with a pen, you can probably do it with a turtle. There are a lot more turtle commands than what we used in the readings or in the lab. Look at the official Turtle documentation to find more commands to help you think about how to draw things. There are also loads of colors you can use in Turtle. See exercise 11 in the Turtle lab for a couple of ways to find colors. Push yourself to try new things and new features with the Turtle graphics. It doesn’t hurt to try. If you aren’t sure, try and see what happens. For example, in one single program you can have two different turtles drawing different things at the same time! . Use What You Know . You know a lot about programming already – if statements and for loops and using variables to store information and getting input from users. Use all of that knowledge to help you in you drawing. Remember you can always refer to old labs for reminders on how to do things. The lab on Monday had you drawing stars using Turtle. If you want to use star(s) on your flag, you can use the code you wrote for Monday. But note if you try to fill the star with color, the middle of it will still be empty. I’ve written a different version of the code to make a star that does fill in the center with color, which you can use if you want. Stay Organized, and Use Comments . One of the hardest parts of programmming computers to draw on the screen is the sheer number of commands and instructions it takes. You will find that your programs are getting long quickly because it takes a lot of instructions to draw anything. Think about how to stay organized. You can always add blank lines; use that to group sets of commmands. So if you’ve got one set of commands that draws a blue square, and another that draws a white star, leave a blank line in between them. Also, use comments (lines that start with # that don’t get read by Python) to tell yourself what those chunks of code do, logically. Its hard to understand what fd(10); right(120); fd(10); right(120); fd(10) does. It is much easier if you label this with # Draw a triangle: . # Draw a Triangle fd(10) right(120) fd(10) right(120) fd(10) . Adding comments to your code is a really good way to remind yourself (and your group mates!) what the code is doing as your program gets longer. Use Programming’s Strengths . Your flag is a computer program. That means that it can do things that other flags cannot. Think about how you can use programming to make your flag more interesting than just a flat drawing. For example, could you animate something on the flag, or have a special way of drawing the flag? Or maybe you can ask the user for some input, and then customize the flag around that input. Maybe you can use the random library to make the flag have different dimensions every time the program is run. Programming can be an artistic tool. And unlike other artistic tools, like paintbrushes or clay, programming can be very dynamic and interactive - it can produce things that are different each time the program runs. How can you harness this strength of programming to make your flag unique? . ",
    "url": "/studios/flag.html#advice",
    "relUrl": "/studios/flag.html#advice"
  },"85": {
    "doc": "Studio",
    "title": "Studio",
    "content": "Today we are going to practice Vexillography – the art of designing flags! . Imagine that you and your teammates are going to go and start your own country. This isn’t so crazy at it sounds; not too long ago, a family colonized an old weapons platform outside England and created the Principality of Sealand. Others have claimed islands in the Pacific Ocean or tried to create floating countries. What all countries need is a flag. Your job today is to design a flag for your group’s new country, and then write a Python program that draws that flag on the screen using the turtle package. Remember to add from turtle import * at the top of your program and done() at the end! . ",
    "url": "/studios/flag.html",
    "relUrl": "/studios/flag.html"
  },"86": {
    "doc": "Studio",
    "title": "Today’s studio",
    "content": "Your goal today is to write a flash card program to help someone study a specific topic. The topic is up to you. Your program should do these things: . | Display a prompt (the question), and ask the user to input their response (the answer). | Tell the user if the response is correct or not. | Keep asking a question until the user gets it right. | Once a question is answered correctly, move on to the next flashcard. | Optional: keep track of how many tries each flashcard took to answer correctly and print that out at the end. | . It is OK if it always prints out the flash cards in the same order every time. We will learn how to make things in different orders later in the semester. ",
    "url": "/studios/flashcards.html#todays-studio",
    "relUrl": "/studios/flashcards.html#todays-studio"
  },"87": {
    "doc": "Studio",
    "title": "Git",
    "content": "Store your project in a Git repository on the MSU GitLab. You’ll need to make a new repository for you and your group - it’s easiest to do this first, before you start writing any code. Only one person in the group needs to create a repository; once it’s shared, everyone else in the group will have access to it. Remember to add Caitlin (geierac) and Jack (waierjac) as members along with your groupmates. See the Using Git in the Reference section for a refresher. ",
    "url": "/studios/flashcards.html#git",
    "relUrl": "/studios/flashcards.html#git"
  },"88": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is my advice for doing this. You don’t have to follow this advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. That’s ok! . Make it useful . Try to make this program actually useful. The easiest way is if you make the flashcard app for something you are already trying to learn. For example, maybe you have some vocabulary or dates you need to know for one of your other classes. Or it can be something related to a hobby or interest you have, like remembering which player is on which baseball team (Question: What team is Julio Rodriguez on? Answer: Seattle Mariners), or who trivia about favorite novels (Question: Who wrote American Gods? Answer: Neil Gaiman). If you can’t think of anything you might want to test yourself on, you can create a flashcard program for someone else; for example, create a program to help a middle school student remember biology facts, or a high school student remember world history, or an elementary school student study multiplication. Or make a program that could be used for playing trivia night at a bar or cafe. Do your research . Just because you are making the program doesn’t mean that you have to already know everything! Then why would you need the app? Instead, plan on doing some research to figure out what things you need to learn. Spend some time with Google trying to make a list of the things you would need to learn, and then spend some time on paper trying to turn those into flash cards. Also, remember that flash cards work best for facts – things with a right or wrong answer that you need to memorize. They don’t really help much with other types of learning, like learning how to write, or how to pronouce words in foreign languages, or how to develop your own style. Input, if, print . There are many different ways to make flash cards. But at their simplest, they are an input statement to ask the user for the response, and an if/else statement to check if it was correct. Get the basic pieces working before making it more complex. question.py from the lab this week might be useful to look at. Loop until correct . For each flash card, what happens when the user enters the wrong answer? Make your program tell the user that it was wrong, and then ask them again for the answer. Put this in a loop so that they keep getting asked until they get it right. Some of the exercises you did for this week’s lab might be helpful. Start simple and test often . Don’t try to do everything at once. Start with something really simple, test it until it works, and then build from there. For example, the first thing you should do is probably just have it print one prompt, and then end. Get that working first. Then write your first input, that asks the user for the response and checks if it is correct. Just print out whether it is correct. Once that works correctly when you run it, then you can add a second flash card. But don’t move on add anything new until everything you’ve already written works correctly. One thing to keep in mind is testing. You want to test the program, over and over, to make sure it does the right thing. Run it multiple times. Put in the right answer. Put in a wrong answer. What happens? Have a teammate run it. Does it work right for them? You should be spending a large amount of your time actually running your program over and over to see if it is working the way you expect it to. This also means that you don’t need to have the whole set of flash cards written before you start writing your program. Get the first one or two written, then try to make it work as a computer program. Once you’ve got those written, write on or two more and make them work as a computer program. Alternate between writing flash cards and writing code. If you try to do it all at once, the its easy to get bogged down in unimportant details. By going back and forth between flashcard writing and coding, you make sure that each activity works well with the other activity. Also, it is best to get a basic flashcard program working, where you only get one try for each card, and then later add in the retry feature that asks them over and over until they get it correct. Follow pair programming . In the lab, you practiced pair programming, with two people using one computer. One person was the driver, controlling the keyboard and mouse, and the other person was the navigator, helping out and thinking. Do that again here. It really does help get things working easier. If your group has more than 2 people, rotate the driver frequently so everyone gets a chance to write some code; the people who aren’t driving can help by using Google, coaching, and writing flashcards. Take Turns . Take turns doing the different parts of the work. Don’t have one person be the “programmer” and the other be the “flash card writer”. Instead, take turns. Have one person in front of the computer programming for 10-20 minutes and then swap to another person. The original programmer can then take a turn with Google looking up facts. Taking turns keeps things interesting as you work, and makes it easier to collaborate and produce something more interesting than you could do yourself. Remember to use Git for this! When you trade places, the old driver should add, commit, and push their code to the GitLab repository for the studio. The new driver should use git pull to get the changes onto their computer before starting to write new code. ",
    "url": "/studios/flashcards.html#advice",
    "relUrl": "/studios/flashcards.html#advice"
  },"89": {
    "doc": "Studio",
    "title": "Studio",
    "content": "Research on how people learn has suggested that when learning facts, one of the most important things to do is to periodically “retrieve” the information from your memory. That is, if you occasionally remember those facts and use them in some way, then you are more likely to remember them long-term. One of the keys is to remember the fact, not just recognize it. That is, it has to come from your brain, and not from something else like notes or a book or a web page. Doing this remembering periodically and over time helps you remember facts long-term. A common way to memorize a bunch of facts at once is to use Flash Cards. Flash cards used to be physical note cards with a prompt on one side (“What is 2 + 3?”) and an answer on the other (“5”). You use them by reading the prompt and trying to remember the answer. Once you remember the answer, then you can flip the card over and check if your answer was right. Flash cards are also nice because you can measure progress: you can count the number you get right, and tell whether you are remembering more or less than in the past. Now, instead of physical note cards, most people use flashcard apps on their computer, phone, or tablet to accomplish the same goal. ",
    "url": "/studios/flashcards.html",
    "relUrl": "/studios/flashcards.html"
  },"90": {
    "doc": "Readings",
    "title": "Readings",
    "content": ". | Think Python: Functions | Automate the Boring Stuff: Functions – stop reading at “Local and Global Scope” | . ",
    "url": "/readings/functions.html#readings",
    "relUrl": "/readings/functions.html#readings"
  },"91": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For the summary this week, think about what you’ve learned about functions, and whether anything else you’ve encountered outside of the class is similar . Summary prompt: How would you describe what a function does, and what it’s for? How is a function different from a variable? . ",
    "url": "/readings/functions.html#summary",
    "relUrl": "/readings/functions.html#summary"
  },"92": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Tuesday. ",
    "url": "/readings/functions.html#question",
    "relUrl": "/readings/functions.html#question"
  },"93": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Functions are a nice way to organize your code and make it reusable. We’ve already been using functions a lot in this class: print() is a function that’s built into Python, and forward() and right() are functions that are built into the Turtle library. This week you’ll start writing your own functions. ",
    "url": "/readings/functions.html",
    "relUrl": "/readings/functions.html"
  },"94": {
    "doc": "Lab",
    "title": "Part 1 - Setting Up Git",
    "content": " ",
    "url": "/labs/git_and_gitlab.html#part-1---setting-up-git",
    "relUrl": "/labs/git_and_gitlab.html#part-1---setting-up-git"
  },"95": {
    "doc": "Lab",
    "title": "Make a copy of the repository for your pair (only do this once!)",
    "content": "At the top of this page, there is a link to this week’s GitLab project. Click on that link and open it in a new window. What opens is a web interface to a repository for the base version of this lab. You will have to log into GitLab with your NetID and password in order to be able to see the project and repository. GitLab is a system hosted by MSU that hosts repositories and allows you to create new ones. Each project in GitLab is a Git repository. GitLab allows you to share them with other people as much as you want, for free. Fork the project . The first thing you will do is to fork the project. Forking a project means making a new project that is a copy of an existing project. IMPORTANT: only one person in your pair should do this step each week. Usually this will be whoever’s driving first. You only need one copy of the project between the two of you. To do this, look for the “fork” button on the top right of the project page and click it. It will ask you for a ‘namespace’: there should be only one option, with your name. Click on that to start the forking process. Forking will take a moment. Once it finishes, then it will take you to the new project. The new project should look almost the same as the original – it is a copy, after all! The main difference is if you look at the top, instead of saying “MI-250 / Git and Gitlab”, it should say your username now. If it does, then great! It worked! If not, then ask the instructor or TA for some assistance. (Note: sometimes you may get a 404 Error page. That happens when forking is slow. Just wait a minute and hit “refresh” and it usually fixes itself.) . Give other people access to the new project . The first thing you should do after forking a project is to give your partner, Caitlin, and Jack access to the project. In the menu on the left, find “Manage” and then go to “Members”. This is the page where you can give other people access. Click on the blue “Invite Members” button on the top right. A window will pop up. Search for your partner in the “username or email address” box – the easiest way is to search for their MSU NetID. Also search for and add Caitlin (geierac) and Jack (waierjac). Then change the “role permission” to “Maintainer” – the highest level of permissions. You don’t need to add an expiration date. When you’re done, click the “Invite” button at the bottom of the window. The three people you added (your partner, Caitlin, and Jack) should show up in the member list. Make sure your partner can access your forked project . Next, the navigator (who was just added to the project) should try to log into Gitlab https://gitlab.msu.edu and click on “Projects” -&gt; “Your Projects”. They should see the “Git and Gitlab” project on the list, and be able to click on it and view the files inside of it. Congrats! You’ve now got your first GitLab project! Good work! . ",
    "url": "/labs/git_and_gitlab.html#make-a-copy-of-the-repository-for-your-pair-only-do-this-once",
    "relUrl": "/labs/git_and_gitlab.html#make-a-copy-of-the-repository-for-your-pair-only-do-this-once"
  },"96": {
    "doc": "Lab",
    "title": "Set up your computer to use the new git repository",
    "content": "NOTE: remember to practice pair programming for this section! Get everything working on one person’s computer first before you start trying things on the second person’s computer. This will make things easier in the long run, I promise! . You’ve now got your own project, but right now it only exists on GitLab. That’s great – it is on a webpage where others can see it also. But you need to be able to edit and run the programs on your own computer. To work with the files in the repository on your own computer, you could download the files like we did last week. But it’s hard to share files with your partner that way (as you may have discovered last week). Instead, we’ll be using Git. What Git allows you to do that simply downloading the files doesn’t is to make a two way street between the files on your computer and the files in the repository on GitLab. Git allows you to make changes to the versions of the files on your own computer and then to easily push those changes back up to GitLab so that other people (like your partner) can access them. Git is a tool that is built to allow programmers to easily share code with one another. Install Git . The first thing you’ll need to do is download and install Git onto your computer. You can download the Git installer from the Git Downloads Page. On Windows: . On Windows, choose the standalone installer. If you have Windows 10 or Windows 11, the 64-bit installer will work fine. The installer will ask you a lot of questions. Just click next on all of them. On Mac: . If you are on a Mac, the best way to get the most up to date version of Git is to install Homebrew first. To install Homebrew, copy and paste this command into Terminal and hit Enter: . /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" . It will prompt you for your computer’s password before the install starts. If it gives you any errors, you may have to install the Xcode command line tools first. You can do so by running this command in Terminal: . xcode-select --install . If you end up having to install Xcode as well, you may have to run the Homebrew install command above one more time before moving to the next step. Once Homebrew is installed, you can install Git by running this command: . brew install git . Alternate option for Mac: If you absolutely can’t get the above instructions to work, you can also install Git using the binary installer option on the Git for Mac downloads page. This will give you a much older version of Git (from 2021), but it will work for most things we do in this class. Make sure Git is installed properly . Once you’ve got Git installed, open up a command line window (Powershell on Windows or Terminal on Mac). If you just type the command git, it should print out a bunch of help information about the different git commands. If it does that, then you’ve got git installed correctly! If you get an error message or a bunch of red text, then you haven’t installed Git correctly yet. Go back and try again. Tell Git who you are . The first thing you need to do to set up Git is to tell it who your are. Use the following two commands to tell it who you are, substituting your name and email address for mine: . git config --global user.name \"Caitlin Geier\" git config --global user.email \"geierac@msu.edu\" . Be sure to keep the quotation marks. You should only need to do this step once on your computer. After that, it will remember who you are. Create a GitLab Access Token . To get files from Gitlab using Git, you need to use something called an “Access Token”. This is kind of like a passkey that you give to GitLab to let it know that it’s you. To create an access token, go back to the GitLab webpage and hover over the sidebar icon on the upper left to make the sidebar visible. In the green part of the sidebar, there will be a circular profile icon on the upper right. If you click on that icon, it should bring up a user menu with your name at the top – choose “Preferences” in that menu. Once you’re on the Preferences page, open up the sidebar menu on the left again and look for “Access Tokens” in the menu. On the Access Tokens page, create a new Personal Access Token. Steps: . | Click the “Add new token” button near the top left of the page. | Type in your NetID in the “Token Name” field. | Choose an expiration date that is after the class ends - like April 30, 2023. | Important: click the “write_repository” checkbox. If you don’t, your token won’t let you access the files inside your repositories. | Click the “Create personal access token” button. The webpage will reload, and near the top, it will show a “personal access token” which is basically a randomly generated password for you to use. | Save this access token!! You will need to use it shortly. I recommend copy and pasting it into your notes or into a Google doc - somewhere where you can find it later. | . You should hopefully only need to use your access token today; after completing this lab, Git should remember it and never ask you again. ",
    "url": "/labs/git_and_gitlab.html#set-up-your-computer-to-use-the-new-git-repository",
    "relUrl": "/labs/git_and_gitlab.html#set-up-your-computer-to-use-the-new-git-repository"
  },"97": {
    "doc": "Lab",
    "title": "Clone the repository",
    "content": "Cloning a repository is always done in three steps: . | Fork the repository (one person in each pair will do this for every lab) or create a new repository (for studios). | In command line, use cd to navigate to the place on your computer where you want the repository to live. | Use the git clone command to clone your repository onto your computer. | . Step 1: Forking the repository . You already did this step above! Make sure you’re on the page for your forked repository on Gitlab. One way to tell if you’re in the right place is to make sure your name shows up in the breadcrumb links above the name of the repository. If it says MI 250 instead, you’re not in the right place. Step 2: Navigate to the right place in command line . On your computer, you should make a place to keep your work for this class – a folder to store all of the labs and studios that you work on. I created a folder on my desktop called “MI250” and keep everything in there. But it’s your computer, and you can put it wherever you want (so long as you remember where it is!). To get a repository on your computer, you need to “clone” the repository – which means using Git to make a copy of the repository that will live on your computer and will talk to the copy that’s on Gitlab. Open up your command line program (Terminal on Mac or PowerShell on Windows). Then change directories to the directory where you want to keep your files using the cd command. Check out the command line reference if you need help remembering how to do this. Step 3: Git clone . If you look at the project page for your forked repository, on the right hand side there is a blue button labled “Code”. If you click on that, you get several options. In this class, we will always use “Clone with HTTPS”. Click the “Copy URL” button that looks like a clipboard icon next to the HTTPS option: it will copy a link to the repository onto your clipboard. Next, we will use a Git command in command line to clone the project. By default, this command will clone the project into whatever directory you are currently in on the command line. That’s why it was important that we cd into our folder for this class before running this command (see Step 2 above!). The command to use Git to clone a project onto your computer is git clone to clone the project. In command line, type in git clone and then paste in the HTTPS link that you copied from the Gitlab website. It should look something like this: . git clone https://gitlab.msu.edu/geierac/git-and-gitlab.git . Important: Make sure your username is in the URL that you paste in! If it’s not (if it says mi250 instead), that means you’re in the wrong repository. When you run the git clone command, it will ask you for your username and password. Don’t enter your real password! Instead, log in with your NetID (don’t include @msu.edu) and then use your newly created “personal access token” as the password. If this works, then it should print out information telling you it is “receiving objects”, which means it is downloading the files for the repository for you. Once the repository has downloaded, you will get a prompt on the command line again. If you use the command ls, you should see a new directory called “git-and-gitlab”. Change directories into that using the command cd git-and-gitlab. If you do an ls again, you’ll see that all of the files from the repository have now been downloaded onto your computer and are there for you to work with. If you look at the folder in Exporer/Finder, then you should also see the files. IMPORTANT: The new folder that appeared on your computer represents the repository. Anything inside that folder will talk to the repository on Gitlab. If you change the name of the folder or move files outside of it before you work on them, the link between the folder on your computer and the Gitlab repository will be broken. ",
    "url": "/labs/git_and_gitlab.html#clone-the-repository",
    "relUrl": "/labs/git_and_gitlab.html#clone-the-repository"
  },"98": {
    "doc": "Lab",
    "title": "Make a change to a file on your computer and “push” it to Gitlab",
    "content": "Next, let’s make a change. Open up the file README.md in your text editor. Right now, it has my name (Caitlin Geier) in there as the author. That’s no longer accurate, though – this is YOUR repository now! Change the name to your name. Add, Commit and Push the change . You’ve made a change to README.md on your local computer. But if you go look at the file in the repository on GitLab, it still has my name in it. That is because you haven’t committed or pushed your change; that is, the change only exists on your computer. The idea behind Git is you can make all sorts of changes on your own computer that may or may not work. Since they’re only on your computer, you won’t break the code for everyone else who uses the repository. Once you get things working, then you can save those changes to the official repository (which lives on Gitlab) so that other people can access the new, working code. There are three steps to getting your code from your computer up to the repository that’s shared with other people: add, commit, and push. We’ll go through each of these one by one. Add . Start by running the status command on the command line: . git status . This command will show you the current status of the version of your git repository that is on your computer. It will let you know if any files have been modified since the last version you got, and if any files have been added or deleted. You should see that you’ve modified the README.md file. It’s good practice to run git status regularly when using Git. It’s especially helpful for troubleshooting issues. The first step is to let Git know what changes go together. Sometimes you make changes in multiple different files and you want all of those changes to logically go together as one commit. To do this, git has what it calls a “staging area” – a place you put changes until you’ve got the whole set of them together. You use the command git add to add things to this staging area. You can run this command multiple times if you want to add changes from more than one file to the same commit. We only have one file with changes – README.md – so we only need to add one file to the staging area. Let’s do so with the git add command: . git add README.md . If your git add command works correctly, then it won’t print anything out. It will just give you a new prompt. If it doesn’t work, then you’ll get an error message. Tip: If you’ve made changes to multiple files and you want them all to be added to the staging area, you can use what’s called a modifier. The modifier -a stands for “all”. You can use it like this: git add -A . Note: On many systems, the filename is case sensitive; so if you get an error message, try to make sure the case is correct. Commit . Once you’ve got all the changes together in the staging area, the next step is to “commit” those changes. Committing the changes takes all those changes and creates a new version of your program that has those changes. That is, it formally records a new version of your program. To do this, we use the command git commit. git commit -m \"adding my name to README\" . Whenever you make a commit, you need to add a message explaining, very briefly, what changes you’ve made and why. -m is a modifier that stands for “message” and you add your message in quotes after it. The purpose of the message is so that you and the other programmers on the project can all tell what’s been changed and why. Push . Committing the changes only records the changes in the clone of the repository that is on your computer; those changes haven’t gotten to Gitlab yet. That’s what git push does – it takes any changes that are on your current computer that you’ve committed, and it pushes them up to the main repository on Gitlab. Run that command now: . git push . Now go check the version of your repository that’s on Gitlab. Don’t forget to refresh the page. When you look at the README.md file, it should have your name in it now instead of my name. That means that you have successfully commited your first change to a Git repository! Good work! . ",
    "url": "/labs/git_and_gitlab.html#make-a-change-to-a-file-on-your-computer-and-push-it-to-gitlab",
    "relUrl": "/labs/git_and_gitlab.html#make-a-change-to-a-file-on-your-computer-and-push-it-to-gitlab"
  },"99": {
    "doc": "Lab",
    "title": "Swap and Repeat",
    "content": "The biggest benefit of Git is collaboration – it makes it easier to work on the same code with other people. The next step of today’s lab is to learn how that works by swapping roles. The current driver (the person at the keyboard) will become the navigator, and the navigator will become the driver. Go through all of the same steps, starting with “Set up your computer to use the new git repository” on the new driver’s computer. When you edit the README file, add your name to the file, so that it says “By: Partner’s Name and Your Name”. Be sure to add, commit, and push the changes, and then check on the GitLab to make sure that the changes you made appear there. Once you’ve done this correctly, then there should be a single Git repository in Gitlab for you and your partner and both members of the pair should have a clone of that Git repository on their personal computer. Either person can work on the program, and then commit and push changes back to the repository at any time. This makes collaboration easier, because both people have a copy, and both people can work on it. The code you turn in today will be the code that you and your partner have both contributed to on GitLab – your Gitlab repo is what you’ll turn in. ",
    "url": "/labs/git_and_gitlab.html#swap-and-repeat",
    "relUrl": "/labs/git_and_gitlab.html#swap-and-repeat"
  },"100": {
    "doc": "Lab",
    "title": "Git Pull",
    "content": "Swap roles again, so that the original driver is now driving again using their own computer. If you look at the files on your computer, then you’ll notice that the newest change – the one that adds the navigator’s name to README.md – isn’t there. What is happening is that there are changes in the main GitLab repository, but they haven’t been copied down to your computer yet. To do that, we can use the command git pull. This command will take all of the changes that are in the main repository on GitLab and pull them down to your computer. Run that now: . git pull . Now open the README.md file in the text editor on your computer, and you should see the changes, including both people’s names. You want to run this command any time that your partner makes any changes and then commits and pushes those changes to the repository. Always remember to use git pull before you start working to make sure you have all the latest changes. ",
    "url": "/labs/git_and_gitlab.html#git-pull",
    "relUrl": "/labs/git_and_gitlab.html#git-pull"
  },"101": {
    "doc": "Lab",
    "title": "Part 2 - Programming",
    "content": "Now that you’ve got the Git repository and have figured out how to contribute to it, we can start working on modifying the programs in that repository. We are going to begin with the program bottles.py, which is a simple program that prints out lyrics to a song – a modified version of the song 99 bottles of beer. The first thing to do is to run the program on the command line: . python bottles.py . You should see it print out two verses of the song. ",
    "url": "/labs/git_and_gitlab.html#part-2---programming",
    "relUrl": "/labs/git_and_gitlab.html#part-2---programming"
  },"102": {
    "doc": "Lab",
    "title": "Exercise 1: Change the beverage",
    "content": "Right now, the song is being sung about water. The original song was about beer. What is your favorite beverage? Pick a new beverage, and change the song so that it is being sung about your favorite beverage. ",
    "url": "/labs/git_and_gitlab.html#exercise-1-change-the-beverage",
    "relUrl": "/labs/git_and_gitlab.html#exercise-1-change-the-beverage"
  },"103": {
    "doc": "Lab",
    "title": "Exercise 2: Last verse",
    "content": "The last verse gets down to zero bottles. No one likes singing about “zero” bottles. Most of the time, that last verse gets modified. For example, the Wikipedia article lists “No more bottles of beer on the wall, no more bottles of beer.” as the last verse. Create a last verse that is more interesting for the song; one that doesn’t use the word or number “zero”. ",
    "url": "/labs/git_and_gitlab.html#exercise-2-last-verse",
    "relUrl": "/labs/git_and_gitlab.html#exercise-2-last-verse"
  },"104": {
    "doc": "Lab",
    "title": "Exercise 3: Save your changes using Git",
    "content": "OK, now you’ve made some changes to your bottles program. The next thing you should do it commit that code to your git repository. Use the same sets that you used above – git add &lt;filename&gt;, git commit -m \"&lt;message&gt;\", and git push – to commit those changes and push them back to the main repository on Gitlab. ",
    "url": "/labs/git_and_gitlab.html#exercise-3-save-your-changes-using-git",
    "relUrl": "/labs/git_and_gitlab.html#exercise-3-save-your-changes-using-git"
  },"105": {
    "doc": "Lab",
    "title": "Exercise 4: Swap driver and navigator",
    "content": "Now, swap driver and navigator. On the new driver’s computer, you should then git pull. Run the program again with python bottles.py and make sure that the your computer has all of the changes that your partner made for the previous exercises. ",
    "url": "/labs/git_and_gitlab.html#exercise-4-swap-driver-and-navigator",
    "relUrl": "/labs/git_and_gitlab.html#exercise-4-swap-driver-and-navigator"
  },"106": {
    "doc": "Lab",
    "title": "Exercise 5: 5 bottles",
    "content": "The song right now starts with only 2 bottles. That’s not very many. Expand the song to start with 5 bottles of your favorite beverage, and then count down until there are none left. ",
    "url": "/labs/git_and_gitlab.html#exercise-5-5-bottles",
    "relUrl": "/labs/git_and_gitlab.html#exercise-5-5-bottles"
  },"107": {
    "doc": "Lab",
    "title": "Exercise 6: Git Commit",
    "content": "OK, now you’ve made some more changes to your bottles program. You should commit that code to your Git repository. Use the same commands that you used above – git add &lt;filename&gt;, git commit -m \"&lt;message&gt;\", and git push – to commit those changes and push them back to the main repository on Gitlab. Then, swap again, and have the other person git pull on their computer. Make sure all of the new code you both added to bottles.py are on both of your computers AND in your GitLab repository. ",
    "url": "/labs/git_and_gitlab.html#exercise-6-git-commit",
    "relUrl": "/labs/git_and_gitlab.html#exercise-6-git-commit"
  },"108": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you have gotten through all of the exercises and tried out Git on both of your computers, great work! If you still have extra time before class ends, do at least one of the challenges below. Challenge 1: Count . The GitLab repository for today has another Python program in it called count.py. Run the program. What does it do? . What happens if the user enters something other than Up or Down? Probably nothing good. Edit the program so it can account for case and for other options for user input, like ‘u’ for Up or ‘d’ for Down. Also add an error case for if the user types something other than the accepted inputs. (Hint: use else!) . Remember to add, commit, and push your changes to Git when you’re done. Challenge 2: Bottles or something else? . In bottles.py, beverage is a variable that is replaced with something else. What else can you replace in the song to make it different? What if your beverage of choice comes in cans? What if the drinks are in the refrigerator instead of on the wall? Pick a word to replace and use a variable to replace it throughout the song. ",
    "url": "/labs/git_and_gitlab.html#challenges",
    "relUrl": "/labs/git_and_gitlab.html#challenges"
  },"109": {
    "doc": "Lab",
    "title": "Turning in your work",
    "content": "Take screenshots of your code working in command line, as per usual, and upload them to D2L under Assignments. If you got all of your changes up in your GitLab repository, you’ve already turned in your code for today! This is how you’ll turn your code in every class from now own. Make sure Caitlin and Jack are both added as members to your repository (see Give other people access to the new project) . ",
    "url": "/labs/git_and_gitlab.html#turning-in-your-work",
    "relUrl": "/labs/git_and_gitlab.html#turning-in-your-work"
  },"110": {
    "doc": "Lab",
    "title": "Troubleshooting",
    "content": " ",
    "url": "/labs/git_and_gitlab.html#troubleshooting",
    "relUrl": "/labs/git_and_gitlab.html#troubleshooting"
  },"111": {
    "doc": "Lab",
    "title": "Troubleshooting git clone",
    "content": "Sometimes, you get an error message when you try to download the repository using git clone. NetID . When you run git clone the first time, it asks you for your username and password. The most common problem is that students put user@msu.edu in the box. Do NOT do that. Just put your username in the box – do NOT put the @msu.edu part. If you did that, then try running git clone again, and use the correct username. If it doesn’t ask you for your username, then Git is trying to remember your (incorrect) username. Windows remembering your password . When you first run git clone, git will ask you for your username and password. both MacOS and Windows will remember these – it won’t ask you for them again after the first time. However, sometimes you get something wrong the first time. Generally Mac handles this well – if it didn’t work, then Mac will prompt you again next time. However, Windows sometimes remembers this wrong username/password, and then Git commands don’t work. To fix this, go down to the start bar and search for “Windows Credential Manager”. On the page that comes up, look through the list for the Git/GitLab credential. I usually just delete the entry for Git/GitLab. Then try running git clone again, and it should prompt you for your username and password. ",
    "url": "/labs/git_and_gitlab.html#troubleshooting-git-clone",
    "relUrl": "/labs/git_and_gitlab.html#troubleshooting-git-clone"
  },"112": {
    "doc": "Lab",
    "title": "Troubleshooting git commit",
    "content": "This section contains extra instructions for troubleshooting problems with git commit. Specifically, do this if no file opens when you git commit and you immediately get an error message. If you type in git commit without the -m \"message\" at the end, Git will either give you an error or will try to open a text editor for you to type the message in. This isn’t a big deal on Windows. If it opens up a text editor window, close the window. Go back to command line and try again, making sure to add the message this time. On Mac, it might open up a new screen inside Terminal. Terminal has a very old text editor called Vim built into it which is hard to use. To get out of it, type: . :wq . and then hit Enter. You can also close the Terminal window and reopen it. ",
    "url": "/labs/git_and_gitlab.html#troubleshooting-git-commit",
    "relUrl": "/labs/git_and_gitlab.html#troubleshooting-git-commit"
  },"113": {
    "doc": "Lab",
    "title": "Git conflicts",
    "content": "If multiple people are making changes to a repository at the same time, sometimes there can be conflicts. This especially happens in studios, where different people might be working on different aspects of the studio at the same time. A few tips for avoiding conflicts: . | Always use git pull before you start working on a file to make sure you have the most updated version. | When you’re done working on a file, always add, commit, and push your code to Gitlab. | . Don’t worry if you run into a conflict; Caitlin and Jack are always around to help you resolve them! . ",
    "url": "/labs/git_and_gitlab.html#git-conflicts",
    "relUrl": "/labs/git_and_gitlab.html#git-conflicts"
  },"114": {
    "doc": "Lab",
    "title": "Git reference",
    "content": "I’ve put together a quick reference for Git on this site: Using Git . ",
    "url": "/labs/git_and_gitlab.html#git-reference",
    "relUrl": "/labs/git_and_gitlab.html#git-reference"
  },"115": {
    "doc": "Lab",
    "title": "Lab",
    "content": "In this week’s readings, you read about version control and Git. A Git repository is a specific, named collection of files that usually make up a single program. You’ve already used git repositories in this class - all of the files for last week’s lab were stored in a git repository, which you accessed through the Gitlab website. Today, the first thing you are going to do is to get your OWN copy of the repository for this week’s lab on your computer - not by downloading it, like last week, but by having Git make a copy of it on your computer. ",
    "url": "/labs/git_and_gitlab.html",
    "relUrl": "/labs/git_and_gitlab.html"
  },"116": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. Be creative! . Use Turtle . You spent last week learning Turtle graphics. Use Turtle to make a visual guestbook that looks nice. Be creative in how it looks, and get the guestbook to look interesting. Remember you can more than just writing out names - you can draw shapes and use different colors and fonts, too. Refer to the Turtle lab if you need a reminder on how to do certain things with Turtle. The Turtle documentation is also a very helpful resource. Use lists . We learned how to use lists this week. Think about how you can approach this using lists. You can add things (like user input) to a list, or sort the list (for example, alphabetically). You can also use a for loop to iterate through a list, item by item. For example, this structure . for item in stuff: print(item) . will go through the list called stuff and will print out each item in the list one by one. Think about how you might want to use lists. Do you want to have everyone add their names to the guestbook first and print it out at the end? Or have it draw out new names using Turtle as they’re added? How would you use a list to store and retrieve the names in each case? . Start simple, then expand . Start with something simple. For example, you could start by getting a really simple guestbook working for just one guest: ask for user input, then draw the user input using Turtle. Then modify it so the name looks nice. Then add a loop so it asks for user input over and over and prints out each name. Then store the names in a list, and print out the list. Or something like that. There are lots of different ways to do this. Think about how to build up features. Wait to do the fancier, more complex features until you have the basic features working well. Use interesting fonts . The write() function in Turtle graphics allows you to specify the font and size. So, for example, you can write: . write(\"Welcome to my Guestbook\", font=(\"Arial\", 30, \"normal\")) . Or . write(\"Please enter your full name\", font=(\"Helvetica\", 12, \"italic\")) . There is a python program here that will give you a list of all the fonts on your computer. Another trick is to open up Microsoft Word and look at the fonts Word lets you use - if there is no cloud icon next to the name of the font in Word’s font list, that means it’s already installed on your computer. Use randomness . Remember you can pull random items out of a list! If you have, for a example, a list of fonts or a list of colors, you can use random.choice() on the list to pull a random item from it. That might be an interesting way to make your guestbook look unique. What other parts of your geustbook design can you apply random features to? . Use multiple turtles . You can have more than one turtle on the screen at any time. It can sometimes be helpful to have different Turtles draw different things - that way you don’t have to figure out how to get the turtle in the right place before you start drawing something new. To create a second (or third or fourth) turtle, you have to name it first, and then call it by name every time you use it. You can call your new turtle whatever you want. bob = Turtle() # creates a new turtle called bob bob.forward(20) # moves bob forward by 20 pixels . For this studio, it might be helpful to have one turtle draw out the names and messages, and another draw the background decoration for the guestbook. But there are lots of ways you could approach it. Test your program . Test your program frequently. Every time you add a few lines of code, test it to make sure it works. It’s easier to debug programs if you know the bug is somewhere in the last 2 lines you typed out, rather than having to go through the entire program to figure out what went wrong. ",
    "url": "/studios/guestbook.html#advice",
    "relUrl": "/studios/guestbook.html#advice"
  },"117": {
    "doc": "Studio",
    "title": "Studio",
    "content": "For this week, your goal is to make a digital guestbook. Traditionally, a guestbook is a physical book left near the entrance for an event (like a wedding or funeral) or a place (like a museum). Guests can sign their name and maybe leave a message, and the guestbook acts as a record of who was there. Your goal is to create a digital guestbook. Imagine it being left running so people can enter their names and possibly leave a message. There should be a way to view all of the previous guests, as well as a way for the user to add themself as a guest. Whether people can leave a message along with their name is up to you, as is whether they can add additional information. Use Turtle as the interface for the guestbook - the names and any additional information people enter into the guestbook should be displayed using Turtle. Work in teams of 2-3. One person should start a new repository in GitLab so your team can share code. ",
    "url": "/studios/guestbook.html",
    "relUrl": "/studios/guestbook.html"
  },"118": {
    "doc": "Studio",
    "title": "Advice",
    "content": "Choose something less morbid . “Hangman” is the name of the game, and it is traditionally played by hanging a stick figure. But it doesn’t have to be! It is OK to choose a more fun, less death-like thing to draw on the screen when the user guesses incorrectly. Draw a fancy smiley face? Draw a stick figure dancing? Draw (stick figure) dogs and cats living together? Its up to you. Work as a team . There are lots of parts of hangman. There’s the user input side – guessing letters, and checking to see if they are in a word. There is the hangman drawing side, that draws the figure incrementally. And there is the game logic, that chooses a word for the game and then connects the user input with the drawing. Spread out the work across the team. Have different people do different parts. Use functions to capture the different parts of the program. Use git to share code. This project is much easier if you break it into parts, and then do the parts separately, and then put them together. Make sure to leave time to put them together; its not as easy as it sounds. Think about program structure . In the lab this week, you were reading code. Almost all of that code had a nice, clear structure – it had logical things that it did, and it had a function for each logical thing. Then, at the bottom, there was a “main” section that was only a few lines long that connected those functions together. Think about how you want to structure your program. At a high level, what are the logical things that the program needs to do? How do they fit together in the program? What information needs to be send from one logical thing to the next? As you get started, draw a diagram that describes what those pieces are, and what information need to move from one to the next. Break the program into pieces (functions) . Once you figure out the logical structure of your porgram, then use that to break the program into functions. If you try to write one big program that does this whole game, you will find it is really difficult. Each time you find yourself thinking you need the program to do something, write a function for that something. Need it to draw a dash with a letter in it? Write a function for that. Need it to draw the next line of the stick figure? Write a function for that. It is pretty much impossible to have too many functions. Clone turtles . In almost all of your programs so far, you’ve only had one turtle. But there is no reason to limit your program to just one. You can use the clone() function of turtles to create new turtles. For example: . from turtle import * t2 = clone() t2.color(\"red\") t2.left(90) t2.forward(100) forward(100) . This little program will create a clone of the turtle, which starts right where the old turtle was at the time you clone it. The clone (t2) will change color to red, turn left, and draw a line stright up. Then the original turtle, still black, will draw a line going right starting at the original position (since it hasn’t moved yet). You can create multiple turtles to do different parts of the hangman program. One turtle might draw the hangman stick figure. Another turtle might be responsible for drawing the letters of the word. Yet a third turtle might write out the incorrectly guessed letters? Its up to you how you use this, but be creative. Use code you’ve written before . You’ve done a lot of programming already in this class. Use that! If you’ve already written code to draw a smiley face for a previous lab or studio, then go find that code and modify it. If you’ve already written code to ask for user input, go look it up and use it. There is no reason to write things from scratch when you’ve already written a lot of code. Use code you’ve read before . Likewise, it is also a good thing to use code that you didn’t write, but you have read or seen elsewhere. Also, if you feel like someone has already written code to do something, they probably have. Google around and see if you can find it. The only catch with using code you didn’t write is that you should read it and try to understand it (like you did in the lab this week). If you don’t understand how the code works, then it will be difficult to use it correctly and make it work in your program. There is a function in exercise 4 from this week’s lab that might be very useful in finding where a letter appears in a word. It is called letter_places(). If you give it a string, and then a letter, it will return a list of all of the places in the string that letter appears. Try it! Copy-and-paste that function into a new python program, and then add code to call it and see what happens. if you say letter_places(\"hangman\", \"a\"), what does it print out? If you instead ask for letter_places(\"hangman\", \"q\"), what happens? . Store the answer . The hardest part of today’s studio is having your program keep track of the word as the user makes guesses. The easiest way to do this is using a list. What I recommend is creating a list of letters, and as the user guesses letters, then you can fill in the correct letters in the right spaces. That is, we will start with a list of blanks (spaces), and each time the user guesses a letter correctly, we will replace the space with the correct letter. To do this, we should start out by creating a variable (which I call in_progress) and initializing a list with spaces: . solution = \"hangman\" num_letters = len(solution) in_progress = list( '_'*num_letters ) print(in_progress) . Now, each time the user makes a guess, we can use the letter places function to figure out which spaces to replace with the guessed letter: . places = letter_places(solution, guess) if len(places) &gt; 0: # the guessed letter is at least one place in the solution for place in places: in_progress[place] = guess print(in_progress) . In the lab this week, you practiced reading and understanding code. This is code that you can use. It works, but you’ll need to end up modifying it to work in your program and to work with turtle. I strongly recommend you read it first like you did in lab, carefully figuring out what each line does and how it works. Then you will be better able to integrate it into your program. ",
    "url": "/studios/hangman.html#advice",
    "relUrl": "/studios/hangman.html#advice"
  },"119": {
    "doc": "Studio",
    "title": "Studio",
    "content": "For the studio today, you are going to make a hangman game. The game works like this: . The game chooses a secret word, and displays a number of blanks indicating how many letters that word has. The player then has to guess letters. If the player guesses a letter correctly, the game fills in the letter in all places in that word that it appears. If the player guesses a letter that is not in the word, then the game draws the next line in a stick figure (drawn with turtle). The player wins if she or he guesses all of the letters before the stick figure is completed. The player loses if the guess incorrectly so many times that the stick figure is fully drawn. That’s it. That’s the whole of the instructions – form a group, write a hangman program. Have fun with it. What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. ",
    "url": "/studios/hangman.html",
    "relUrl": "/studios/hangman.html"
  },"120": {
    "doc": "Honors Option",
    "title": "Honors Option: Contract Programming",
    "content": "Most programming work is broken up into different parts, which are usually done by different people. The first part is the specification: deciding what the program needs to do. Specifications are hard because they need to provide enough detail about what the program will need to do that someone else can program. The second part is the implementation, which is writing the main code that (hopefully) accomplishes what the specification says it should The third part is the testing, which checks the main code to see what it does and does not do, to make sure that it accomplishes what it is supposed to do. We are going to do that – specification, implementation, and testing – around a small app. | First, you are going to need to write a specification. Look through the studios for this class, and choose one of them that you find interesting. (You do not need to choose the same studio as your partner.) You will write a specificaiton for a program that fulfills that studio. The specification will need to provide a lot more detail than the studio does, and get you to make decisions about exactly what you want build. The studios are intended to provide space for creativity – but when you are writing a specification, you don’t want to let the programmer be too creative or you will get back something very different than what you intended. So you will have to be creative yourselve, when creating the specification, and be very specific about what you want to the programmer to provide. For example, if you chose Studio 3: Flashcards, you would need to decide what topic you want your flashcards to be about, how many flashcards you want, and write the content for the flashcards compete with prompts and answers. Also, decide what you want the program to look like. What functions should exist? What interface shoudl it have? Should it ask repeatedly until answered correctly, or move on and count wrong answers? You will not be writing the code for this; someone else will. You are just specifying what code you want written, and what it should do once it is finished. Think about how you want someone else to write the code. As you write the specification, remember that the programmer will have about 2 hours to implement this. How much could you get done in 2 hours? What is reasonable to ask for in 2 hours? . | Next, we will swap with partners. Your partner will take your specification and try to implement it. They will write code that tries to do what you specified. And, conversely, you will try to write the code that they specified. They will ask you to do things differently than you asked. Your job will be to do what they asked, not what you envision. | Finally, we will swap back. You will be given a working version of what you specified. Your job now will be to test it: did they do what was asked? What works? What doesn’t? Re-read your specification and compare the program you were given against it. Think about whether the code that you were handed actually works the way you think it should. If it doesn’t, is what the code does reasonable, or would you describe it as a bug or a failure? . | After you’ve gone through all three steps – specification, implementation, and testing – please write up a short reflection. What was the process like? Waas it hard to write a specification that you weren’t going to program yourself? Did the other person interpret things similarly to you or differently than what you imagined? Did you get back something close to what you expected? Did everything work well, or were there bugs in the code? Was it hard to write code where someone else decided what the program should do? Or was it easier because you knew exactly what the proram was supposed to do? (Also, think about all the questions and ideas in the “Is this fun?” heading above.) . | . The reflection doesn’t need to be long; a paragraph or two about what its like to ask someone else to write code, and another paragraph or two about what its like to be the programming doing work for someone else should be enough. What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. ",
    "url": "/honors.html#honors-option-contract-programming",
    "relUrl": "/honors.html#honors-option-contract-programming"
  },"121": {
    "doc": "Honors Option",
    "title": "Advice",
    "content": "Be Detailed and Specific . The specification is your contract; it tells the other team what you want done. The more specific you can be, the more likely you are to actually get what you want. If you are doing flashcards, Don’t just say “do some math problems” – how will they ever know what that means? If you just say “do some math problems”, then they might give you back flashcards for grade school math (2+2=4), or they might give you back calculus problems. Which one die you want? Instead, give them exact problems for the flashcards. Tell them exactly how many flashcards. Think about how you would implement it, and give them some structure that they can use to make it work correctly. Do you want it to count the number correct? Do you want it to be serious and boring, or snarky and funny? Be specific. Specify both program and content . The natural impulse is just to write the content (e.g. for the flashcards – what questions should it ask, and what should the answers be?) But that’s not enough. You are asking them to write a computer program. Be sure to also specify what that program should do. Should it be graphical (turtle) or text-based (terminal)? Should it be case senstive? Should it give the user more than one chance to get it right? Should it count the number correct? What else should it do? Anything it should NOT do? . Think About Testing While Writing the Specification . Near the end of class, you are going to get back some code. It almost certainly will not do exactly what you expect it to – but your partner will think it does. Think about how you will test it. As you are writing the specification, also jot down some notes about how to test it. What things will you look for? What does it mean to “work” correctly? What are some possible inputs, and what would you expect to happen with those inputs? . Choose something interesting . I gave an example above using the flashcards studio. But that is probably the least interesting and least creative studio of the year. Try to choose something either that you think would actually be useful to you, or would be interesting for you to work on and think about. Then make it more interesting to you – be creative, and come up with an interesting program that you would want done. Remember, you want creativity to be part of the specification, not part of the implementation. Ask for clarifications . Despite trying really hard, program specifications are almost always more vague and less detailed than you would like. As you start writing code, you start to realize all of the things that the specification did NOT specify. It is OK to ask for clarifications. “When you said X, what did you mean?” “If this happens, would it be better if the program does X or Y?” Clarifying questions are normal and good. Use email to communicate . This isn’t a one-time handoff. You are allowed to communicate with the other team. You will be implementing their specification, and they will be implementing yours. Talk to them! Ask questions! Answer their questions. Get to know them. You’ll need to think about how to do this communication. You’ll probably have multiple questions. Do you send them a separate email every time something comes up? Can you figure out any of the answers yourself? Do you need to wait for a response, or can you keep working while you wait? . When you need a clarification, communicate via email, and CC both Jack and Rick when you email. Is this fun? . As you work, think about what parts of this you are enjoying, and what parts you don’t. Some people really like being told what to do, and having a specification to work towards is nice and easy. Other people hate it because it feels uncreative and like they can’t express themselves. Some people really like testing because it is fun to break things and think about all the weird ways that programs get used; other people hate testing and find it very tedious. Some people like writing specifications because they get to see lots of possibilities, and then get to have other people make them happen. Other people hate writing specifications because they feel like writing down all the details that a specification needs is more work than just writing the code. Think about what parts of this you like, and what parts you don’t like. This will help you as you move forward in your career in thinking about what parts of the work you might want to do, or might want to avoid. (This is a good thing to mention in your reflection.) . Limit your commitment . This honors option shouldn’t take a ton of time. For coming up with a specifcation, set a timer and limit yourself to about 20-30 minutes. Try to come up with a good specification in that time, but its OK if it isn’t perfect. For the actual programming aspect, expect about 2 hours of work – about the same amount of time and complexity as a normal studio in class. Try to design your specification to be able to be done in that amount of time. And when you are programming, limit your time to about 2 hours. IF you really want to, you can go longer, but think of it like a contract job – the client agreed to pay you for 2 hours of work, so if you do more than that, you are doing it for free! . ",
    "url": "/honors.html#advice",
    "relUrl": "/honors.html#advice"
  },"122": {
    "doc": "Honors Option",
    "title": "Suggested Timeline",
    "content": "These dates are only suggestions. Please feel free to recommend changes if you would like different deadlnes. | Step | Time Commitment | Due Date | How to turn in | . | 1. Specification | 20-30 minutes | Friday, April 7 | Email to partner; CC Rick and Jack | . | 2. Programming | ~2 hours | Friday, April 21 | Create new Gitlab repo with your program and place a copy of the specs you followed in it. Add partner, as well as Rick and Jack, to repo as maintainers. Email partner, CC Jack and Rick when done. | . | 3. Testing | 20-30 minutes | Friday, April 28 | (Nothing to turn in, but would be helpful for you to write down a list of what works as you expected and what doesn’t to refer to as you write your reflection) | . | 4. Reflection | However long it takes you to write 2-4 paragraphs | Wednesday, May. 3, 7:45pm (end of finals timeslot for this class) | See bottom of guidelines for what to write about. To turn it in, email to Jack and Rick as PDF or Word doc. Also include a link to the Gitlab repo you created (with the program you wrote based on your partner’s specifications) in the email and/or in the reflection paper. | . ",
    "url": "/honors.html#suggested-timeline",
    "relUrl": "/honors.html#suggested-timeline"
  },"123": {
    "doc": "Honors Option",
    "title": "Honors Option",
    "content": " ",
    "url": "/honors.html",
    "relUrl": "/honors.html"
  },"124": {
    "doc": "Homework",
    "title": "Instructions",
    "content": "For each exercise below, write your answers to the questions in Word (or similar) and include at least one screenshot which shows your search results. Paste your screenshots directly into Word underneath your answers. Your answers don’t need to be more than 1-2 sentences. Note: If you would prefer to use Bing or DuckDuckGo or some other search engine than Google for this assignment, that’s fine. Everything below will work in most search engines. Exercise 1 - General keyword search . When working with a specific programming language, it’s always very useful to include the name of the language in the search terms you use. For this class, that means including the word “python” in your searches. Let’s say you want to figure out how to use an “else” statement in Python. Use Google to search for the term “else statement”. What’s the first thing that comes up? How far down do you have to scroll before you get a search result that’s specific to Python? Is the featured snippet at the top of the search useful? (Include a screenshot of the results.) . Now search for “else statement python”. How are the results different? (Include a second screenshot of these results.) . Exercise 2 - Define . Google Search allows you to use a number of different operators to narrow your search results. If you’re trying to understand what a term or concept means, the “define” operator can be very helpful. define:else statement . Note there is no space between “define:” and the term you want defined. This is important. Search for “else statement” using the “define:” operator, as shown above. How are the results different from when you searched for “else statement” in exercise 1? . Exercise 3 - Exact search terms . Sometimes you want to find results that exactly match the search terms you use. You might want to do this if the search results coming up aren’t specific enough. To search for a specific phrase, put the phrase in quotes. Google this phrase without quotes: what does elif do . Now use quotes around it: \"what does elif do\" . Take screenshots for each result. How are the results different? Which of the results do you find most useful? . Exercise 4 - Site search . There’s also an operator that allows you to use Google to search a specific website rather than the entire internet. It works like the “define” operator, except you can add additional keywords after it. So if I wanted to search Reddit to see what kinds of reading chairs Redditors recommend, I could do this: . site:reddit.com best reading chair . This will bring up search results only from Reddit. Note that you have to include the domain extension for the url (like .com or .org) as part of the site name. If you try it with just site:reddit your search won’t work. Reddit can actually be a useful site for finding answers to specific programming questions. Stack Overflow (stackoverflow.com) is also a very useful site for programming questions, and the official Python documentation (python.org) will be useful for this class, too. Search Reddit, Stack Overflow, or the Python documentation to find out whether you always need to have an else statement after an if statement or not. Make sure your search is specific to Python. What search terms did you use to find the answer? Did you try using quote marks around any phrases? Which site(s) did you search? About how many searches did you do before you found a good answer? . Include two screenshots: one of the search results for the last search you did, and one showing the webpage with the best answer you found. ",
    "url": "/homework/hw1_google.html#instructions",
    "relUrl": "/homework/hw1_google.html#instructions"
  },"125": {
    "doc": "Homework",
    "title": "Turn in",
    "content": "Turn your assignment in as a Word doc or a PDF on D2L under Assignments -&gt; Google Search and Programming. This assignment is due on Wednesday, January 31st at 3pm (before the start of class). Grades will be based on following the instructions and making an honest effort. If you describe your findings for each exercise particularly well, that will earn you a check plus. ",
    "url": "/homework/hw1_google.html#turn-in",
    "relUrl": "/homework/hw1_google.html#turn-in"
  },"126": {
    "doc": "Homework",
    "title": "Homework",
    "content": "Google Search is an incredibly important tool to use when learning and practicing programming. It’s not expected that you will memorize how to do absolutely everything with code. You won’t be able to, there’s just too much to know. It is expected that you will be able to figure out what you don’t know. Google Search is one of the best tools for that. Professional programmers routinely use Google to remind themselves how to do certain things with code, to find examples of how other people have written code for solving a specific problem, and even to find freely available code they can add to their own programs. The goals of this assignment are to get you started with understanding what Google is and isn’t good for, and to give you some tips for using Google more effectively. ",
    "url": "/homework/hw1_google.html",
    "relUrl": "/homework/hw1_google.html"
  },"127": {
    "doc": "Homework",
    "title": "Instructions",
    "content": "Each of the exercises below includes an error message and the snippet of code that caused the error. In your own words, describe what’s happening with each of the error messages below. Describe: What do you think caused the error? How would you go about trying to fix it? Try to make your descriptions as human-readable as possible - pretend you’re trying to explain it to your partner during a lab or a studio during class. Exercise 1 . Code: . person = \"Thor\" if (person == \"Thor\") or (person == \"thor\") print(\"Thor walks over to the hammer and reaches down to pick it up.\") . Error message: . PS C:\\Users\\geier\\Desktop\\mi250&gt; python avengers.py\" File \"c:\\Users\\geier\\Desktop\\mi250\\avengers.py\", line 2 if (person == \"Thor\") or (person == \"thor\") ^ SyntaxError: expected ':' . Exercise 2 . Code: . body_part = \"head\" print(\"Nothing goes over my\", body_part, \". My reflexes are excellent and I would\", action, \"it.\") . Error message: . Traceback (most recent call last): File \"C:\\Users\\geier\\Desktop\\mi250\\mad-libs.py\", line 2, in &lt;module&gt; print(\"Nothing goes over my\", body_part, \". My reflexes are excellent and I would\", action, \"it.\") ^^^^^^ NameError: name 'action' is not defined . Exercise 3 . Code: . answer = input(\"What is my favorite color? \") if answer.lower() == \"green\": print(\"Right! Green is my favorite color.\") else: print(\"Wrong!\") . Error message: . PS C:\\Users\\geier\\Desktop\\mi250&gt; python question.py File \"C:\\Users\\geier\\Desktop\\mi250\\question.py\", line 5 print(\"Wrong!\") ^ IndentationError: expected an indented block after 'else' statement on line 4 . Exercise 4 . Code: . count = input(\"How high do you want the count to go? \") for num in range(count): print(num) . Error message: . Traceback (most recent call last): File \"C:\\Users\\geier\\Desktop\\mi250\\counter.py\", line 2, in &lt;module&gt; for num in range(count): ^^^^^^^^^^^^ TypeError: 'str' object cannot be interpreted as an integer . ",
    "url": "/homework/hw2_errors.html#instructions",
    "relUrl": "/homework/hw2_errors.html#instructions"
  },"128": {
    "doc": "Homework",
    "title": "Turn in",
    "content": "Turn your assignment in as a Word doc or a PDF on D2L under Assignments -&gt; Understanding Error Messages. This assignment is due on Wednesday, February 21st at 3pm (before the start of class). Grades will be based on following the instructions and making an honest effort. If you describe your findings for each exercise particularly well, that will earn you a check plus. ",
    "url": "/homework/hw2_errors.html#turn-in",
    "relUrl": "/homework/hw2_errors.html#turn-in"
  },"129": {
    "doc": "Homework",
    "title": "Extra tips and resources",
    "content": "As already mentioned, Google (or the search engine of your choise) is one of the best resources for looking up error messages. Here are a couple of other helpful resources: . | Error types in Python | Common Python runtime errors beginners find | . Note that text editors like Visual Studio Code will also highlight issues that will cause errors, usually in red or yellow. That can help you spot and fix issues before you run the program. It can also be helpful to look at the syntax highlighting - that is, the different colors text editors use to represent different parts of the code. For examples, VS Code always shows strings in Python files as orange text. If you know a line of text is supposed to be a string but it’s not all in orange, that’s a sign that there’s something wrong that needs fixing - like a missing quote mark (“) at the beginning or end of the string. ",
    "url": "/homework/hw2_errors.html#extra-tips-and-resources",
    "relUrl": "/homework/hw2_errors.html#extra-tips-and-resources"
  },"130": {
    "doc": "Homework",
    "title": "Homework",
    "content": "Learning how to read and understand error messages that you get when you are running and testing programs is an important skill to have. First, it’s good to understand the anatomy of an error message. This is different for different programming languages. For Python, error messages usually have 3 parts: . | What file the error is in and the line number in the file that the error is on (or near) | The actual line of code causing the error | The type of error and a brief explanation of what the error is | . It’s helpful to know how to read and understand the different parts of error messages because those messages are meant to help you figure out a) where the error is and b) how to correct it. Google is a very valuable resource for understanding error messages as well. For the exercises below, you might want to use Google to figure out what each error message means. I recommend trying to figure out what the message is saying on your own first, then use Google as a backup option. ",
    "url": "/homework/hw2_errors.html",
    "relUrl": "/homework/hw2_errors.html"
  },"131": {
    "doc": "Homework",
    "title": "Instructions:",
    "content": "Find a job posting for a job you would like to have someday in the future. You don’t have to be qualified for the job. Some good places to look for job postings are Glassdoor, Indeed, and LinkedIn. Handshake is also a useful, MSU-specific resource. There are also a lot of useful resources on the ComArtSci career center website. Save the link to the job posting to copy into your assignment. Now, write a 2-3 paragraph reflection about the job posting you found: . | Summarize: write 1 paragraph summarizing the job posting. For example, what is the job title, what company/organization is it for, what are the main responsibilities for the job, what skills (if any) are required or recommended, etc. Pay special attention to the details that are interesting to you personally. | Reflect: write 1-2 paragraphs reflecting on how programming might (or might not) be a useful skill if you were to apply to this job. Think not only about what the responsibilities of the job are, but also what kinds of people you might be working with. Also think about whether a knowledge of programming would make some aspects of the job easier. | . Please turn in your reflection in on D2L either as a Word doc or a PDF. Include the link to the job posting somewhere in the document you turn in. ",
    "url": "/homework/hw3_jobs.html#instructions",
    "relUrl": "/homework/hw3_jobs.html#instructions"
  },"132": {
    "doc": "Homework",
    "title": "Homework",
    "content": "This is a short research and writing assignment. The purpose of this assignment is for you to reflect on how programming might fit into your future. ",
    "url": "/homework/hw3_jobs.html",
    "relUrl": "/homework/hw3_jobs.html"
  },"133": {
    "doc": "Homework",
    "title": "Homework",
    "content": "TBD - exercises for students to try a few things on ChatGPT, including instructions for getting signed up for it if they aren’t already. Reflection on how ChatGPT is / isn’t useful for programming. ",
    "url": "/homework/hw4_chatgpt.html",
    "relUrl": "/homework/hw4_chatgpt.html"
  },"134": {
    "doc": "Homework",
    "title": "Homework",
    "content": "TBD - ask students to find and read a recent article about something relating to ethics and programming or ethics and technology. Suggest a few resources (e.g. Ars Technica) for them to look through. Write a brief summary of the ethical question covered in the article and reflect somehow. ",
    "url": "/homework/hw5_ethics.html",
    "relUrl": "/homework/hw5_ethics.html"
  },"135": {
    "doc": "Software Testing",
    "title": "Software Testing",
    "content": " ",
    "url": "/testing/",
    "relUrl": "/testing/"
  },"136": {
    "doc": "Software Testing",
    "title": "Exercise: What is a bug?",
    "content": "Software testing is the process of finding and eliminating bugs in software. Take a minute and write down your answer to the question “What is a bug?”. Go ahead; I’ll wait. Computer programs are written with goals in mind; the program is supposed to do something specific. A bug is anytime that the program doesn’t do that. That is, a bug is anytime there is a difference between what the program is supposed to do and what the program actually does. As computer programs get more complicated, so do the bugs. A simple computer program often only does one thing. If it does that then, then great; it works. When you make computer programs more complicated, they have to work in a wider variety of different settings. Different people might enter in different inputs. The program has to work with different types of data. The program has to work on different computers (Mac vs. Windows) with different size screens and other differences. Bugs may appear only in some circumstances but not others – it may work fine for you on your computer, but not for me on my computer. But still, that’s a big problem for me! (AND, also, a problem for you if you want me to pay you for the computer program….) . Fixing Bugs . When people write programs, they often think that they should try to write programs that don’t have bugs. But, that’s impossible! They also think that programs aren’t done until they are bug-free. That’s also impossible! Microsoft Windows shipped with millions of known bugs that were not fixed. People still bought it and use it on a regular basis. Fixing every bug is hard, and often not worth the time and effort. If a bug is any time what the program actually does is different than what the program is supposed to do, then there are two ways to fix a bug: . | Change what the program actually does. Modify the code so that the program does what it is supposed to do. | Change what the program is supposed to do. Change your idea of what the program is supposed to do and what kinds of things it can and can’t do. (and, if applicable, change the written specification) | . Both are entirely reasonable ways to fix a bug. Also, it is reasonable to choose to not fix a bug; just acknowledge that it exists but that it isn’t worth fixing. ",
    "url": "/testing/#exercise-what-is-a-bug",
    "relUrl": "/testing/#exercise-what-is-a-bug"
  },"137": {
    "doc": "Software Testing",
    "title": "Why Test?",
    "content": "Computer programs do not always work as the programmer intends them to. Often, I write code that I think does one thing, and then when I run it, I find out that it does something else. This is a very normal thing to happen, and every programmer experiences it on a daily basis. Testing is really an attempt to understand what your program actually does. Testing is a way to better understand the program that you’ve written and what it can and cannot do. Testing is the process of trying to find bugs. Testing does not necessarily involve fixing bugs. Instead, you test your program to try to learn about the bugs that exist. This gives you the information you need to decide whether it is worth fixing the bugs or not. Automated vs. Manual testing . There are two major ways of doing testing: manually testing the program by running it and entering inputs on your own, and automated testing by writing a 2nd program that tests your 1st one. You are already familiar with manual testing. You do it all the time. You write code, and then you run the code and see what happens. You have some idea in your head about what the program should do, and then you run the program and see what the program actually does. Often, this isn’t a very structured or formalized process, but you still do it all the time. You run your program over and over, adding code and trying different inputs, to see what happens. This is manual testing. It is possible, and not uncommon, to do more structured manual testing. Rather than just ad-hoc running your program, you could think carefully about what kinds of inputs your program might get, and then write down a list of possible inputs. Then you could think about, for each input, what should the program do? Write that down next to the input. Rather than having some vague notion about what the program should do, you now have explicitly written down the expected output. Now you can run the program multiple times, and see if what the program does matches what you wrote down that it should do. This structured, manual testing is quite common in the real world. Large companies pay people to run these structured manual tests and figure out if the program does what it is supposed to do. Some things, like user interfaces, are difficult to test automatically, and mostly are tested this way. However, running through these tests manually is hard and boring work – especially if you have to do it frequently. So, programmers often do what they are good at – they write a computer program to automatically run tests and check if the program does what it is supposed to do. Automated testing invovles using one computer program to test another, and is an extremely common way to do testing. As programs get bigger and bigger, automated testing becomes more important. Regression bugs: bugs that appear later, breaking previously working code. As you work on writing computer programs, one thing that you notice is that you change things in one place, and it affects other parts of the program. That is, it is possible (and common) that one part of the program works fine NOW, but later on you change something else and now that part no longer works. When this happens, it is called a “regression bug”. Regression bugs are really nasty, because they mean that you tested the program and it worked, but then later on it stopped working. The only way to catch regression bugs is to re-run all of your tests again, to make sure that the program still does everything it is supposed to. But doing that is a real pain. That’s one of the big reasons that we automate tests; it is much easier to re-run tests if they are automated and can be run with a single keystroke. ",
    "url": "/testing/#why-test",
    "relUrl": "/testing/#why-test"
  },"138": {
    "doc": "Software Testing",
    "title": "Test Cases and Automating Tests",
    "content": "In order to think about how to test software, we break our program down into test cases. Each case tests one specific feature or function of a program, and a single input to that part of the program. To test a program you’ve written, you will normally have many different test cases that test different parts of the program with different inputs. Basically, test cases break the job of software testing into discrete, managable parts. What is a test case? . A test case is a well-specified set of inputs and expected outputs. Above, I talked about how you could write down an input to your program, and then also specify what the output should be. That is a single test case. The trick with test cases is to be very specific. You are testing a very specific, logical piece of functionality of your code with a well-defined input and well-defined expected output. If your test case is specific enough, then it should be easy for anyone to tell whether the actual output matches the expected output; that is, you can tell whether the test case “passes” or “fails”. Automated test cases: Easy to run over and over . When we are writing automated tests, we usually break our tests into test cases. One function executes exactly one test case, and then decides whether that test passes or fails. For example, let’s pretend we have a really simple function called add() that takes two numbers and adds them together. If I add 1 and 2 together, I would expect to get 3, right? We can make that into a test case – if I call add(1,2), then I would expect the result to be 3. To do testing, we use the assert command in Python. Assert means to test and see if the result is what is expected. So, a really simple automated test case for the add() function would be: . def test_add(): result = add(1,2) assert result == 3 . In this case, the code is a test because the function name starts with test_. It runs the add() function with 1 and 2 as parameters, and then stores the actual result that is calculated in a variable called result. Then it checks (asserts) that this result is equal to 3 – the expected output. If it is equal, then we say that the test case “passes”, and the result is what we expect. If it is not equal, then we say that the test “fails” because it is not what we expected. This is a single test case. If I wanted to test a different set of inputs, that would be a separate test case. So if I also wanted to check that adding 0 and 0 results in 0, here is a second test case: . def test_add_zero(): result = add(0,0) assert result == 0 . Testing harness: runs a collection of test cases and produce output reports . Now we have more than one automated test case. What if we want to run all of these tests, and collect the results into a single output that is easy to read? That is the job of a test harness: a program that runs automated tests for us and reports on their results. In python, a common test harness that is built in is called UnitTest. There are other ones that are commonly used also, such as pytest or nose. ",
    "url": "/testing/#test-cases-and-automating-tests",
    "relUrl": "/testing/#test-cases-and-automating-tests"
  },"139": {
    "doc": "Software Testing",
    "title": "Types of Tests",
    "content": "Most software has a large number of tests associated with it. It is not uncommon for the test code to be more lines of code than the code that is being tested. Now, the next question is what kinds of test cases should we create? How do we think about what to test? . What follows is one way to think about what to test. It is not the best way, and it is certainly not the only way. But it is a useful way to organize your thinking. To help illustrate, I will be writing tests for a function that generate Fibonacci numbers – a sequence of numbers that goes 1, 1, 2, 3, 5, 8, 13, 21, 34… Each number in the sequence is the sum of the two previous numbers. The function takes as a parameter which number in the sequence it should generate (the 1st number, or 3rd number, or what), and it returns that number. Here is an implementation of that function: . def fib(n): if n &lt;= 2: return 1 return (fib(n-1) + fib(n-2)) . For the first two numbers (n=1 and n=2), it returns a hard coded 1. For each number after that, it calculates the two previous numbers and adds them together. This is just an example function. We could write tests for almost any function we create. Level 0: Basic Functionality . The first types of test cases that I write are called “Level 0” tests. These test the most basic functionality; if these fail then the function is hopelessly broken and needs to be fixed. Level 0 tests should test the one or two most common use cases of a function to make sure that it works correctly with completely normal input. For the Fibonacci function, a very normal use is to ask it for the 3rd or 4th number. Let’s pick one – the 4th number. Looking at the Wikipedia page for Fibonacci nunbers, it looks like 4th number is 3. So we would expect fib(4) to result in 3. We can write this as a test case: . ### Level 0 tests def test_fib_3(): assert fib(4) == 3 . Usually we don’t have many level 0 tests. We write level 0 tests just to check and make sure that the most basic funcationality works. If there is a syntax error, or if fib() does something unrelated to Fibonacci numbers, or if I forgot to write the code for fib(), then this test will catch that. All it does it make sure that the most normal, basic way of using the function works. Level 1: Full Range of Functionality and Edge Cases . Once the Level 0 tests are passing, we know that the basic function works. The next thing I do is write Level 1 tests. These tests look at the full range of functionality to try to identify what are the edge cases and different types of inputs that the function should handle. We should use our knowledge of the function to try to identify tricky cases, and test those to make sure they work. However, all of the Level 1 test cases should be valid cases, in that they ask the function to do things that it normally would be expected to do. For the fib() function, what are some tricky cases that it needs to handle? Well, the first two Fibonacci numbers are always tricky, because they are different than the others. The first number should be 1, and the second number should also be 1. Let’s write a couple of tests for those: . # Level 1 tests def test_fib_1: assert fib(1) == 1 def test_fib_2: assert fib(2) == 1 . Are there any other trick cases? Let’s pick a higher nunber, and make sure that it does calculations accurately. Looking at the Wikipedia page for Fibonacci numbers, the 10th number is 55. So let’s check that to make sure it calculates larger and more complicated numbers correctly: . def test_fib_10(): assert fib(10) == 55 . Ideally, you want to keep writing Level 1 tests until you’ve tests the full range of valid inputs – long inputs, short inputs, big numbers, small numbers, blanks, etc. Everything that is valid, you should write a test for to make sure that it works. Level 2: Error conditions . Almost all programs have invalid inputs – inputs that are considered to not be legitimate. However, sometimes the user ends up providing an invalid input. Good programs detect that the input is invalid, and handle it appropriately (for example, by displaying an error message). Level 2 tests test these invalid inputs. They intentionally provide invalid inputs to the program, and then check to make sure that the program does something reasonable with that input. For example, the fib() function only really produces sensible outputs for positve, whole numbers. If you enter a negative number, or if you give it a fraction, it doesn’t know what to do. What should it do? Often, when writing test cases, you realize that you don’t know what a program should do. If a bug is when what the program actually does is different than what the program should do, then it is a problem if you don’t know what the program should do! . This is surprisingly common, to not know what the program should do. This is another benefit of testing – it forces us to think through all of the things that can happen, and try to figure out what we want to the program to do in each of these situations. For the Fibonacci function, what do we want the program to do if it gets an invalid input? Let’s say that is should throw an IndexError any time it gets an invalid input. Now that we know what it should do, we can write some tests for some invalid inputs. We can use pytest.raises() to check and make sure that that error is raised. The test fails if it does NOT raise that error, and it passes if it does create that error: . # Level 2 tests def test_fib_negative(): with pytest.raises(IndexError): fib(-1) def test_fib_fraction(): with pytest.raises(IndexError): fib(2.5) def test_fib_string(): with pytest.raises(IndexError): fib(\"hi\") . If you run these tests with our fib() code above, you’ll see that these Level 2 tests fail! Uh oh! We have found some bugs in our code – it doesn’t handle error conditions very well. First, we need to decide if we care – is this a bug that is worth our time fixing? If it is, then we need to change our fib() code to make it do the right thing. Level 3: Performance and Scalability . Once all of the tests for Levels 0, 1 and 2 are passing, then the program mostly works correctly – it does what it is supposed to do. However, that’s not quite enough. There are usually other goals that programs have – for example, running fast enough that the user doesn’t get bored. Level 3 tests test these other, non-correctness features of programs. For example, it is a problem if it takes minutes to calculate our Fibonacci number. That’s not good. The computer should be able to calculate it in less than 10 seconds. So let’s write a test to check this: . # Level 3 tests def test_fib_speed(): start = datetime.datetime.now() out = fib(40) end = datetime.datetime.now() assert (end-start).total_seconds() &lt; 10 # It should take less than 10 seconds to compute . Example . You can download these examples here. This file contains the basic fib() function, and all of the tests listed above. To run it, use the command: . pytest fib.py . OR, alternatively, you can run it with . python3 -m pytest fib.py . When you run it, you should see that four of the test fail! Our fib() function only passes half of the tests. As an exercise, can you fix it so that all the tests pass? (Solution) . ",
    "url": "/testing/#types-of-tests",
    "relUrl": "/testing/#types-of-tests"
  },"140": {
    "doc": "Software Testing",
    "title": "Testing an Application",
    "content": "When testing a whole program or large application, there are some additional considerations. Specifically, it is really valuable to distinguish between unit tests and integration tests. Unit tests . Most programs are split up into smaller, logical units of functionality. A unit test tests a single, small unit of functionality. Often, we do this with functions; a unit test can test that a function works correctly. All of the tests we wrote above for the fib() function are unit tests – they test a small unit of functionality that is (most likely) part of a larger program. Unit tests are very common, and the majority of automated tests that are written are unit tests. Unit tests are great for catching regression bugs and for helping us to think through program and make sure that we cover everything it is supposed to be able to do. Integration tests . However, it is possible that all of the individual pieces work correctly on their own, but that they don’t fit together properly. That is where integration tests come in. Integration tests look at the program as a whole, and make sure that the pieces all fit together properly in a way that works. The most common way to create an integration test is a user script – write a script of what the user would do when using the application as a whole, and then annotate the script with what is expected to happen at each stage. User scripts can capture the overall functionality of a program in a way that unit tests don’t. Integration tests can be automated, and many good integration tests are. But often, we also do integration tests as manual tests, running through the application and making sure that it works as a whole. Exercise . You can try to complete the testing lab. ",
    "url": "/testing/#testing-an-application",
    "relUrl": "/testing/#testing-an-application"
  },"141": {
    "doc": "Home",
    "title": "MI 250: Introduction to Applied Programming",
    "content": "This course is a first introduction to computer programming, designed for students who will not become professional programmers but who will need to use technical skills or interact with programmers. That is, the course helps students understand how to think about programming computers, and builds some basic skills at getting computers to do what they want them to do, without an expectation that they go on to take large numbers of future programming courses or work professionally doing programming. Everyone can learn to program. Everyone. And understanding more about how computers work, how programmers work, and what is easy vs hard for computers are extremely useful skills. Those skills are valuable for people doing analytics, graphic design work, creating user experiences, building games, and almost anyone who works with computers as part of their job. This course is offered through the Department of Media and Information at Michigan State University. ",
    "url": "/#mi-250-introduction-to-applied-programming",
    "relUrl": "/#mi-250-introduction-to-applied-programming"
  },"142": {
    "doc": "Home",
    "title": "Spring 2024",
    "content": "Class meets on Mondays and Wednesdays at 3:00-4:50pm in Holden Hall, room C131. Course content can be found on this site and on Gitlab. D2L is used for turning in assignments and keeping track of grades. Useful links: . | Syllabus | Course schedule | Gitlab | D2L | . ",
    "url": "/#spring-2024",
    "relUrl": "/#spring-2024"
  },"143": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    "relUrl": "/"
  },"144": {
    "doc": "Lab",
    "title": "Pair Programming",
    "content": "In this class, all of the labs will be done through pair programming. You will be assigned to work with one other person as a “pair”. Pairs work following the mantra of “2 people, 1 computer”; that is, both people work together on a single computer to get the lab exercises done. You must do all of the lab exercises together. You’ll be randomly assigned into a pair for each lab. At any given time, each of you will have different roles. One person will be the “driver”, and the other person the “navigator”. Once you’re paired up, begin by deciding who will be the driver and who will be the navigator. Driver . The driver controls the computer. They are physically in front of their computer using the keyboard and mouse. The job of the driver is to get the computer to do the tasks assigned in the lab. The driver is ultimately responsible for what happens on the computer. Navigator . The navigator (also called the observer) watches the driver’s activities. They make suggestions, point out errors and problems, ask questions, and think more carefully about what is being done. Being a navigator does not mean being passive; you should be actively watching and trying to help out. Since laptop screens are small, it may be helpful if the navigator uses their laptop or another device to keep the lab instructions up or to look things up. It is very important that both members of the pair communicate regularly. The driver can ask questions and discuss issues, the navigator can ask that specific changes be made or specific code by typed in, and both members can stop what is going on to discuss anything they feel needs to be discussed. Periodically, both of you will switch roles. In some labs, we will switch roles when you complete specific parts of the lab (like today). In other labs, we will set times, and we will switch roles every 20 minutes or so. Everyone should be both a driver and a navigator at some point during the lab. ",
    "url": "/labs/installing_python.html#pair-programming",
    "relUrl": "/labs/installing_python.html#pair-programming"
  },"145": {
    "doc": "Lab",
    "title": "Get ready to work with Python",
    "content": "The goal of this lab is to get everything set up to run your first python program on both your own computer and your partner’s computer. I will give you a program, and you can both run it on your computers. For this section, the driver will do everything on their computer first with the other person acting as navigator. Later on in the lab you’ll switch places. Remember you’ll learn faster by working together! . Install Python . Python is a programming language, but is interpreted, which means that there is a separate program that reads the program that you write and “runs” it by interpreting it as instructions. That is, it is a program that runs other programs. The first thing we need to do is go install Python. Go to the main Python website at https://www.python.org. On that page, hover over the “Download” menu and you should see a button with Python 3.12.X on it. Click the button to download the program, and run the installer program. That will install the current version of the python interpreter on your computer. Important: While running the installer, be sure to click the “Add python to the PATH” checkbox. If you already have python installed on your computer, make sure you have the current version (3.12.X). If the version of Python you have installed is not the current version, then run the installer and it should replace the old version of Python with the current version. Use Command Line . Next, we want to make sure that Python is installed, and that it is installed correctly. To do this, we are going to use command line. We will be using command line for a lot of things in this class, including running code and saving code to the cloud. If you have Windows . In Windows, we are going to use the “PowerShell” command line interface. This comes built in to all recent versions of Windows. To access this, click on the search bar and type in “powershell”, and that should find it. Run it. It should open up a window with a bunch of white text at the top on a blue or black background. You’ll see a prompt with a blinking cursor in front of it, like this: . PS C:\\Users\\geier&gt; . The first thing we are going to do is to verify that we have python installed correctly. To do that, simply type python where the cursor is and hit enter. If it works, you should see something like this: . Python 3.11.5 (tags/v3.11.5:cce6ba9, Aug 24 2023, 19:29:22) [MSC v.1936 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. &gt;&gt;&gt; . The three arrows &gt;&gt;&gt; mean Python is in interactive mode. Try typing 2+2 and hitting enter. It should add the numbers for you. You can use this mode to try out short snippets of code to see if it works. We won’t be using it much in this class, though. To get out of Python’s interactive mode, type quit() and hit Enter. On Windows, you can also hit Control-Z and then Enter. Troubleshooting . If the Python install doesn’t work, you’ll get an error message (on older versions of Windows), or it will open Python in the Microsoft store (on Windows 10 or 11). Try closing PowerShell and opening it again. If it still doesn’t work, it means Python isn’t properly installed. Run the Python installer again. If it is already installed, if will give you an opportunity to “modify” the Python install. Do that. Click through the optional features, and then you should see a page of “Advanced Options”. On that page, click the checkbox next to “Add python to environment variables”. Then click install to finish it. After this, close PowerShell and open it again, then try the python command again. If you have Mac OS . On a Mac, we will use the Terminal app. Terminal gives us a command line that we can use to run things. On the launchpad or in the applications list, it is usually in the “Other” folder. Or you can click the spotlight search icon (the magnifying glass in the upper right) and type in “terminal”. Terminal should open up a window with a bunch of text in it, and a prompt with a blinking cursor next to it. It might look like this: . Last login: Mon Aug 28 23 16:57:43 on ttys000 geier-Macbook-Pro:~ geier$ . If you type, it should appear next to the prompt. Type the command python3 and hit enter. If it works, then you should see something like this appear: . Python 3.11.1 (default, Aug 23 2023, 11:08:38) [Clang 12.0.0 (clang-1200.0.26.2)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. &gt;&gt;&gt; . The three arrows &gt;&gt;&gt; mean Python is in interactive mode. Try typing 2+2 and hitting enter. It should add the numbers for you. You can use this mode to try out short snippets of code to see if it works. We won’t be using it much in this class, though. To get out of Python’s interactive mode, type quit() and hit Enter. On Mac, you can also hit Control-D. Important: Macs come pre-installed with a REALLY old version of Python (2.7). Many of the things we do in this class won’t run on that version of Python. If you just type python, it’ll run that really old version. If you are using a Mac, you should always type python3 instead of python to run python. That way, you’ll use the current version. Be sure to check the version number that is printed out to make sure it is correct. Troubleshooting . If you get an error message, that means Python wasn’t installed properly. Try closing Terminal, opening it again, and then trying the python command again. If it still doesn’t work, try running the Python installer again. ",
    "url": "/labs/installing_python.html#get-ready-to-work-with-python",
    "relUrl": "/labs/installing_python.html#get-ready-to-work-with-python"
  },"146": {
    "doc": "Lab",
    "title": "Run your first program",
    "content": "Next, we are going to try to run our first Python program. The program is called eliza.py - eliza is the name of the program, and the .py at the end means it’s a Python program. All Python programs end with .py. Download eliza.py from Gitlab . Near the top of this webpage is a link to a Git repository on Gitlab (which is similar to Github, except it’s administered by MSU). The repository contains the code for this week’s lab. Each week’s lab will have a Gitlab link at the top. When you go to Gitlab for the first time, you’ll need to log in. Click the “Okta” button (and check the “Remember me” box down below so you won’t have to log in everytime.) If you’re logged into an MSU system already, the site should load. Otherwise, it’ll ask you for the MSU netid and password. Once you’re in Gitlab, you should see a short list of files. Clicking on a file will show you the contents of the file. This repository only has two files in it: eliza.py and a file called README.md which says a bit about what’s in the repository. We want to download the eliza.py file. Click on the name of the file, and it should take you to a page where you can view the file. Near the top of the contents, there is a download link that looks like the bottom half of a box with a down arrow going into it. Click that, and download the file. It will either automatically go to the Downloads folder on your computer, or it will ask you where you want to download it to. Find the program using command line . Next, we want to run the file from the command line. Open up PowerShell (in Windows) or Terminal (in Mac OS). The most important thing to remember about command line is that it only will let you do things with files if it thinks it’s in the same location the file is. That means it has to be in the Downloads folder to interact with any of the files in Downloads. PowerShell will show you the directory tree you’re in, while Terminal will only show you your current folder. By default, both PowerShell and Terminal start in the top level Users/username directory when you open it up. Other directories like Desktop and Downloads are nested directly under the Users directory. The first thing we need to do is to change the current directory to the one where the file was downloaded. If you sent eliza.py to the Downloads folder, use the command cd downloads. cd is short for “change directory”. If that command works, it won’t print anything out; instead it will just give you a new prompt which will show you you’ve moved into that folder. On Windows, this looks like: . PS C:\\Users\\geier\\downloads&gt; . On Mac, it looks like: . geier-Macbook-Pro:Downloads geier$ . See how “downloads” is now in the prompt? You can always see where you are in the folder structure on your computer by looking at the command line prompt. You can go to different places on your computer, too. For example, if you created an “MI 250” folder on your desktop and saved eliza.py in there, you can get to your MI 250 folder in command line with this command: . cd desktop/\"MI 250\" . Note that whenever you have spaces in the name of a folder, you need to put quote marks (“”) around it when you navigate to it in command line. Once you think you’re in the right folder on command line, run the command ls. This will give you a list of files in that folder. Make sure eliza.py is in that list. If it is, you can run it! . Command line reference . There’s also a neat trick that works in both Windows and Mac OS to get to the folder you want to go to. | Type cd in command line - make sure there is a space after cd. | Open up the folder you want in File Explorer (Windows) or Finder (Mac OS) – the normal way of viewing folders. | Drag the folder over to the command line window. When you release your mouse on top of the command line window, that should put the full directory name after cd. | . A couple of other useful command line commands: . | You can get a list of the files in the current directory with the ls command | You can move up one directory (to the parent directory) with the command cd .. | If you start typing the name of a file or directory, you can it the Tab key and it will try to automatically finish typing the name of that file/directory for you. | When the space next to the prompt is empty (you haven’t typed anything yet), you can hit the “up” arrow on your keyboard - this will autopopulate the last command that was given. | . There’s more useful command line stuff in the Reference section on this site. Run the program . Once you are in the right directory, try to run the Eliza program you downloaded: . python eliza.py . If you’re on a Mac, remember to use python3! . The program should begin talking to you, and ask you for information about yourself. Play around with it, and answer some questions. Notice how it responds, and when it says the same things and when it says different things. When you are done, type “goodbye” to exit the program. Congrats! You have run your first python program by hand on the command line! Good work. We will be doing this many times over the course of the semester, but in the future it will mostly be programs that YOU write that you will be running. ",
    "url": "/labs/installing_python.html#run-your-first-program",
    "relUrl": "/labs/installing_python.html#run-your-first-program"
  },"147": {
    "doc": "Lab",
    "title": "Trade places and repeat",
    "content": "Change Drivers: At this point, the driver should have Python installed and running on their computer, and should have been able to run eliza.py. Now the driver and navigator should swap. Go back to the beginning of the Install Python section on this page and re-do these all of the above steps on the new driver’s computer. Make sure that you’ve got python installed correctly on both computers, and that both computers can run eliza.py. Some things will be easier the second time around, and sometimes you will encounter new problems. Work together with your partner to figure out how to get it working. ",
    "url": "/labs/installing_python.html#trade-places-and-repeat",
    "relUrl": "/labs/installing_python.html#trade-places-and-repeat"
  },"148": {
    "doc": "Lab",
    "title": "Edit the program",
    "content": "Congratulations on getting a Python program running on your computer. That is a big accomplishment, and is probably one of the hardest parts of this class. Command line, Python, downloading .py programs – this is all very weird and not the normal way we install or run programs on computers. There is a reason we do it this way – it turns out it will be easier in the future if we do it this way – but it is very weird and takes a while to get used to. That’s OK if it feels weird! It should. For the next step, we are going to edit the program. We are going to add some new features to the program, and then run it again. Install a text editor . To edit the program, the first thing we need it is a text editor. Computer programs are written as plain text files. This means we can’t open them up in Word or Google docs or similar programs. We have to open them in a text editor. There are lots of text editors out there that you can use, and they can get really complicated. The text editor I recommend for this course is: . Visual Studio Code . VS Code works for both MacOS and Windows. It’s entirely free. Here are a couple other free options, if you decide you don’t like VS Code: . | For Mac: BBEdit (free version works fine) | For Windows: Notepad++. | . You are welcome to install any other text editor you like. If you have a text editor that you already use and like, that’s fine, too. Note that Caitlin and Jack both use VS Code and will be able to support you most easily if you use VS Code, too. All of the options above are free to use. There are many others, including some specifically for Python, but not all of them are free and some get very complicated. I encourage you to experiment and find one that YOU like. Programming is a form of art, and each artist has their own preferences for tools. Look at the Eliza program’s code . You downloaded the eliza.py program earlier in this lab. Our next goal is to edit this file. Go to the text editor that you choose, and open the eliza.py file from whatever folder you downloaded it to (probably downloads). First, look over the file. Read what it says. It is weird, and hard to read. The file roughly has three sections. The first section is only 2 lines. It looks like a header (basically, it is). Both lines start with the word import. We’ll learn more about imports later, but they allow the program to access specific functionality. The second section is labeled “list of inputs and possible responses”, and has a bunch of text in quotes. This contains the logic and intelligence for Eliza, our fictional person. The last section calls itself the “code that asks for user input and prints out a response”. This is a series of commands – think of them like the instructions you wrote to make pizzas earlier this week. It prints out information, then asks the user to type something in, and then chooses a response based on what was typed. Right now, the way Eliza works is that the computer looks for specific words in what the user types; words like “hello”, “mother”, or “I feel”, which the program calls prompts. Then, when it sees one of these prompts, it looks at the list of possible responses below the prompt, and picks one randomly to print out. So if the user enters “hello”, then it will randomly pick one of the 3 responses below it and print it out. Make a change to the code . We are going to make a change. We are going to allow Eliza to respond to questions. First, we should check whether she already does that. Run the eliza.py program with the command python eliza.py in command line. Enter a question, complete with a question mark at the end. What happens? She responds, but she doesn’t seem to acknowledge that it was a question. Now, let’s add an ability for her to respond to questions. If you look in the file, you should see code that looks like this: . (\"\", [\"Please tell me more\", \"Can you elaborate on that?\", \"I see\", \"How does that make you feel?\", \"How do you feel when you say that?\" ]), . That is the ‘default’ response; if she doesn’t know what else to say, she says that. Let’s put the question responses just above that. Add a new, blank line right above that. Then paste in this code: . (\"?\", [\"Why do you ask that?\", \"Why don't you tell me?\" ]), . Make sure not to leave out any parentheses (), square brackets [], or commas. Also make sure the indents look like how the next chunk of code is indented. Indents are important in Python. Great! You’ve just made your first changes to a python program. Good work. When you’re done, save the file by going to File -&gt; Save in your text editor. A quicker way to do this is Ctrl+S on Windows or Cmd+S on Macs. Files never save automatically; you have to remember to do it yourself every time. If your changes aren’t saved and you try to run the program, it will run the last saved version. Run again, and see if the changes appear . Now let’s see if your changes work. Go to the command line again, and run eliza.py using the command python eliza.py. Notice that this is how we always run a python program: we go to the command line, type the word python followed by the name of the program file we’ve been editing. (And again, remember to use python3 if you’re on a Mac!) . Eliza should appear again. Start interacting with her. Does she still behave normally? What happens now if you ask her a question? Does she do somethig different than she did before? . If she does, then your changes have worked! If she doesn’t, then go back to the file and try again. Make sure you saved the latest version, and take a look at the punctuation and indents in the code you added. Don’t worry (yet) about how that code works, or what exactly it does. We will learn that throughout the semester. By the end of the semester – actually, about half way through the semester – you should be able to read and understand (and possibly write) this program yourself. But for now, if you don’t understand it, that’s normal and OK. The important part is figuring out how to edit files in a text editor, and then run them on the command line. Take a screenshot . Once you’ve got the changes you made to eliza.py working, take a take a screen shot of Eliza working on your computer – preferably showing some of the new responses you’ve added – and submit it on D2L. The easiest way to do this is to put the window with your code editor and the window for Terminal or PowerShell side by side and take one big screenshot of both windows. ",
    "url": "/labs/installing_python.html#edit-the-program",
    "relUrl": "/labs/installing_python.html#edit-the-program"
  },"149": {
    "doc": "Lab",
    "title": "Trade places and repeat",
    "content": "In normal labs after this week, we won’t be repeating steps on both people’s computers. But for now, we want to make sure that both people’s computers are set up and working with Python correctly. So change drivers again, and go through the steps starting at Install a Text Editor again. Hopefully it will be easier the second time around. ",
    "url": "/labs/installing_python.html#trade-places-and-repeat-1",
    "relUrl": "/labs/installing_python.html#trade-places-and-repeat-1"
  },"150": {
    "doc": "Lab",
    "title": "Extra Challenges",
    "content": "At this point, both you and your partner should have Eliza.py with changes working on both of your computers. Labs every week will have one or more challenges at the end. If you finish all of the main exercises, start working on one of the challenges. If you finish one (or both!) challenges before class ends, let Caitlin or Jack know so we can check your work and answer any questions. Challenge: Other Python programs . Now that you’ve gotten your first Python program running, try to download a few more Python programs and get them running. Be sure to run them using the command line: . | Snowflake – draws a snowflake on the screen. (the “raw” button downloads the file) | Uno – play the card game uno | . Challenge: Add more responses to Eliza . You don’t necessarily understand how Eliza works, yet. You will later in the semester. But still, it is a good exercise to try to add additional responses to Eliza. Try to figure out how she works, and see if you can get her to respond in different ways than she does now. ",
    "url": "/labs/installing_python.html#extra-challenges",
    "relUrl": "/labs/installing_python.html#extra-challenges"
  },"151": {
    "doc": "Lab",
    "title": "Submit your work",
    "content": "When you and your partner are done for the day, submit your work! Today you’ll just need to turn in screenshots of Eliza working in command line and of the changes you made to the code. If you got to the challenges, take screenshots of those working, too. Next week you’ll start turning in your code as well. If you and your partner both finished everything and submitted your work before the end of class, you can leave early! Make sure you check in with Caitlin or Jack first. If you didn’t get everything done today, that’s OK. Sometimes you won’t be able to finish the entire lab, and that’s fine. For today, since we were installing stuff you’ll be using for the rest of the semester, let Caitlin and Jack know if you couldn’t finish the main part of the lab and how far you got. We’ll work with you after class or next week to make sure you have everything working. ",
    "url": "/labs/installing_python.html#submit-your-work",
    "relUrl": "/labs/installing_python.html#submit-your-work"
  },"152": {
    "doc": "Lab",
    "title": "Lab",
    "content": "Today we will start with our first programming lab. We’ll be getting Python set up and getting your computer ready for writing code, then we’ll practice working with code a bit. ",
    "url": "/labs/installing_python.html",
    "relUrl": "/labs/installing_python.html"
  },"153": {
    "doc": "Lab",
    "title": "Exercise 1 - Decide who’s driving and who’s navigating",
    "content": "You’ll be randomly divided into pairs. Find a place to sit where you’re next to your partner. Then decide who will be driving (typing) and who will be navigating (acting as support). Normally you’ll switch places partway through class so you each have a chance to drive and to navigate. This is a short exercise, so you won’t do that today. ",
    "url": "/labs/intro_to_class.html#exercise-1---decide-whos-driving-and-whos-navigating",
    "relUrl": "/labs/intro_to_class.html#exercise-1---decide-whos-driving-and-whos-navigating"
  },"154": {
    "doc": "Lab",
    "title": "Exercise 2 - Write instructions",
    "content": "The main task for today: with your partner, write out instructions for how to make a pizza. The driver will be doing all of the typing; the navigator will help by offering suggestions, looking things up, etc. You can use any resource you have available to you to help. Be as specific as possible! Assume that you’re writing instructions for someone who had never seen or had a pizza before. Also be creative! There are many different ways to make a pizza. ",
    "url": "/labs/intro_to_class.html#exercise-2---write-instructions",
    "relUrl": "/labs/intro_to_class.html#exercise-2---write-instructions"
  },"155": {
    "doc": "Lab",
    "title": "Exercise 3 - Be prepared to share with the class!",
    "content": "We’ll take some time to share our pizza making instructions out loud and see how different they all are. You and your partner don’t have to share, but be prepared to. ",
    "url": "/labs/intro_to_class.html#exercise-3---be-prepared-to-share-with-the-class",
    "relUrl": "/labs/intro_to_class.html#exercise-3---be-prepared-to-share-with-the-class"
  },"156": {
    "doc": "Lab",
    "title": "Exercise 4 - Take screenshots",
    "content": "For every lab and studio you do in this class, you’ll be expected to take screenshots showing the work you did. You’ll submit your screenshots on D2L. We’ll practice that today. Today, everyone will take a screenshot and submit it. The place you’ll turn them in on D2L is under “Assignments” and is called “Screenshot Practice Exercise”. Driver: Submit a screenshot of your written pizza instructions. Navigator: Submit a screenshot of an image of a pizza you’ve found through Google (or your search engine of choice). MacOS and Windows both have built-in applications for taking screenshots. If you need a refresher, here’s a reference for taking screenshots. (For the future, this can be found under “Reference” in the sidebar of this site.) . NOTE This “lab” is for practice and is ungraded! The first graded lab will be on Wednesday. ",
    "url": "/labs/intro_to_class.html#exercise-4---take-screenshots",
    "relUrl": "/labs/intro_to_class.html#exercise-4---take-screenshots"
  },"157": {
    "doc": "Lab",
    "title": "Lab",
    "content": "Today is an introduction to the course and a discussion of what programming is. We’ll do a short “lab” today that will get you familiar with the format for the course. All labs in this class will be done using pair programming. Pair programming is based on the idea of “two programmers, one computer:” two programmers work together on the same code using one computer between them. One person is the driver: they are the person using the computer and typing the code. The other person is the navigator: they do the bigger picture thinking, look up relevant information, and help spot mistakes. In this class, students will switch roles on a regular basis. Students who participate in pair programming get stuck and frustrated less often than students working by themselves and are also able to practice teamwork and communication – which is why we practice it in this class! . ",
    "url": "/labs/intro_to_class.html",
    "relUrl": "/labs/intro_to_class.html"
  },"158": {
    "doc": "Lab",
    "title": "Install PyTest",
    "content": "Today, we will be writing automated software tests. Python comes built-in with a testing framework called unittest, but we aren’t going to use that. We are going to use a much better and easier to use system called PyTest. Before we can use it, we first need to install it. This only needs to be done once. On the command line, run the command . pip3 install pytest . It should download and install the latest version of pytest. Once it is finished, you should get your prompt back at the command line. Next, let’s check and make sure it is installed and working correctly. The fib.py program from the readings is in the git repository for this week. Run this command; it should run the tests and report 4 passes and 4 failures: . pytest fib.py . Note: You’ll need to make sure that fib.py is in the current directory . If it runs the tests (which may take a few seconds), and then prints out that there are 4 passes and 4 failures, then it is working. You can also run pytest fib_improved.py to see all of the tests pass. ",
    "url": "/testing/lab.html#install-pytest",
    "relUrl": "/testing/lab.html#install-pytest"
  },"159": {
    "doc": "Lab",
    "title": "Basic Testing",
    "content": "We are going to practice writing test cases for existing code. I am going to give you pre-written functions, and you will need to write one or more test cases – usually automated test cases – for those. Exercise 1: Basic (Level 0) Test for Cleanup . Let’s start by looking at the file cleanup.py. It contains a function – cleanup() – that takes a string and tries to clean up the langauge by replacing bad words with less bad words. Let’s begin by writing a basic test for this. There is a test function in the file – test_cleanup() – that right now does nothing. Let’s write a test case. In the test, call the cleanup() function, and give it the message “damn this shit to hell” – which of course has a lot of bad words in it. Save the output from the cleanup() function into a variable. Then use assert to check to see if that output has had the bad words replaced – it should now say “darn this poop to hades”. Once you get the test written, run pytest cleanup.py and see if it passes. You should make sure that your test passes correctly before moving on. Exercise 2: Basic (Level 0) Test for First Word . If you look at the file first_word.py, it contains a function called first_word(). This function takes a sentence as a string, and it returns the very first word in the sentence. Let’s write a test for this, to see if it works correctly. The file contains a single test called test_first_word(). Right now that function does nothing, so the test passes. Edit that function to test the first_word() function. Call the function, passing in the sentence “This is a test”. Save what the function returns to a variable. Then check that what the function returns is correct – it is the word “This”. Run your test. It should fail, because the first_word() function is broken. Exercise 3: Fix the bug in first_word . It is returning the wrong word! Fix the function so that your test now passes. Run pytest and verify that your test now passes correctly. ",
    "url": "/testing/lab.html#basic-testing",
    "relUrl": "/testing/lab.html#basic-testing"
  },"160": {
    "doc": "Lab",
    "title": "A Few More Tests",
    "content": "Exercise 4: Testing how to count letters – “HI” . Next, turn your attention to the count_letters.py file. This file counts a count_letters() function that takes a message and counts how many times each letter appears, and returns the dictionary with the letter counts. Write a test for this function that passes in the word “HI” and verifies that the function reports that the word has one “H” and one “I”. You will have to write our own test function for this. Note: You are allowed to have more than one assert in a single test. All asserts must pass for the test to pass. So you can separately check the counts for ‘H’ and ‘I’ are correct. Exercise 5: Test repeats (Level 1 test) . Add a second test to this file that tests repeated letters. Pass in a string that has at least one letter repeated more than once. Then verify that this correctly counts the number of times that letter appears. Exercise 6: Test empty (Level 1 test) . What happens if you pass in the empty string – \"\"? Add a test case that passes the empty string to count_letters() and verifies that it returns a reasonable answer. Exercise 7: Test missing (Level 2 test) . Add one more test case to count_letters.py. Pass in a word to count_letters(). Verify that it correctly counts at least one of the letters. But also pick a letter that is NOT in that word, and verify that that that letter is NOT reported in the dictionary that is returned. By this point, you should have 4 separate tests in count_letters.py that all pass when you run it with pytest. Hint: You can do assert key in dict or assert key not in dict – in general, anything you would use in an if statement, you can also do in an assert. ",
    "url": "/testing/lab.html#a-few-more-tests",
    "relUrl": "/testing/lab.html#a-few-more-tests"
  },"161": {
    "doc": "Lab",
    "title": "Testing Output",
    "content": "Much of the code we’ve written so far in class has been creating output – for example, the print() statements for our choose-your-own adventure program or our conversational agent program. We can test this code by “capturing” the output from the print statements into variables, and then checking whether that output is what we expect it to be. To capture output, we use the capsys functionality of pytest. We add a parameter to our test called capsys, which will cause pytest to capture all print statements. Then we can retrieve that output by saying captured = capsys.readouterr(). THen we can access the actual output with captured.out. He is an example test that just prints the word hello, and verifies tht it prints correctly: . def test_print(capsys): print(\"hello\") captured = capsys.readouterr() assert capured.out == \"hello\" . Exercise 8: 99 bottles . If you look in the file bottles.py you’ll see a function that prints out one verse of the song 99 bottles. Write a function that tests this by picking a verse number (e.g. verse 75), calling the bottles function, capturing the output, and the verifying that the output looks like what it is supposed to look like. Exercise 9: 9 bottles . The bottles function does something different for verses less than 10. Write another test to verify that a verse less than 10 (e.g. 9) prints out the alternate version of the song. ",
    "url": "/testing/lab.html#testing-output",
    "relUrl": "/testing/lab.html#testing-output"
  },"162": {
    "doc": "Lab",
    "title": "Testing Input",
    "content": "We also write a lot of code that gets inputs from users. How do you test that? . The easiest way to test that is to replace the input() function with another function that returns a pre-specified string. This way, when your program calls input(), it won’t actually ask the user; instead, it will just pretend the user typed something in and return what you tell it to. This is called mocking the input. To do that, we use a feature in pytest called monkeypatch. Put one line at the beginning of your test to replace input with whatever you want it to be: . def test_input(monkeypatch): monkeypatch.setattr('builtins.input', lambda x: \"Rick Wash\") name = input(\"What is your name? \") assert name == \"Rick Wash\" . Exercise 10: Test the Flashcard . The file flashcard.py has a function that contains a single flashcard, much like the flashcards you made in week 2 studio. It asks the user a riddle, waits for the user to respond, and then returns either the word “Correct” or “Incorrect” based on what the user entered. Test that this flashcard works correctly. If the user enters “mountain” (the correct answer), then the function should return “Correct”. If the user enters anythign else, it should return “Incorrect”. You will need at least two tests to test this – one that tests a correct answer, and one that tests an incorrect answer. ",
    "url": "/testing/lab.html#testing-input",
    "relUrl": "/testing/lab.html#testing-input"
  },"163": {
    "doc": "Lab",
    "title": "Testing Your Own Code",
    "content": "It is easier to write tests once you have a program working. But which comes first, the test or the program? If you google this question, you’ll get thousands of very long, heated discussions online. This is a subject of much debate among programmers. Still, this is something you will need to deal with. So for this next exercise, you will need to write BOTH the main function code, and the test code. Exercise 11: Nth word . Write a function that extracts the nth word from a sentence. That is, if I give you the sentence “this is a sentence” and ask for the 4th word, it should return “sentence”. If I ask for the 2nd word, it should return “is”. Look at the code in first_word.py as a good place to start. Also, then write one or more tests for your nth word function to verify that it works correctly. It is up to you whether you write the test first, write the main code first, or do them both at the same time. Think about which way makes most sense to you. Do you write the code first, and then test it to make sure it works? OR, do you write the test first, so you know what it needs to do, and then write the code so that it matches what the test says it should do? . Hint: Start by making a list of what kinds of things you can test. Then write your “nth word” function to be easy to test in that way. Focus on Level 0 and Level 1 tests. Try to find ways that the function is supposed to work correctly, and test that it does. ",
    "url": "/testing/lab.html#testing-your-own-code",
    "relUrl": "/testing/lab.html#testing-your-own-code"
  },"164": {
    "doc": "Lab",
    "title": "Manual Test Cases for Turtle Graphics",
    "content": "We’ve now written a lot of automated tests, spread across a bunch of different files. Run the command . pytest bottles.py cleanup.py count_letters.py fib_improved.py first_word.py flashcard.py . It will go through all of the files that have tests in them, and then run ALL of the tests you’ve written. Very hand way to check all of your code. However, there’s one thing we’ve done a lot of in this class that we haven’t written tests for: turtle graphics. It is actually pretty hard to write tests for turtle graphics, because the output is on the screen. Instead, we usually do manual tests for turtle graphics programs. So far, you’ve just run the program over and over and see if you like what is looks like. Let’s be more rigorous than that. Let’s create some very specific manual tests where the program draws something, and then we explicitly write down what we expect it to draw. That way, someone can look at the expected output and decide, for each drawing, whether it “passes” or “fails”. Challenge: Stars . In your folder for this week, there is a star.py program. That program contains a function that draws a star of different sizes and colors. Create 3 manual tests for this star function. One test should be a Level 0 test – give it a reasonable size and color, and see if it works. The other two tests should be Level 1 tests – give it a different size, and a different color, and see if it draws the star appropriately. For each test case, explicilty write down what parameters to give the function, and what you expect the program to draw. They should be paired – so these parameters should draw this output. It is OK to write this on a piece of paper – just take a photo of it with your phone to turn it in. Then modify the program to draw the 3 test cases on the screen. Then run your test manually – look at the output, and decide for yourself whether what it drew matches what you expected it to draw. Write down whether each test cases passes or fails. Challenge: Level 2 tests for nth_word . As a second challenge, try to write one or more tests for your nth_word() function that tests errors – aka Level 2 tests. Think about inputs to your nth_word() function that might be invalid. What happens if someone asks for the 5th word in a sentence that only has 4 words? What happens if someone asks for the ‘a’th word instead of the ‘1’st word? What happens if someone asks for the ‘-1’st word? (is that actually an error?) . In each of those cases, think about what you think should happen, and then write the test to test whether that actually happens or not. If it doesn’t happen, it could be because the function is broken. Or it could be because your understanding is incorrect, and the test is helping you to see what is wrong. ",
    "url": "/testing/lab.html#manual-test-cases-for-turtle-graphics",
    "relUrl": "/testing/lab.html#manual-test-cases-for-turtle-graphics"
  },"165": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/testing/lab.html",
    "relUrl": "/testing/lab.html"
  },"166": {
    "doc": "Lab",
    "title": "Names, names, and more names",
    "content": "Lists are the simplist possible form of what’s known as an array. An array is a data structure that allows you to store lots of different pieces of related data in a single variable. A “list” in Python is exactly like it sounds: a list of different, but related, pieces of data. For example: . groceries = [\"apples\", \"cheese\", \"crackers\"] . The variable groceries is storing a list of different things you might buy at a grocery store. You can have as many (or as few) items in a list as you want. Lists are also mutable, which means you can change the contents on the fly. Lists are always identified by the square brackets ([]) around the contents of the list. Whenever you see square brackets in Python, you can be sure it’s a list (or, more broadly, an array) of some sort. Exercise 1: Add your names to a list . Start by running the program names.py. This prints out a list with the names of the instructor and the course assistant for this class. Add your (the driver’s) name to the end of the list. Run the program and make sure it prints out all 3 names correctly. Exercise 2: Adding another name . You have hard coded another name into the list. However, you can also get Python to add more things to a list that already exists using .append(). For example, look at the groceries list at the very beginning of today’s instructions. Say you want to add “jam” to that list. You can do that like this: . groceries.append(\"jam\") . In names.py, use .append() to add your partner’s (the navigator’s) name to the list. The names list that prints out should have 4 names in it now. Exercise 3: Add name with input . Now, go back to names.py. Modify your program to ask the user for another name with input(). Then .append() that name to your list, and print out the full list. It should have 5 names in it when you’re done. Hint: You’ll want to store the user input into a variable first before you append it to the list. As an example, if “jam” were stored in a variable called new_grocery_item, you could also append it to the groceries list using the variable: . new_grocery_item = \"jam\" groceries.append(new_grocery_item) . Exercise 4: Print nicely . Right now, your print() statement prints out the list as Python code. Let’s make it more human readable. We worked with for loops a couple weeks ago. For loops and lists are made for each other - you can use a for loop to easily go through each item in a list one by one. Let’s go back to our groceries example: . for item in groceries: print(item) . In the above code, the for loop goes through each item in the groceries list one by one. print(item) prints the next item in the list every time the loop is run. When it prints, it looks like this: . apples cheese crackers . Use a for loop to print out each name in your names list one by one. Exercise 5: Alphabetical order . The function .sort() will sort any list you have. If the list is made up of numbers, it will sort from lowest to highest. If the list is made up of words, it will sorts things alphabetically, with words that are capitalized coming before words that are lowercase. So if you have a variable groceries that contains a list, then you can say groceries.sort() to sort that list into alphabetical order. Modify names.py to sort the names, and print out the list of names in alphabetical order by first name. Test your program by entering in different names, and seeing if it sorts them differently. Exercise 6: Beginning of the Alphabet . With lists, you can also retrieve specific items using square brackets ([]) next to the name of the list. So, to get the 2nd item from the list stuff, you can say stuff[1]. The number in the square brackets is called the list index. Modify your program to print out only one name: the name that comes first in alphabetical order. Hint: the list index in Python always start at 0, so 0 is the index for the first item, 1 is the second, and so on. Exercise 7: End of the Alphabet . The folks who have last names that start near the end of the alphabet always end up waiting longer. So let’s show some love to the end of the alphabet. Change your program so it prints out the person’s name who appears last in alphabetical order. Hint: There are two ways to do this: the first is to find out how long the list is and call the last item in it, and the second is to sort the list in reverse alphabetical order to call the first item. Refer to this week’s readings for help with the second option. Google will likely be helpful, too! . ",
    "url": "/labs/lists.html#names-names-and-more-names",
    "relUrl": "/labs/lists.html#names-names-and-more-names"
  },"167": {
    "doc": "Lab",
    "title": "Flipping Coins",
    "content": "Next, we are going to use the random library to build a couple of useful tools to help us make choices. As a reminder, before you can use the random library, you need to add import random at the beginning of your program. Exercise 8: Heads or tails . Open up coin.py. This program is supposed to flip a coin - but the program isn’t finished yet. Right now it just generates a random number between 1 and 2, stores it in the variable num, and prints out the number it generates. Run it to see how it works - the number it prints should change if you run it enough times. Modify the program so it prints out “Heads” if num is 1, and “Tails” if num is 2 (or if it isn’t 1). Exercise 9: Coin flipper bias . The coin.py program flips a single coin and prints out either heads or tails. Let’s test to see if this program is biased. Modify the program to flip the coin 20 times and print out the results of each flip. Hint: You will need to use a loop for this. Look back at the lab on loops for help. Exercise 10: Coin flipper counter . Modify your coin flipping program to count how many times heads comes up, and the same for tails. At the end of the program, it should print out the counts – how many heads came up, and how many tails came up. Hint: You can use a counter to do this (which is sometimes known as an “accumulator”). You create a variable, and then set it to zero as a place to start. Then, each time through a loop, you add 1 to it. It looks something like this: . counter = 0 while looping: counter = counter + 1 print(counter) . You can also write it as counter += 1, which is shorter and does the same thing as counter = counter + 1. Hint 2: you’ll likely need two counters: one for heads, and one for tails. Where should the counter for tails go in the code if you only want it to go up whenever the coin is tails? . Exercise 11: Coin flipper user input . Modify the program to ask the user how many times it should flip the coin. Then have the program flip a coin that many times, and count the number of heads and the number of tails. At the end of the program, it should print out the counts – how many heads came up, and how many tails came up. Hint: Remember the difference between strings and integers. When a user enters a response to input(), it is stored as a string. If you want to use it as a number, you need to convert it to one using int(). ",
    "url": "/labs/lists.html#flipping-coins",
    "relUrl": "/labs/lists.html#flipping-coins"
  },"168": {
    "doc": "Lab",
    "title": "Choosing a restaurant",
    "content": "It is always difficult to choose where to go for lunch when you are with a bunch of friends. We are going to build a restaurant choosing program to help with the choice. Let’s start by looking at restaurant.py and running it. It should ask the user for 3 restaurants and then print out the list of restaurants. Exercise 12: User experience of counting . Python counts starting at zero: 0, 1, 2, 3, etc. Regular human beings, on the other hand, start counting at 1: 1, 2, 3, 4, etc. Right now, the program asks for “restaurant 0” first. Modify the program so that it looks like human beings would expect, starting with 1. Hint: the program should still ask for 3 restaurants. Hint 2: Note where i is being used inside the for loop. In for i in range(3), i is a variable that changes value each time the loop is run. Because range(3) is an integer in this for loop, i is also an integer (which means you can do math to it!). Exercise 13: Random Choice . The function random.choice() will pick a random item out of a list and return that item. So if you have a list of groceries, you can say random.choice(groceries) to get a random thing out of that list. Modify the restaurant program to use this to randomly choose a restaurant for lunch. Then print out which restaurant the computer chose. Note: Remember to import the random library (import random) at the beginning of your program. Exercise 14: More (or less) than 3 . This is where lists really shine. Lists are great because you don’t have to know ahead of time how many items are going to be in the list. They get bigger or smaller as needed. Right now, the restaurant.py program always asks for exactly 3 restaurants. In programmer terminology, we say that “3” is “hard-coded” into the program. Modify the program to ask the user how many restaurants they are thinking about for lunch, and then have it ask them for that many restaurant names, and then pick a random restaurant from that list. So if they say they are thinking about 5 restaurants, your program should ask them for 5 names of restaurants, and then pick from among those 5. If they say 2, it should only ask them for 2 restaurant names. Here is a potential use of the program: . How many places are you thinking about for lunch? 4 Enter the name of restuarant 1: Jimmy Johns Enter the name of restuarant 2: Chipotle Enter the name of restuarant 3: Five Guys Enter the name of restuarant 4: Noodles and co. You should go to Noodles and co. Hint: Remember the difference between strings and integers. When a user enters a response to input(), it is stored as a string. If you want to use it as a number, you need to convert it to one using int(). Hint 2: Notice that I made the program a little more user friendly by printing out the words “You should go to” in addition to the final choice. It is always a good idea to try to make things easier for your users to use and understand. ",
    "url": "/labs/lists.html#choosing-a-restaurant",
    "relUrl": "/labs/lists.html#choosing-a-restaurant"
  },"169": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you finish with the exercises above, try at least one of the challenges below. The challenges are starting to give a little less direction - as you get further into programming, you get fewer and fewer directions for how to do things, and have to do more work to figure it out yourself. Challenge 1: Unlimited Restaurant Options . Modify the restaurant.py program so that it doesn’t need to ask ahead of time for the number of restaurants. The user should be able to just keep entering restaurants until they type “done” or just hit enter or something. Then it will randomly choose one of the ones they entered and print it. The program should still accept as many restaurants as they want. Here is an example output: . Enter the name of a restuarant: Culvers Enter the name of a restuarant: Chipotle Enter the name of a restuarant: Jimmy Johns Enter the name of a restuarant: No Thai! Enter the name of a restuarant: Potbellys Enter the name of a restuarant: You should go to No Thai! . Hint: while True: will loop forever. You can break out of a loop with the break command. An elegant way to break out of a loop with user input is to only have the break command run if the user enters a specific word, like “quit”. Challenge 2: Infinite coin flipper . Make a copy of your coin program and call it infinite.py. Modify the program so that it keeps flipping coins as long as the user wants it to. It should flip a coin, and then ask the user if it should continue. If the user says “yes”, it should go and flip another coin, and then ask the user again. It should keep doing that until the user says “no”. As a bonus, have the program print out the percent of coin flips that have come up “heads”. To get this, you can divide the number of “heads” by the total number of coin flips (heads + tails), then multiply the result by 100. Don’t forget to add this program to your Git repository. Hint: while True: will loop forever. You can break out of a loop with the break command. An elegant way to break out of a loop with user input is to only have the break command run if the user enters a specific word, like “quit”. Heads Should I continue? yes You have flipped 1 coins 1 have come up Heads Which is 100% Tails Should I continue? yes You have flipped 2 coins 1 have come up Heads Which is 50% Heads Should I continue? yes You have flipped 3 coins 2 have come up Heads Which is 66.66666666666666% Heads Should I continue? yes You have flipped 4 coins 3 have come up Heads Which is 75% Tails Should I continue? no . Challenge 3: Song list randomizer . Start a new program called songs.py that asks the user for several songs they want to listen to, then present the list of songs in a random order. Your program should print out the list of songs in a human readable format. Don’t forget to add this program to your Git repository. Hint: random.shuffle(list) will randomly re-order a list. Picture in your head putting each item in your list on a separate index card, and then shuffling the deck of index cards. Hint 2: you can ask the user how many songs they want in the list ahead of time, OR you can let them keep adding songs until their song list is complete. If you do the second option, you could use a while loop. ",
    "url": "/labs/lists.html#challenges",
    "relUrl": "/labs/lists.html#challenges"
  },"170": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/labs/lists.html",
    "relUrl": "/labs/lists.html"
  },"171": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Lists . | Automate the Boring Stuff: Chapter 4 - Lists | How to Think Like a Computer Scientist: Lists | Learn Python: Lists - practice. | . Randomness . | Random Numbers in Python - this reading might look familiar. Does it make more sense this time around? | The Random Module | . ",
    "url": "/readings/lists_and_randomness.html#readings",
    "relUrl": "/readings/lists_and_randomness.html#readings"
  },"172": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For the summary this week, think about what we’ve done in class already. Summary prompt: Summarize your thoughts about lists, and about using randomness with lists. Focus on ways they would make what we’ve already done in class easier (or harder?). ",
    "url": "/readings/lists_and_randomness.html#summary",
    "relUrl": "/readings/lists_and_randomness.html#summary"
  },"173": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Monday. ",
    "url": "/readings/lists_and_randomness.html#question",
    "relUrl": "/readings/lists_and_randomness.html#question"
  },"174": {
    "doc": "Readings",
    "title": "Readings",
    "content": "This week we’re learning about lists and revisiting the random module, which we started using a couple weeks ago. ",
    "url": "/readings/lists_and_randomness.html",
    "relUrl": "/readings/lists_and_randomness.html"
  },"175": {
    "doc": "Readings",
    "title": "Readings",
    "content": "The readings for this week cover three topics. First, we will learn a bit more about strings and about the print() function, which outputs strings. We’ve been using both in class already. Second, we’ll learn about two kinds of loops – while loops and for loops. And third, we’ll learn a bit about using random numbers in Python. Strings and Print() . | Automate the Boring Stuff, Chapter 6: Manipulating Strings – Stop reading at “Project: Password Locker” | The print() function in Python – Stop reading at “Printing Custom Data Types” | . Loops . | Loops in Python | Learn Python: Loops - practice. Note the exercise at the end uses lists, which we won’t cover in class for a couple weeks. | . Randomness . | Random Numbers in Python | . ",
    "url": "/readings/loops.html",
    "relUrl": "/readings/loops.html"
  },"176": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For the summary this week, focus on loops and randomness. Think about similar things you have encountered before. Summary prompt: How would you describe loops and randomness in your own words, and what do you think each thing might be used for in programs? . ",
    "url": "/readings/loops.html#summary",
    "relUrl": "/readings/loops.html#summary"
  },"177": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Monday. ",
    "url": "/readings/loops.html#question",
    "relUrl": "/readings/loops.html#question"
  },"178": {
    "doc": "Lab",
    "title": "Lab",
    "content": "Today is Martin Luther King Jr. day; there is no class today. MSU hosts a number of events to commemorate MLK Jr. Day - events for 2024. ",
    "url": "/labs/mlk.html",
    "relUrl": "/labs/mlk.html"
  },"179": {
    "doc": "Readings",
    "title": "Readings",
    "content": ". | Working with Modules in Python | Python Modules and Packages – An Introduction – stop at Python Packages | . ",
    "url": "/readings/modules.html#readings",
    "relUrl": "/readings/modules.html#readings"
  },"180": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For the summary this week, think about past programs you’ve written and how those programs have been organized. Also think about how you’ve written programs in studios, where multiple people were working on different pieces of the same program. How might using modules have helped? . Summary prompt: Think about and describe a strategy for deciding when to break up a program into multiple files, and how to decide what goes in which file. ",
    "url": "/readings/modules.html#summary",
    "relUrl": "/readings/modules.html#summary"
  },"181": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes. NOTE: Because of fall break, there is no class on Tuesday. We will have a lab on Thursday. You have until Thursday to submit your summary+question this week. ",
    "url": "/readings/modules.html#question",
    "relUrl": "/readings/modules.html#question"
  },"182": {
    "doc": "Readings",
    "title": "Readings",
    "content": "This week we’re looking at modules, which is another way to organize a Python program. In the ‘real world’, programs often consist of multiple files which work with one another. Some programs might have dozens or even hundreds of source files, all of which have code in them. The more complex a program is the longer the code will be. Breaking up a program into multiple files is a way to keep things more organized, and to make collaborating easier. We’ve already been using modules - every time you use import, you’re using a module for Python that someone else has written, like random or turtle. Those modules contain functions that you can use in your program. This week you’ll get to write your own modules. ",
    "url": "/readings/modules.html",
    "relUrl": "/readings/modules.html"
  },"183": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. Finish the Lab . If you didn’t finish this week’s lab, you should make sure that at least one person in your group finished through Exercise 11 – getting TMDB API access working. If not, go back and do Exercise 11, and possibly also all of the exercises after that. Specifically, you should make sure that you can retrieve and print out movie information from TMDB first. If not everyone in your group finished the lab, ask the student(s) who got the furthest to show the code from the lab to the others in your group and explain how it works. That will help everyone be on the same page as you work on the studio today. Reuse Code . For Studio 12, you wrote code to create a word cloud from a file. This studio is similar, but instead of pulling text data from a file, you’ll be pulling it from a server using an API. Try to see if you can reuse any of the code you wrote for that studio. The studio instructions for Week 12 also have some good examples of what a word cloud can look like. How much data do you need? . Think about how much data do you need to draw your word cloud? Only getting 1 actor probably isn’t enough to be meaningful. Getting 1000 actors seems like a lot. How much data do you want to use? You might want to limit the size of your cloud. Visual Size . You can do things to make your visualization more interesting. For example, TMDB has a “popularity” score for each actor that indicates how popular she/he is. You could sort the list by popularity, and/or draw more popular actors in a larger font. Variation: Actor Cloud . Rather than just displaying a word cloud for a movie, can you make a version that takes an actor’s name, and displays his/her movies? Each movie has a popularity score also that you could sort by or use to control the font size. Movies also have budget information, so you could make movies with bigger budgets have a larger font? Be creative. Improve the wordcloud and the layout . You made word clouds last week also. You can and should definitely re-use that code for this week’s studio. But think about how you can make it better. Can you make the layout of the words on the screen better? . You’ve got a movie that you are representing visually. Another way of thinking of the “movie cloud” is as a text-based movie poster. Have your program draw a poster-like representation of the movie on the screen with Turtle. Does that shift in mindset give you ideas for how it might look? . Draw first before adding user input . Make sure your program can draw a nice looking cloud first before adding the feature that allows the user to specify which movie they want the cloud to be drawn for. That is, hard code a movie into your program and make sure it works with that movie before trying it with different movies. If you’re in a group of 3-4, it might make sense for 1-2 people to work on the user input portion while the others work on drawing the cloud . ",
    "url": "/studios/movie_cloud.html#advice",
    "relUrl": "/studios/movie_cloud.html#advice"
  },"184": {
    "doc": "Studio",
    "title": "Studio",
    "content": "For this studio, you should write a program that creates a Movie Cloud. A movie cloud is a word cloud, but about a movie. Your program should ask the user for the name of a movie. Then it should search that movie in The Movie Database, and get the list of actors in the movie. Using Turtle, it should draw the the name of the movie in big letters, and then should draw the actors’ names in a word cloud of some sort. Work in groups of 2-4, as per usual. ",
    "url": "/studios/movie_cloud.html",
    "relUrl": "/studios/movie_cloud.html"
  },"185": {
    "doc": "Lab",
    "title": "Functions and modules",
    "content": "Modules are a way to separate different parts of code into different files so that the code is more organized and easier to read. We’ve been using modules all semester - random is a module, as is turtle. These modules contain functions that you can import into your program so that you can use them. Exercise 1: Separating functions from running code . Open up cards.py. You may recognize this program - we used it in the functions lab a couple weeks ago. Right now everything is in one program, and the program is over 100 lines long. Most of the code consists of the functions that create the different playing card symbols; there are only a few lines of code at the bottom of the program that actually run when you run the program. Modules allow you to separate the code that is actually running from the functions that define how the code will be run. Create a new file called card_functions.py. Move all four of the functions that define how the card symbols should be drawn into this new file. Make sure to include from turtle import * at the top of card_functions.py. Now cards.py should only have a few lines of code left it in. We’ll need to add one more line of code to cards.py - the command that imports the card functions from card_functions.py. There are two ways to import functions from another file: we’ve been using both methods. import random random.randint() . This method imports functions from the random module. In order to use functions like randint() and choice(), you need to put random. in front of them. The other method is the one we’ve been using to import Turtle functions: . from turtle import * forward(10) . This method imports all of the functions from the turtle module so that they can be used ‘natively’ inside a program. That means you don’t have to add turtle. in front of every Turtle function you want to use. Use one of the above methods to import the card functions in card_functions.py into card.py. The name of the module you import is the same as the name of the file (for this exercise, you’ll be importing card_functions). Note: It’s best practice in Python (and many other programming languages) to separate words in the names of variables, functions, files, or anything else you’re naming with underscores: _. Python sometimes has trouble with hyphens (-) because they’re used for math (minus sign), but never has trouble with underscores. Exercise 2: Add another function . Right now the program draws a spade, then moves, then draws a heart, then moves, etc. The code that moves the turtle in between each symbol is repetitive, though. Make a new function called move_next() that moves the turtle in between each symbol and replace the repetitive code with calls to the function. Put this function in the card_functions.py file. The program should run in exactly the same way as it did before, but cards.py should be shorter. ",
    "url": "/labs/organizing_your_program.html#functions-and-modules",
    "relUrl": "/labs/organizing_your_program.html#functions-and-modules"
  },"186": {
    "doc": "Lab",
    "title": "Organizing and Refactoring Code",
    "content": "As you begin to write longer and more complex programs, it becomes more important to stay organized as you work. Earlier in the semester, you would put all of the code in one file, with no line breaks or other ways of organizing the code. Today, we are going to practice a few skills that will make it easier to stay organized. One method is called refactoring - this is when you edit code you’ve already written to make work better, make it cleaner, or make it more efficient. In professional programming, it’s very, very common to spend time refactoring code on a regular basis. Exercise 3: Read and comment . Run the program flag.py in this week’s git repository. It should draw something that resembles a US flag. The program is over 250 lines long! And there is a LOT of repetition in that program. We can better organize our code in a way that will make it easier to read, shorter, and work better. The first step is to figure out what the code is doing. Start by reading the code in flag.py. Think about what it does. As you read it, you’ll find yourself mentally organizing the code in your head – “OK so this part draws the first red stripe. Then this part moves the turtle down to the next stripe.” and so on. Pay attention to that. The logical sections that appear in your head should become sections or functions in the code. As you read through the code and figure out what each section of it does, write comments describing each code section. In Python, commented lines start with #. I’ve added a few comments at the beginning of the program as an example. Exercise 4: Red stripes . Now that you’ve commented the code, you’ll notice that you probably used the same comments multiple times. When a chunk of code does the same thing as another chunk of code, that’s a good time to use a function. Take the code for the red stripe, and put it into a function called red_stripe(). Now go through the code, and every time it draws a red stripe, replace the the code with a call to the red_stripe() function. That is, delete the extra copies of the current code that draws a red stripe, and replace it with a call to your res_stripe() funtion. There are 7 red stripes in the US flag, so there should be 7 calls to red_stripe() in the program when you’re done. Exercise 5: Move Next . Next, look at the 2nd block of code. It moves the turtle to be ready to draw the next stripe. Put that code into a move_next() function. Go through the code and every time it tries to move the turtle for the next stripe, replace it with move_next(). Since there are 13 stripes in the flag, there should be 13 calls to move_next(). When you run the program, it should still draw exactly the same flag as it did when you began. But the program should be much shorter now. Exercise 6: Generalize to stripe() . The first exercise involved copy-and-pasting code into functions, and then calling those functions. This is a really common part of refactoring, and it is important. Just giving sections of code a name can make the code easier to read and understand. But once you give it a name, you often realize that it can do more than just one thing. We only replaced the red stripes. The program also draws white stripes, with almost exactly the same code. For this exercise, change the red_stripe() function to just be stripe(), and add a parameter called bar_color that allows you to specify what color you want the stripe to be. That is, you should be able to say stripe(\"red\") or stripe(\"white\") to get either a red stripe or a white stripe. Now, see if you can replace more of the code with this stripe() function. You should be able to replace all of the code that draws all 13 stripes with calls to the stripe(). When you run the program, it should still draw exactly the same flag as it did when you began. Hint: Remember parameters are variables specific a function that act as placeholders, and then are filled in with whatever is in the paratheses when the function is called. So bar_color in the function’s code would be replaced with \"white\" or \"red\" when the function is called. If you need a refresher on parameters, go back to the drawing with functions lab. Exercise 7: Generalize to colored_rectangle() . OK, we’ve done a good job of making our program much, much shorter. It is also easier to read and understand now. Let’s keep going. We’ve got a bunch of code that draws a blue box on top of our red-and-white stripes. We could copy-and-paste this code into a blue_box() function. But, looking at the code, it looks surprisingly similar to the code for the stripes we had before, doesn’t it? . Let’s see if we can add some more parameters to our stripe() function to allow us to draw a blue box. We already can specify the color of the box. But right now, stripe() always draws a rectangle that is 300 by 10. Let’s add some more parameters to our stripe() function to specify how wide and how tall the rectangle should be. ALso, since we are logically changing what this function does, we should also rename the function to better reflect what it does. How does the name colored_rectangle() sound? So, we could call colored_rectangle(\"red\", 300, 10) to draw a red stripe, and colored_rectangle(\"blue\", 100, 70) to draw the blue box. Modify the flag code to make this happen. You’ll need to change all of the calls to stripe() so that they call the new function instead and use the extra parameters for width and height. When you run the program, it should still draw exactly the same flag as it did when you began. Exercise 8: Moving functions to a module . If you look at your code now, it is really in two parts. First, there are a couple of helper functions – colored_rectangle() and move_next(). And second, there is the main code that calls these functions and creates the actual drawing. Create a new file called flag_functions.py and move these two functions into that new file. Remember to add from turtle import * at the top of the flag_functions.py file. Then add a new import statement at the top of flag.py to import flag_functions. When you run the program, it should still draw exactly the same flag as it always did, but now it should be much easier to read and modify the program. Hint: Remember if you decide to use import functions instead of from functions import * you’ll need to refer to the module when you call each function in it, like functions.move_next(). Exercise 9: Add a star . Write a function to draw a single white star, and draw it on top of the blue box in the flag. But keep your code organized! The function that draws the star shoud go into your functions file (flag_functions.py), and the code that actually moves the turtle and creates the star should go in the main program file (flag.py). Hint: if you can’t remember how to draw a star, go back to the code you wrote for the functions lab. ",
    "url": "/labs/organizing_your_program.html#organizing-and-refactoring-code",
    "relUrl": "/labs/organizing_your_program.html#organizing-and-refactoring-code"
  },"187": {
    "doc": "Lab",
    "title": "Separating Logic and Content",
    "content": "Next, turn your attention to the program flashcards.py. Run that program. It should prompt you to name the capitols for a series of U.S. states. After each prompt, it will tell you if you got it right or not. Let’s refactor this program. Note that not only is it repetitive, but it also has a lot of hardcoded content - that is, it only tests you on the same four state capitols every time you run it. We’ll try to make the program not only more effecient, but also easier to use with different types of content. Exercise 10: Write a flashcard function . Each of the flashcards has a set of code that displays a prompt and then checks what the user inputs against a correct answer. The only thing that varies for each flashcard is the prompt and the expected answer. This is the content of the program; everything else is the logic. Let’s refactor this code into a flashcard() function. The function can accept two parameters – the prompt and an expected answer. Move code for displaying a question, getting the answer from the user, and then checking to see if it is correct or not into the function. Then modify the main part of the program to call the flashcard function 4 times and to ask the same 4 questions as it currently does. When you run the flashcard program, it should look the same to the user as it currently does. Exercise 11: Moving the content into a dictionary . Right now, the content of the flashcards – the prompts and answers – is hardcoded and is mixed with the logic of the flashcard program. The logic controls what order the flashcards should be displayed, when the user should be asked for an answer, what counts as a correct answer, etc. Mixing the content of the flashcards with the logic of the program makes it hard to update either. If you want to add new flashcards, you have to understand how the program works to know what to change. If you want to change how the program works, you have to work around all of the content of the flashcards in doing so. Let’s try to separate the logic of the program from the content in the program. Let’s put all of the content in a single dictionary, where each key is a prompt for the user, and the value associated with that key is the expected answer. This dictionary should be hard-coded at the top of the file, and will contain the same 4 prompts and answers that we asked before. Remember that you can hard-code dictionaries in two different ways: . cards = {} cards['Wyoming'] = 'Cheyenne' ... OR . cards = { 'Wyoming': 'Cheyenne', ... } . Once we have the content of the flashcards in a dictionary (which I called cards), then we can use a for loop to go through the dictionary to display the flashcards using a structure like this: . for prompt, answer in cards.items(): flashcard(prompt, answer) . Run the program to make sure it’s pulling content from the dictionary. Your program should no longer have any repetitive code in it at this point. Exercise 12: Fix the formatting . When you run the program, it should do basically the same thing as before – give you instructions, then start naming states and expecting the user to type in each state’s capitol. Except you may notice that what prints out in the terminal is not as nicely formatted as it was before. It looks like Montanahelena once the user types in an answer instead of Montana: Helena like it did before. Let’s add back the colon (:) and extra space to the prompt so it looks more user friendly. Hint: Inside an input() statement you can’t use commas like in print(), but you can use + to combine strings together. Using + means you need to add spaces into the string manually, though. user_entry = input(answer + \" is correct\") prints out in the terminal as Helena is correct, where answer = Helena. Exercise 13: Add more content . Now if you want to add a new flashcard, you shouldn’t have to change anything except the dictionary. Try this: add two additional flashcards about states and capitols to the dictionary, run the program, and verify that you can add new flashcard content without changing the main code. There’s a text file in the Gitlab repo called capitols-all.txt with all of the U.S. states and their capitols in it, for reference. Exercise 14: Moving the content into a separate file . So far we’ve only used modules with functions. But modules can also be used to store content. Create a new file called capitols.py and move the dictionary into it. The instructions variable also contains content that is specific to this set of flashcards: move that variable into capitols.py as well. Then import capitols into flashcards.py so that you can continue to use the content. Hint: We’ve covered two ways to import things from another file: from filename import * imports everything from that file so it can be used natively, and import filename expects that you refer to the module whenever you call a function from it (like filename.function()). Use whichever method makes the most sense to you. Exercise 15: Put helper functions in a separate file . Now that we’ve taken the content out, the flashcards.py program should contain two parts: a helper function that makes the flashcard work and the main part that loops through the dictionary to display flashcards. Let’s organize the code the same way we did above. Put the helper function into a separate file called flashcard_functions.py. Then import the functions into the main flashcards.py file. Your flashcard program should now have two import statements, and should only contain a few lines of code: a print statement that prints out the instructions, and the loop that goes through the dictionary. Exercise 16: Create a new set of sports flashcards . For the next exercise, let’s see how easy it is to use a different set of flashcards with the program. Create a new file called players.py and add instructions and a dictionary with the same prompt: answer format as the dictionary you created to store states and capitols. This set of flashcards should give the user a player’s name and prompt them to say what team the player plays for. The format of this new file should look very similar to capitols.py. I’d even recommend using the same variable names for the instructions and the dictionary. Only the content – the actual text of the instructions and the contents of the dictionary – should be different. Now instead of importing capitols into flashcards.py, import players instead. If you’ve set it up correctly, when you run flashcards.py it should now be asking sports questions instead of questions about state capitols. ",
    "url": "/labs/organizing_your_program.html#separating-logic-and-content",
    "relUrl": "/labs/organizing_your_program.html#separating-logic-and-content"
  },"188": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you finish all of the exercises above before the end of class, try at least one of the challenges below. Challenge 1: Draw a different flag with the flag functions . Your flag functions file contains a generalized functions for making a stripe, and more specific functions for making a star and moving the turtle to the next stripe. Create a new program and import the flag functions into it, then use those functions to draw the flag for Myanmar. You’ll likely need to generalize both your move_next() function (perhaps add a parameter to specify how far the turtle should move between stripes) and the star() function (add a parameter for size). Challenge 2: Randomize the order of the flashcards . Now that we’ve separated the content from the program logic, it is also easier to make changes to the program logic. Modify your program to randomize the order that it asks users the flashcards. Verify that it works with both the capitols and the sports content. Hint: cards.keys() will give you a list of all of the prompts – that is, it will convert all of the keys in the dictionary into a list. Once you have a list, you can use random.shuffle() on that list to reorder that list into a random order. You can then use a for loop to loop through that new order of prompts. Given a prompt, you can use cards[prompt] to figure out the expected answer. Challenge 3: Count the number of correct flashcards . Add functionality to flashcards.py so that it prints out how many flashcards the user got correct at the end of the program. You’ll need to modify the flashcard() function so that it uses return to return information about whether the answer was correct or not. One way to do this is to have the function return 1 for every correct answer and 0 for every incorrect answer, and then add the number it returns to an incrementing counter. As a very simple example, if flashcard() returns 1, then: . count_correct = 0 count_correct += flashcard() # first flashcard count_correct += flashcard() # second flashcard print(count_correct) . If the user answer both flashcards correctly, and flashcard() returns 1 each time, the print statement will print 2. Hint: you can use len(cards) to get the total number of entries in a dictionary. ",
    "url": "/labs/organizing_your_program.html#challenges",
    "relUrl": "/labs/organizing_your_program.html#challenges"
  },"189": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/labs/organizing_your_program.html",
    "relUrl": "/labs/organizing_your_program.html"
  },"190": {
    "doc": "Lab",
    "title": "Code Reading",
    "content": "For each of the following exercises, your goals is not to write code. It is to read the code and write comments describing what the code does. You should not need to modify the code at all. Instead, you will need to read through the code and figure out what it does. You will use a timer for these exercises: each exercise will ask you to set a time, and then you have that amount of time to try and figure out what the code does before you actually run the program. Only after your timer goes off can you run the code to see what it does. I recommend setting a timer on your phone, or typing “Timer” into Google and use the built-in Google time that comes up. As you work, think out loud. You are working with a partner. Think out loud, and work with your partner to try to figure out what the program is doing. You should be spending a LOT of time talking to each other during this lab. One person (the ‘driver’) should pull up the code on their computer, and then both of you can talk about what it is doing and how it is doing it. As you figure out what the code does, you will need to add comments to the code that describe what is happening. As a reminder, if you put a # symbol in the code, python ignores everything that comes after that symbol (which we call a ‘comment’). For each line of code, or each small chunk of code, add a comment to that explains what the code is doing. Do this for every piece of code in the program. When you are done commenting all of the code, make sure to add a “purpose” statement at the top of the program to describe what the program is doing as a whole. As an example: . # Purpose: this program keeps asking the user if they want to stop, and stops when they say so while True: # Keep looping forever, until \"break\" answer = input(\"Do you want to stop? \") # Ask the user if they want to stop, and store the result in the variable answer if answer == \"yes\": # Check if what the user typed in is the word \"yes\", all lowercase break # if it is \"yes\", then break out of the while loop print(\"Done looping!\") # Print message AFTER loop is broken out of to let the user know the break was successful . Important: As you finish two to three exercises, before you move on to the next one, ask Caitlin or Jack to come over and look at your comments to make sure that they aren’t missing anything. This is important; often we will ask you questions that reveal that you might not have fully understood the program. Hint: Use print: After the timer goes off, if you are still trying to figure out what the program does, you should use print(). Add print() statements to the program and run it again to print out the contents of variables (or lists or dictionaries) so you can see what is stored in them. This will help you think about what the program does and how it works. Exercise 1 . Set your timer for 2 minutes. Look at the program in ex1.py. Read the code, and write comments for each line or chunk of code as described above. Remember to describe what the program does at the top when you’re done. After your timer goes off, you are allowed to run the program to see what it does. Exercise 2 . Set your timer for 2 minutes. Look at the program in ex2.py. Read the code, and write comments for each line or chunk of code as described above. Remember to describe what the program does at the top when you’re done. After your timer goes off, you are allowed to run the program to see what it does. Exercise 3 . Set your timer for 5 minutes. Look at the program in ex3.py. Read the code, and write comments for each line or chunk of code as described above. Remember to describe what the program does at the top when you’re done. After your timer goes off, you are allowed to run the program to see what it does. ",
    "url": "/labs/practice_reading.html#code-reading",
    "relUrl": "/labs/practice_reading.html#code-reading"
  },"191": {
    "doc": "Lab",
    "title": "Check in",
    "content": "At this point, ask the instructor or TA to check your comments for exercises 1 through 3 before moving on. Switch drivers if you haven’t already. Exercise 4 . Set your timer for 5 minutes. Look at the program in ex4.py. Read the code, and write comments for each line or chunk of code as described above. Remember to describe what the program does at the top when you’re done. After your timer goes off, you are allowed to run the program to see what it does. Exercise 5 . Set your timer for 5 minutes. Look at the program in ex5.py. Read the code, and write comments for each line or chunk of code as described above. Remember to describe what the program does at the top when you’re done. After your timer goes off, you are allowed to run the program to see what it does. Exercise 6 . Set your timer for 8 minutes. Look at the program in ex6.py. Read the code, and write comments for each line or chunk of code as described above. Remember to describe what the program does at the top when you’re done. this program do? . After your timer goes off, you are allowed to run the program to see what it does. ",
    "url": "/labs/practice_reading.html#check-in",
    "relUrl": "/labs/practice_reading.html#check-in"
  },"192": {
    "doc": "Lab",
    "title": "Check in",
    "content": "At this point, ask the instructor or TA to check your comments for exercises 4 through 6 before moving on. Now is a good time to switch drivers again. Exercise 7 . Set your timer for 7 minutes. Look at the program in ex7.py. Read the code, and write comments for each line or chunk of code as described above. Remember to describe what the program does at the top when you’re done. this program do? . After your timer goes off, you are allowed to run the program to see what it does. Exercise 8 . Set your timer for 10 minutes. Look at the program in ex8.py. Read the code, and write comments for each line or chunk of code as described above. Remember to describe what the program does at the top when you’re done. this program do? . After your timer goes off, you are allowed to run the program to see what it does. ",
    "url": "/labs/practice_reading.html#check-in-1",
    "relUrl": "/labs/practice_reading.html#check-in-1"
  },"193": {
    "doc": "Lab",
    "title": "Check in",
    "content": "At this point, ask the instructor or TA to check your comments for exercises 7 and 8 before you try a challenge. Don’t forget to add, commit, and push all of your comments to your git repository. ",
    "url": "/labs/practice_reading.html#check-in-2",
    "relUrl": "/labs/practice_reading.html#check-in-2"
  },"194": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "Please complete at least one challenge before leaving for the day. It is up to you which one you do. Ask Caitlin or Jack to come over and see the results of your challenge before you leave. Challenge 1: Eliza . Also in the git repository for this week is the Eliza program that you ran the very first week of the semester. Do this same code reading exercise on that program: for each line of the program, put a comment next to it describing what that line does and how it works. Pay particular attention to the responses variable. What is stored in that variable? It is a list. But a list of what? How does that work? How does it get used? . Challenge 2: Last week’s studio . If you and your partner were in different studio groups last week, have one person bring up the code for their group’s studio and have the other person read the code and try to figure out what it’s doing. The person who didn’t work on that group’s studio last week should be driving. Figure out as much as you can without running the code first. If you were in the same studio group, or didn’t attend last week, find a studio that only one of you worked on. ",
    "url": "/labs/practice_reading.html#challenges",
    "relUrl": "/labs/practice_reading.html#challenges"
  },"195": {
    "doc": "Lab",
    "title": "Lab",
    "content": "You have spend almost all of the lab and studio sessions writing code for this class. Writing code is relatively straightforward – you enter code into the text editor, you run the code, see if it does what you want it to, and then keep editing it until it does. One aspect of this is that you don’t always have to really understand what the code is doing – sometimes you get lucky and it just works. The goal for today is to practice reading code. Reading code is harder than writing code. Reading code requires you to think more carefully about what each line of a program is doing. It requires you to keep track of what is stored in variables, and what variables contain what information. It requires you to think through options for if statements, to try to understand why they are there. You are going to practice reading today, to try to get better at it. Reading code is one of the best ways to become a better programmer, once you have the basics down. But reading code is a skill that requires practice, just like all other skills. ",
    "url": "/labs/practice_reading.html",
    "relUrl": "/labs/practice_reading.html"
  },"196": {
    "doc": "Lab",
    "title": "Using Functions with Parameters",
    "content": "Today, we are going to write code to build a checkboard using Turtle and write some of our own functions. Today’s lab is focused on learning more about how functions are actually used in real programming. You are always welcome to revisit the previous functions lab to refresh your memory. Exercise 1: Squares . The file board_1.py wants to draw a game board, but it is missing the code for its square function. The square function takes two parameters – how big the square should be, and what color the square should be. Fill in the code for this function. Test this. Does it work? It should draw a large black square on the screen. You can also test this by going down to the line where square(400, \"black\") is called, and change the number to a different size. Does it draw a different size square? (It should.) This is generally a good idea when working with functions. Run the program a couple of different times, putting different values in the parameter to make sure that the function does what it is supposed to do. Don’t forget to change the parameters back to the way it started square(400, \"black\") when you are done testing it. Hint: Remember it’s good practice to have the Turtle be in the same place AND facing the same direction at the start of the function as at the end. Hint 2: I would recommend using color() here to define the color of the square. Remember fill_color() only affects the fill color, and pen_color() only affects the outline color. color() handles both. Exercise 2: Red Squares . The file board_1.py draws a large black square. Let’s change this to draw a large red square. If you wrote your function well, then all you should need to do is change one line near the bottom to say 'red' instead of 'black'. Try that: . square(400, \"red\") . Test this. Does it work? It should draw a large red square on the screen. If it does, then great! You finished this exercise. If it doesn’t – if it still draws a black square – then your function isn’t working the way it is supposed to. Go back to your function and modify it so that it draws whatever color square is specified on that line at the bottom of the program. Exercise 3: Row of Squares . The file board_2.py continues our work toward building a game board. Copy-and-paste the code for your square function into this file. You should see another function, called row. It wants to draw a row of squares. Write the code to do this. You should build on your square function; that is, you should repeatedly call your square function to draw a row of squares all the same color. As you do this, think carefully about side effects. When you a call a function, it has side effects. For Turtle, the side effects include moving the turtle and changing the direction the turtle is facing. If your function has side effects, that can cause problems if you call the function multiple times, or if you call other functions after it. To deal with this, it is a good idea to try to make sure our functions are predictable – they always leave the turtle in the same place it started and facing the same direction it started. So, make sure that all of the right() or left() turns in the function always turn a total of 360 degrees. If your square function from Exercise 1 has side effects, you might have to modify it to make it work in the row. Hint: You should use a for loop with a range() parameter to draw the row; for i in range(number): . Hint 2: You shouldn’t need to write turtle code for drawing a square again. Just call your square() function to draw the square! . Hint 3: The hard part about this execise is understanding parameters of functions. It might help to go back to the readings and look at how they talk about parameters. Remember that parameters are variables; they get filled in with whatever is passed into the function when it is called, and you use them like normal variables, but only inside the function. Hint 4: No hard-coded numbers are needed for the row() function. ",
    "url": "/labs/practicing_functions.html#using-functions-with-parameters",
    "relUrl": "/labs/practicing_functions.html#using-functions-with-parameters"
  },"197": {
    "doc": "Lab",
    "title": "Return Values",
    "content": "In Python, functions can return values that they figure out. For example, you’ve already used the input() function, which does 2 things: it prints out a prompt, and then it returns whatever the user enters. You then store that returned value into a variable when you say variable = input(\"prompt\"). Exercise 4: Next Color . Look at the file color.py. It contains a function called next_color that returns a value – a string containing the name of a color. Right now, it always returns \"black\" as the next color. Run the program, and you can see what it does. The program has a variable called col that stores the current color, and prints out what it thinks the current color is. Then it calls next_color, and it changes the current color from red to black. Then it repeats that again – calling next_color and printing out what the current color is. However, since next_color always returns \"black\", the current color always stays black. next_color takes a parameter of what the current color is. Modify the next_color function to use an if statement to return different colors. If the current color is “red”, return black. If the current color is “black”, return red. What happens when you run this program now? . Exercise 5: Checkerboard . Let’s combine the last 3 exercises to see if we can get Python to draw a checkerboard pattern on the screen. Copy and paste your code from the previous three exercises into the board_full.py file. Then you should modify the row() function so that after it draws each square, it changes the color to whatever is returned from next_color. This should hopefully allow you to draw a checkerboard pattern on the screen. Reminder: If you put speed(0) at the top of your file, the turtle will draw much faster. Hint: If you are having trouble getting it to work, try reading the code under draw_board() that calls next_color() to see how it is used. Exercise 6: Draw a Rainbow . Let’s take a detour from our board game. The program rainbow.py is designed to draw a rainbow. However, it currently only draws a weird orange box with a red stripe on top. It needs you to implement the function is next_color(). This function is interesting. It takes one parameter – the current color – and then figures out what the next color should be. That next color is then returned from the function. This is really similar to the next_color function from the previous exercise. Except this time, it needs to needs to handle more than just back-and-forth. Finish writing this function. Once you finish writing this function, the program should draw a rainbow on the screen. Note: The colors of the rainbow, in order, are usually red, orange, yellow, green, blue, indigo, and violet. Or maybe red, orange, yellow, green, cyan, blue, and violet, if you prefer. The screenshot below uses cyan and blue. Exercise 7: Rainbow Checkerboard . You’ve now got a nicer next_color function. You should be able to put that into the checkerboard file (replacing the black-and-red one) and produce a rainbow checkerboard! . Start by opening board_full.py and doing a File –&gt; Save As and saving a new copy as rainbow_board.py. You should be able to do this by only replacing the next_color function. Hint: You will need to make it cycle to make it look like the screenshot. Modify your function so that the next color after the last color in the rainbow is the first again. ",
    "url": "/labs/practicing_functions.html#return-values",
    "relUrl": "/labs/practicing_functions.html#return-values"
  },"198": {
    "doc": "Lab",
    "title": "How are functions used?",
    "content": "So far, you’ve written functions that take parameters and do different things based on those parameters, and also functions that return values. But why do we separate things into functions? What is the point? . In this section of the lab, we will try to understand the idea of abstraction: we can use functions to make programming easier by abstracting away the difficulties. Let’s take our checkerboard for example. Say we want to put a checker piece on one of the spots of the board – how would we do that? Right now, you’d have to do a lot of work to figure out where on the screen it should go, the size it should be, etc. Let’s see if we can make that simpler by writing a couple functions. Exercise 8: Draw a Circle on a square . Go back to board_full.py. When you run it, the turtle stopped at the upper-left square of our checkerboard. Add a new function called draw_piece that draws a red circle on that square. It should take no parameters and should draw a piece on whatever square the turtle currently is on. Hint: The whole checkerboard is 400 pixels across, and there are 8 squares acrosss. So each square is 400/8 pixels. You don’t need to do the math; the program can do it for you. Just specify 400/8 to get the right size. Reminder: Turtle has a circle() function that draws a circle counterclockwise. It takes one parameter – the size (radius) of the circle. Use it (along with color(), begin_fill(), and end_fill()) to draw a filled in circle. Note that the radius should be half of the size of a square – so if 400/8 is the size of a square, the radius of the circle should be 400/8/2. Hint 2: Don’t hard-code locations using goto(). That might work for this exercise, but it will make it hard to do the next exercises where we move the pieces to different locations on the board. Reminder 2: Don’t forget to call your draw_piece() function at the end of the file. Exercise 9: Goto a square . In chess, each square is given a number and a letter so that players can describe each move they make - e.g. “queen to e4”. We can do something similar here. Since we’re using Turtle, though, let’s give each square a designation that looks like x/y coordinates, but is a bit easier to use. Let’s start in the upper left, where the turtle is and where you just drew a piece. Let’s call that square (1,1). The one just to the right of it then will be (2,1) (and (3,1), (4,1), etc.). The one just below it will be (1,2). The lower right corner square is (8,8). I’ve written a function called goto_square(), located in the file goto_square.py. It takes two parameters – the square number coordinates for row and column. It then moves the turtle to the upper left hand corner of that square on the checkerboard. Copy-and-paste that function into your checkerboard program. Exercise 10: Place a piece on square (5,6) . Now combine these two functions. Use the goto_sqaure() function to goto square (5,6) on the board. Then use your draw_piece() function to draw a circle in the middle of that square. Exercise 11: Place a piece on a square the user specifies . For the final exercise today, ask the user which square to put a piece on (using textinput(), which is very similar to input() and we used in the first Turtle lab). You’ll have to ask twice – once for the row, and once for the column. Do you see how functions make this easier? Now, instead of having to do that complicated math each time you want to draw something on a square, you just call your goto_square() function which does the thinking for you. You just tell it which square to draw on. This is one way functions are really useful. They provide an abstraction – now that you have the goto_square() and draw_piece() functions, you don’t need to think about circles, lines, and fills. All you need to do to play checkers is to go to a specific checkers square, and draw a piece there. Because of the functions, you can think about checkers pieces and not about Turtle lines and fills. ",
    "url": "/labs/practicing_functions.html#how-are-functions-used",
    "relUrl": "/labs/practicing_functions.html#how-are-functions-used"
  },"199": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you still have time before the end of class after completing all of the exercises, try at least one of the challenges below. Challenge 1: Change the size of the board . Take the code that I wrote and put it into its own function that draws a checkerboard. Modify the function to accept a new parameter – the number of squares across on the board. Right now, it does an 8x8 checkerboard. Use your new function to draw a 10x10 checkerboard. Note: You don’t have to make the piece drawing work for this, but if you want to try, go for it! . Challenge 2: Multiple pieces . Use a loop to ask the user for multiple locations, and place a piece at each location they tell you to. Bonus: use alternate colors for each piece that is placed - one color for player one, a different color for player 2, and with the assumption that the players are taking turns. Challenge 3: Remove a piece . How would you remove a piece from the board? Write a function to remove a piece from a specific square. ",
    "url": "/labs/practicing_functions.html#challenges",
    "relUrl": "/labs/practicing_functions.html#challenges"
  },"200": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/labs/practicing_functions.html",
    "relUrl": "/labs/practicing_functions.html"
  },"201": {
    "doc": "Readings",
    "title": "Readings",
    "content": ". | The Most Important Skill for a Developer Is Reading Code | How to Quickly and Effectively Read Other People’s Code | . Also, please skim through the following: . | Loops in Python | Automate the Boring Stuff: Chapter 3 - Functions | Automate the Boring Stuff: Chapter 4 - Lists | Automate the Boring Stuff: Chapter 5 - Dictionaries and Structuring Data | . Yes, you read those before. Skim through them again. Now that you’ve spent some time working with these ideas (for loops, lists, dictionaries, functions), they should make sense in a different way. ",
    "url": "/readings/reading_code.html#readings",
    "relUrl": "/readings/reading_code.html#readings"
  },"202": {
    "doc": "Readings",
    "title": "Summary",
    "content": "As you re-read these, what new things do you notice that you didn’t last time? Is there anything that makes more sense this time through than last time? . Summary prompt: What new things did you learn by re-reading these readings again? . ",
    "url": "/readings/reading_code.html#summary",
    "relUrl": "/readings/reading_code.html#summary"
  },"203": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . We do not have class on Tuesday this week. Submit your summary+question on D2L under Quizzes before class starts on THursday. Thursday’s class will be a lab. ",
    "url": "/readings/reading_code.html#question",
    "relUrl": "/readings/reading_code.html#question"
  },"204": {
    "doc": "Readings",
    "title": "Readings",
    "content": "This week’s topic is reading code. You’ve been doing a lot of this already, but it’s important to keep practicing. One of the most important skill you can have as a programmer is to be able to read and understand code that other people have written. ",
    "url": "/readings/reading_code.html",
    "relUrl": "/readings/reading_code.html"
  },"205": {
    "doc": "Lab",
    "title": "Using dictionaries for analysis",
    "content": "For this series of exercises, we are going to build up a program that counts words in a file (how many times each word appears) and prints the results. Dictionaries are useful any time you have key/value information – you want to associate one thing (the ‘key’) with another thing (the ‘value’). The key is always a word, but the value can be anything. We’ve mainly used dictionaries as a way to provide structure for sets of data, but dictionaries can also be useful for analyzing text. Today we’ll use dictionaries to do some very basic text analysis. Exercise 1: Ducks and Sheep . Consider the phrase “duck duck goose”. The word “duck” appears twice, and the word “goose” appears once. The program count.py specifies a dictionary that stores these counts and prints them out. It says that there are 2 ‘ducks’ and one ‘goose’. Each word is used as a key in the dictionary, and the value for that each is the number of time that word appears. Once we are done making the dictionary, each key is a word and the value for that key is the count of the number of times the word appears in “duck duck goose”. Modify the program to instead report counts for the phrase “Baby, I’m just gonna shake, shake, shake, shake, shake”. You should use the same program structure: use setdefault() on each unique word in the phrase to set the value associated with each word to 0 at the top, and then use a single line to increment the counter for each word of the phrase. Hint: += is used to add to an existing number. So . var += 10 . is the same as saying . var = var + 10 . Exercise 2: Split the string . It’s a pain to add each word to the dictionary one by one. Luckily, we’re using Python, and Python has lots of tools to make that kind of work faster. Right now, the phrase “Baby, I’m just gonna shake, shake, shake, shake, shake” is a string, and we’ve been breaking it up into individual words and adding them to the dictionary manually. Python has a function for breaking up strings into a list of words. We can then use a for loop to add each word to the dictionary. Create a new program called word_count.py. Paste the phrase “Baby, I’m just gonna shake, shake, shake, shake, shake” into the new program and save it to a variable. Now let’s break up this phrase – which is a string – into individual words. In Python, we can do this with the split() function, which separates out each word and returns a list of words. So if I have a string called s: . s = \"I shake it off\" . and I run s.split(), then the list it returns will look ike this: . [\"I\", \"shake\", \"it\", \"off\"] . Do this on the phrase in your program, and print out the resulting list. Hint: You’ll want to save the results of the split() function - the list - into a new variable, otherwise you’ll have a hard time with the next exercise. Exercise 3: Count words using a dictionary . Now we have a list of words. Remember you can use a for loop to go through a list item by item like this: . for item in my_list: . Every time this loop runs, the variable item represents the next word in the list. You can use that variable inside of the loop to do things with each word. Now create a blank dictionary called words. We’ll use the for loop to add each word in the list to this dictionary along with a value representing how many times that word has been encountered. First, you will want to set the default value associated with each word to 0 using a phrase like this: . my_dictionary.setdefault('word','default_value') . In this example, ‘word’ is the key and ‘default_value’ is the value – both of these are hardcoded. But we want the word - the key - to be different each time the loop is run, so that each individual word will be added to the dictionary. Remember there’s a variable in the for loop statement that represents each word in the list of words. We also want the default value to start at 0 for each word so that we can add to that count every time we encounter the word. After you set the default value, you’ll want to increment the count for the value every time the word shows up. You already did this in the first exercise. Your for loop should now set the default value for each word and then increment the count associated with that word each time it sees it in the list. Print out the words dictionary when you’re done. It should look like this: . {'Baby,': 1, \"I'm\": 1, 'just': 1, 'gonna': 1, 'shake,': 4, 'shake': 1} . Exercise 4: Clean up text, part 1 . Notice the work ‘shake’ is in the dictionary twice. The fist time it appears, there’s a comma next to it. We can use Python to strip out the punctuation. Python has another useful function that works on strings called replace(). This function will replace a given character or word in a string with something else. replace() takes two arguments: the character/word to find in the string, and the thing you want to replace that character or word with. For example, . my_string.replace(\"w\",\"x\") . would look for every time the character ‘w’ shows up in a string and replace it with the character ‘x’. For this exercise, what we’re going to do is replace all of the punctuation characters in the string with nothing, like this: . punc = \",.?!:;-\" # common punctuation marks, saved into a string for char in phrase: # go through each character in the \"phrase\" string if char in punc: # for each character in the string, checks if the character is also in the string called 'punc' phrase = phrase.replace(char, \"\") # replaces the character with nothing and resaves the string . Integrate the code above into your program. If you’ve done it correctly, the dictionary that prints out should now look like this: . {'Baby': 1, \"I'm\": 1, 'just': 1, 'gonna': 1, 'shake': 5} . Hint: You’ll need to think about where best to put this code. Think about the order that things are happening in: should this code go before or after the phrase is split up into a list of words? . Exercise 5: Clean up text, part 2 . That looks better. But note that some words are capitalized and some words aren’t. If the word “Baby” were to show up more than once and some instances were capitalized and some were not, it would end up as two different entries in our word count dictionary. Let’s fix that. Python has yet another function that can be used on strings to make all of the characters lower case called lower(). We used it all the way back in Week 2 and a few times since then. Use it here to convert the whole song to lower case before you split it up into words. Now your dictionary should look like this: . {'baby': 1, \"i'm\": 1, 'just': 1, 'gonna': 1, 'shake': 5} . Hint: Remember if you want the string to be saved as all lower case, you have to overwrite the variable the string is saved into when you apply lower() to it. Exercise 6: Use different text . This program is working pretty well with a short phrase. What about something longer? We’re only running it on one line of the Taylor Swift song. Let’s use the full refrain instead: . 'Cause the players gonna play, play, play, play, play And the haters gonna hate, hate, hate, hate, hate Baby, I'm just gonna shake, shake, shake, shake, shake I shake it off, I shake it off Heartbreakers gonna break, break, break, break, break And the fakers gonna fake, fake, fake, fake, fake Baby, I'm just gonna shake, shake, shake, shake, shake I shake it off, I shake it off I shake it off, I shake it off I, I shake it off, I shake it off I, I shake it off, I shake it off I, I shake it off, I shake it off . Note: In Python, hard-coded strings normally all appear on one line: \"hello\". If you want a string to be more than one line long (like the lyrics above), you can use triple quotes around it. So something like this: . lyrics = \"\"\" These are the lyrics to a song that span more than one line and don't rhyme \"\"\" . The dictionary that prints out should now look like this: . {\"'cause\": 1, 'the': 3, 'players': 1, 'gonna': 6, 'play': 5, 'and': 2, 'haters': 1, 'hate': 5, 'baby': 2, \"i'm\": 2, 'just': 2, 'shake': 22, 'i': 15, 'it': 12, 'off': 12, 'heartbreakers': 1, 'break': 5, 'fakers': 1, 'fake': 5} . Exercise 7: Print the results nicely . You’ve got a really program for cleaning text and counting words at this point. However, the way that Python prints out dictionaries is really annoying and hard to read. Modify your program to loop through all of the words in the dictionary and print out the count for each word on a separate line, like this: . 'cause: 1 the: 3 players: 1 gonna: 6 play: 5 ... You can do this by calling dict.keys() – which returns a list of all of the keys (words) in the dictionary. You can then use a for loop to loop through that list. ",
    "url": "/labs/reading_files.html#using-dictionaries-for-analysis",
    "relUrl": "/labs/reading_files.html#using-dictionaries-for-analysis"
  },"206": {
    "doc": "Lab",
    "title": "Working with Files",
    "content": "We can do a lot with strings in Python. But if you have a lot of text – like a book’s worth of text – it becomes very annoying to store the text inside the program itself. Instead, you can store the text in text files (files that end in .txt) and have Python read text from the file and into the program. Exercise 8: Print out a file’s contents . If you look in the repository, there is a file there called filecount.py. It contains the beginning of a program. Right now it just opens a file, reads the first line, and prints it out. Notice that it uses the with() command. with() allows you to open a file, and then everything in the with block – everything indented below the with command – has access to the file. As soon as a line runs that isn’t indented, then Python closes the file, and the program no longer have access to it. Also, remember that with is NOT a loop; it only runs once (like if). Run this program. What does it print out? Look at the other files in the git repository – where is this program getting the text from? . Exercise 9: Print out the full file . Modify filecount.py to read in the whole file, one line at a time, and then print out the text from the file one line at a time. You will need to add a loop to the program to do this. There are two ways to read in a file. Choose one, and try to get it working: . | One way is to put the f.readline() function inside a while loop. It returns \"\" (an empty string) when it gets to the end of the file, so you can break out of the loop when you see an empty string (e.g. while line != \"\"). | The other way is to use a for loop – for line in f:. If you use this, then the for loop implicitly does a readline() behind the scenes, saves each line in the variable line, and automatically stops at the end of the file. (You do NOT need readline() if you use a for loop; you should remove that line if you choose to use a for loop.) . | . Either way will work. Pick one, and modify the program to print out the whole file. Exercise 10: Print line numbers . Right now, the program is really basic; all it does is print out the contents of the file. But once you have the contents of the line in a variable, you can have your program do more interesting things. We will start with something simple: adding line numbers. Modify your program to print out the line number, and then the contents of the line. The output should look something like this: . 1 All the world‘s a stage, 2 and all the men and women merely players. 3 They have their exits and their entrances; 4 And one man in his time plays many parts . Hint: To do this, you’ll have to keep track of which line you are on with a counter variable, which you can increment (add 1 to it) every time you read a new line in. Exercise 11: Print out the total number of lines in the file . Modify the program to print out how many lines are in the file at the very end. This should be pretty easy if you finished the previous exercise. The total number of lines is the line number for the last line, right? . There are a total of 4 lines in this file . Exercise 12: Count the total number of words in the file . Modify the program to count the total number of words in the file. Your program should take each line, split it into separate words, and count the words in the file. Your program should print out the total count after it is finished reading the whole file in. Remember, we used split() in our word counter program to convert a string into a list of words. You can use it in a similar way here. Once you have them in a list, you can then count them: len(list) returns the length of list (the number of items in that list). number_of_words_in_line = len(words_list) . Exercise 13: Change the file you read from . Right now, the program always reads the same file – ‘short.txt’. Modify the program so that when you run it, it instead reads in the file ‘medium.txt’, prints it out with line numbers, and calculates information for that file instead. ",
    "url": "/labs/reading_files.html#working-with-files",
    "relUrl": "/labs/reading_files.html#working-with-files"
  },"207": {
    "doc": "Lab",
    "title": "Count words from files",
    "content": "Right now this program is just telling you very basic things about the file you give it. But we can do more interesting things – we’ve already done more interesting things with strings. We can do the same things with text from a file. Exercise 14: Count how many of each word . For this exercise, modify your program to instead count how many times each word appears. You should have a separate count for each word. Sound familiar? You’ve already done in your word_count.py program. Bring the code from that program into this one, but modify it to use the text from the file instead. Your program should print out a dictionary that has the count of the number of times each word appears in the file. When I run mine on “short.txt”, these are the counts I get: . {'All': 1, 'the': 2, \"world's\": 1, 'a': 1, 'stage,': 1, 'and': 3, 'all': 1, 'men': 1, 'women': 1, 'merely': 1, 'players.': 1, 'They': 1, 'have': 1, 'their': 2, 'exits': 1, 'entrances;': 1, 'And': 1, 'one': 1, 'man': 1, 'in': 1, 'his': 1, 'time': 1, 'plays': 1, 'many': 1, 'parts': 1} . Exercise 15: Clean up the text . You also have code in word_count.py that removes extra punctuation makes and puts all the words into lower case. Let’s use that code here, too – that is, if you haven’t already done so. Now your dictionary should look like this for “short.txt”: . {'all': 2, 'the': 2, 'world‘s': 1, 'a': 1, 'stage': 1, 'and': 4, 'men': 1, 'women': 1, 'merely': 1, 'players': 1, 'they': 1, 'have': 1, 'their': 2, 'exits': 1, 'entrances': 1, 'one': 1, 'man': 1, 'in': 1, 'his': 1, 'time': 1, 'plays': 1, 'many': 1, 'parts': 1} . Remember that all of the code that acts on text from a file must be inside the with block. Exercise 16: Print the results nicely . The bigger a dictionary gets, the harder it is to read. Modify your program to loop through all of the words in the dictionary and print out the count for each word on a separate line. Remember you’ve already done this in a previous exercise. Make sure to test it with both short.txt and medium.txt. Exercise 17: Move to Long . Look at the file long.txt in the repository. It is the play “Twelfth Night” by William Shakespeare. Yes, the entire play. Modify your program to count how many of each word is present in that play and print out the results. This should be easy, but the results will be much, much longer! . ",
    "url": "/labs/reading_files.html#count-words-from-files",
    "relUrl": "/labs/reading_files.html#count-words-from-files"
  },"208": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you’ve finished all of the exercises above and still have time left in class, try at least one of the challenges below. Note: most of these challenges will be helpful for the studio this week. Challenge 1: Sort the words by frequency . Modify your program to only print out most common words that appear in the input file, with the most common words first. Make sure it works with all three text files: short.txt, medium.txt, and long.txt. Note it’s easiest to test code on short.txt because it’s the output is so much smaller. You can do this by sorting the dictionary and looping through your sorted dictionary, and then print out the word and the count. Make sure the output looks nice and is easily readable by humans. Dictionaries are stored in Python in a random order. It is not possible to actually sort a dictionary like you can sort a list. However, you can loop through the dictionary in a specific order. Here are some options: . Sort by key . for key in sorted(dict): print(key, dict[key]) . Sort by value . for key in sorted(dict, key=dict.get): print(key, dict[key]) . Reverse sort (highest first) . for key in sorted(dict, reverse=True): print(key, dict[key]) . Combined (reverse sort by value) . for key in sorted(dict, key=dict.get, reverse=True): print(key, dict[key]) . Choose one of these options and use it to sort your dictionary and print out the the words in order by how common they are. When I print out most common words in medium.txt, this is what I get: . and 5 thou 4 shall 3 to 3 of 3 fair 3 thee 2 a 2 summer’s 2 more 2 the 2 ... Challenge 2: Top 10 most common words . Modify your program to only print out the 10 most common words that appear in the input file. Try it out with both medium.txt and long.txt. You should be able to do this by keeping a separate counter, and then using break to stop the loop after you’ve printed out 10 words. Challenge 3: Stop List . When you run your program, particularly on medium.txt and on long.txt and look at your top 10 list, you’ll notice that many of the top words are obvious – and, of, the, a, etc. Let’s try removing the really common, obvious English words to see if we can get a list of the more unique words in the files. This is called making a stop list. Create a list at the top of your file that contains common English words. Then, when you are reading in the file, if you see a word in that list, skip that word. Once you have the stop list working, run your word counting program on long.txt. What are the 10 most common words in Shakespeare’s Twelfth Night, not counting really common boring words? . Hint: Python supports not in a list. If you have a list of stop_words, you can say . if word not in stop_words: ... Challenge 4: Top 10 words in a different Shakespeare play . Pick a different Shakespeare play that you like, and use your program to figure out the most common words in that play. You can find plain text copies of Shakespeare’s plays on Project Gutenberg. Pick a play, download the “plain text” version of the play, and then run your program on that file. Make sure the file is in the same folder as the program on your computer. If you do it right, you should only have to change one line in your program. ",
    "url": "/labs/reading_files.html#challenges",
    "relUrl": "/labs/reading_files.html#challenges"
  },"209": {
    "doc": "Lab",
    "title": "Lab",
    "content": " ",
    "url": "/labs/reading_files.html",
    "relUrl": "/labs/reading_files.html"
  },"210": {
    "doc": "Studio",
    "title": "Advice",
    "content": "Pick a studio you enjoyed, or didn’t finish . You can pick any past studio you want to work on and refactor. My recommendation would be to pick a studio you remember enjoying; you’ll care about it more if you had fun with it. Or if there’s a studio you and your group didn’t manage to complete, you can use today as an opportunity to get the code working. Take time to read and understand the code . Read through the code and make sure you understand what it’s doing. Run the program to see if it does what you expect based on how you’ve understood the code. It will likely be helpful to add comments to the code to note down what data each variable is storing, what each function does, etc. Use Functions . Code is much easier to read and work with when it is organized into functions. Functions are also really useful for repeating code. A large part of refactoring is figuring out how to write functions so that you aren’t repeating yourself, and so the code is easier to read. Ideally, you will most most of your code into functions, and have a relatively short ‘main’ section that just calls the appropriate functions in the right order. Use files to store data . One way to approach refactoring is to think about the data you’re working with in the program and where the most efficient way to store that data would be. If you’re working on a studio that uses content - like text-based data that comprises a story - it might make sense to save that data into files and then use Python to read the files in order to make use of the data. You can also write text to a file, which might be useful for storing user input, for example. Look for opportunities to refactor . Go back to Monday’s lab for ideas how to refactor. When we looked at our existing code, we looked for a couple of things to identify opportunities for refactoring: . | Look for repeated code, or places where the exact same code is repeated multiple times. Pull them together into a function. | Look for similar code, or places where code that isn’t exactly the same, but is similar, is repeated multiple times. That is a good candidate for putting into a function with one or more parameters. Small differences can be controlled with the parameter (like the color parameter to the rectangle function). | Look for opportunities to generalize. Just like we went from red_strip() to stripe(color) to colored_rectangle(...), look for places where you take an existing function, and make it more useful by making it slightly more general than it currently is. (Emphasis on slightly; if you make things too general, then they become less useful). | Remove unneeded code. As you look at the code, you might find things that aren’t needed anymore. Remove them from the file so they don’t get in the way of the more important things. | Look at how data is stored. If the program is storing data, what form does the data take? For example, if it’s two lists that work with each other, would a dictionary make more sense? Or if it’s all text data in strings, would it make more sense to store everything in a text file? | . Think about the User Experience . Refactoring is a gread opportunity to make minor changes to improve the user experience of running your program. Put yourself in the shoes of someone else running your code. What would make it easier to use? Some things I’ve seen groups do in class so far include: . | Adding spaces in appropriate places (e.g. at the end of an input() prompt) so things don’t run together. | Adding additional text (print() statements) to help explain what the program does and what the user is supposed to do. | Moving the turtle at the beginning of the program up and to the left, so whatever it draws is centered on the screen. | Changing the font or the color or the line thickness so whatever is being drawn by the turtle is easier to see | Speeding up the turtle (with the speed() function) so you don’t have to wait as long for things to draw. (OR have it speed up and slow down at different times as it draws for dramatic effect.) | . How much more can you do? . If you think you’ve done enough refactoring with a studio, call for help from either Jack or me and talk us through the changes you made. If we don’t have additional ideas, then you can move on and work on refactoring another studio. ",
    "url": "/studios/refactor_old_studio.html#advice",
    "relUrl": "/studios/refactor_old_studio.html#advice"
  },"211": {
    "doc": "Studio",
    "title": "Studio",
    "content": "Your goal today is refactoring. The task for today is to go back to one of the previous studios that you did, read through the code, and then re-write the code. Your goal in re-writing the code is to make it easier to read, easier to understand, more reusable, and to work better. Much like you did on Monday, you don’t need to change what the program does. You just should revise and rewrite the code to make it do what it already does better. For today’s studio, it is up to you whether you work by yourself or whether you work in a group. You do not have to be working with the same group that you did for the original studio; it is OK to refactor code that others wrote. That’s it. That’s the whole of the instructions – choose a past studio, optionally form a group to work with, and revise the code to work better. Have fun with it. What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. ",
    "url": "/studios/refactor_old_studio.html",
    "relUrl": "/studios/refactor_old_studio.html"
  },"212": {
    "doc": "Readings",
    "title": "Readings",
    "content": ". | Refactoring: Introduction and Its Techniques | Working with Modules in Python | Python File Operation | . You may recognize the last two readings, from last week and from a few weeks ago. Read them again - do they make a bit more sense now? . ",
    "url": "/readings/refactoring.html#readings",
    "relUrl": "/readings/refactoring.html#readings"
  },"213": {
    "doc": "Readings",
    "title": "Summary",
    "content": "For the summary this week, think about the code you’ve written for studios throughout the semester. You know more about Python now than you did in September - how might you approach doing some of those earlier studios now? It might help to look at the [schedule]{(% link schedule.md %)} and your old Gitlab repos to refresh you memory and what the studios were and how you approached them then. Summary prompt: How do you think modules and files might be useful for refactoring? . ",
    "url": "/readings/refactoring.html#summary",
    "relUrl": "/readings/refactoring.html#summary"
  },"214": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Tuesday. NOTE: Tuesday’s class will be a studio, and will be extra credit (attendance is optional). The summary+question for this week is still required. ",
    "url": "/readings/refactoring.html#question",
    "relUrl": "/readings/refactoring.html#question"
  },"215": {
    "doc": "Readings",
    "title": "Readings",
    "content": "This week we’re practicing refactoring - the process of improving and simplifying code you’ve already written. ",
    "url": "/readings/refactoring.html",
    "relUrl": "/readings/refactoring.html"
  },"216": {
    "doc": "Reference",
    "title": "Reference Materials",
    "content": "These materials are here as quick references for students to refer to in and outside of class. ",
    "url": "/reference.html#reference-materials",
    "relUrl": "/reference.html#reference-materials"
  },"217": {
    "doc": "Reference",
    "title": "Reference",
    "content": " ",
    "url": "/reference.html",
    "relUrl": "/reference.html"
  },"218": {
    "doc": "Lab",
    "title": "Requests",
    "content": "Exercise 1: Install the requests library . We are going to begin by using a simple API that just gives us some current information. To do this, we need to install the requests library. Using the command line, run the command: . pip3 install requests . (Note: if you are using VIsual Studio Code to run your code, you’ll need to install requests through the terminal in VS Code.) . requests is a library that makes it easy to access APIs that are available through the web with Python. Exercise 2: Who is on the International Space Station? . There is an API available on http://api.open-notify.org/ that provides a lot of interesting information from NASA, including things like the current position of the International Space Station (the ISS). We’re going to use it today to find out which astronauts are currently on the ISS. To get that, we will use the astros.json endpoint. This endpoint will return a JSON file with the astronauts’ names. Endpoints for this API are URLs that contain the data. If you use the full URL (http://api.open-notify.org/astros.json) in a browser, it will show you the information in JSON format. Use the requests library to retrieve the list of current astronauts on the International Space Station and print out what the API returns. Start by looking at the file iss.py in the lab repository. First, make sure to include import requests at the top of your program so you can use the requests functions. Next, let’s query the API. To do this, you can use the requests.get() function. The URL for the endpoint you want to query is the parameter for the function. If we want to get a list of astronauts, then we will want to use the astros.json endpoint. Let’s save the results of the query to a variable called people, like this: . people = requests.get(astronauts) . If you use print on the people variable, what happens? Nothing useful, because people is a complex object that can’t be easily printed. We can access the text of the JSON object by using .text on the variable, like this: . people.text . Print out the JSON text showing the astronaut information. Hint: The Python API tutorial from this week’s readings might be useful to refer to for this exercise, and also for the next 2 exercises. Exercise 3: Convert the JSON response to Python . You will notice that the response, which is in JSON, is actually quite complex. JSON is a format using specifically for storing complex data structures. Fortunately, Python makes it pretty easy to convert JSON to Python data structures, like dictionaries and lists. This allows us to use Python to do stuff with the data, like loop through it. We can use the json library and use the json.loads() function to convert from JSON to Python: . import json info = json.loads(people.text) . Once you have loaded the JSON text into a Python dictionary, use pprint() (from the pprint library) to pretty print out the whole dictionary. When working with APIs, I have found that using pprint() to pretty print the resulting dictionary is important for helping me to see the structure of the data that I get from the API. Hint: You will probably need to from pprint import pprint for this exercise. Exercise 4: Number of people in space . Now we have a variable called info that is a dictionary with astronaut data in it. Let’s look at the structure of the data the API is giving us. It’s a dictionary with 3 keys: message, number, and people. The people key contains a list of dictionaries, and each dictionary in that list has two keys: craft and name. The key number in this structure has a value that is an integer. If you look at the output when you pretty printing info, you’ll notice that this number matches the number of astronauts. Let’s pull that number from the data and print out the number of astronauts in a human readable format, like this: . Number of people in space: 3 . Remember you can get the value associated with a key in a dictionary with this format: . dict['key'] . Note: The people currently in space frequently changes as people launch and land. You might not get the same number that I did when I wrote this. That’s one of the coolest parts of APIs; they can be current and up-to-date. Hint: The Dictionaries as Data Structures lab might be useful to refer to for a refresher on how to access data from complex structures like dictionaries. Exercise 5: Astronaut’s names . The number of astronauts is only one level deep in the info dictionary, so it was pretty easy to get. How would we print out the names of the astronauts? To do this, you need to go three levels deep. For example, if we wanted to print out the name of the first astronaut that’s listed, we’d need to target the key people, then the first dictionary in the list of people, and then the key name for that dictionary. The code would look like this: . info['people'][0]['name'] . When you use print() on that line of code, it should print out the name of one astronaut. For this exercise, we want to print out the names of all of the astronauts, not just the first one. Remember you can go through a list using a for loop. The list you want to loop through is info['people']. Remember you also want to target the name key once you get into a dictionary inside the list. When you’re done, what your program prints out should look like this: . Number of people in space: 3 Andrew Morgan Oleg Skripochka Jessica Meir . Hint: If you set up a for loop to go through the list info['people'] like this: . for person in info['people']: . then person represents each item in the list. In this for loop, person represents a dictionary, and you can use dictionary syntax (dict['key']) to target the key called name. ",
    "url": "/labs/requests.html#requests",
    "relUrl": "/labs/requests.html#requests"
  },"219": {
    "doc": "Lab",
    "title": "API Requests with Parameters",
    "content": "Requests can be more specific than just asking for a URL. You can add parameters to a request by putting the parameters in a dictionary and then passing the dictionary to the requests.get() function as a parameter. Exercise 6: Find words that rhyme with your name . Datamuse has a nice, easy to use API that will give you words that are related to other words in various ways. One thing you can do with this API is request words that rhyme (sound like) a word that you provide. To do that, you pass a parameter called rel_rhy (for “related” to by “rhyme”) to the datamuse words API and set that paramter equal to the word you want to rhyme. You can add parameters to a requests.get() call by putting them into a dictionary and then passing that dictionary as a second parameter: . parameter = {\"rel_rhy\": \"stuff\"} rhyming = requests.get(datamuse, parameter) . The file rhyme.py in the lab has the Datamuse API endpoint. Create a dictionary with one item in it – rel_rhy as the key, and your last name as the value. Then call the API, and print out what it returns. Printing out the raw JSON is fine; don’t convert it to Python or parse it yet. Hint: You’ll need to remember to import requests to use the requests library. Hint 2: Remember, to get the JSON data out of the result of the API call, you need to use .text like you did in the previous exercises. Exercise 7: Pretty print the JSON response . The raw JSON that is returned by DataMuse is complicated and hard to read. This is unfortunately pretty normal for APIs – they give you a LOT of information, and you need to pick through it to get what you want out. The first step is understanding what they give you back. For this exercise, your goal is to pretty print the results from the previous exercise. You will need to first convert the results from JSON to a Python dictionary using json.loads(), just like in Exercise 3. Then use the pprint() function to print it out in a readable form. What does the structure of this look like? Look for where there are list structures (look for square brackets, []) and dictionary structures (look for curly braces, {}). Look at how the different structures are nested within one another by looking for where a bracket or brace begins and ends, and what’s inside of it. Understanding how data is structured can help you figure out how to get what you need from the data. Also look at how the data is organized. In this case, the words are in descending order based on a “score” - the score indicates how closely each word rhymes with the word you gave it. Hint: You will need to import json and from pprint import pprint for this exercise. Exercise 8: Print out the rhymes . The API returns the a complicated JSON object. You already converted the JSON to a Python data structure using json.loads() in the last exercise. Now then print out all of the words that rhyme with your last name. Only print out the words: no brackets or scores or anything else in the dictionary. For example, if I want to rhyme the word ‘time’, I could run the program and get: . paradigm sublime rhyme prime crime ... Try it with different words. Notice the list is longer for some words than it is for others. Hint: You should only need 1 for loop for this. Exercise 9: Accept user input . Let’s make this rhyme finding program more user-friendly. Modify the program to accept user input. Ask the user what word they want to find a rhyme for, and then pass that word into the API. You can do this the same way you have all semester by using the Python input() command. Add some text above the rhyming words so the user knows which word the list of rhymes is for, like this: . These words rhyme with \"time\": paradigm sublime rhyme prime crime ... Hint: You will need to modify the dictionary you pass to the api to include the word input by the user. Exercise 10: Print only the top 10 rhymes . The list it gives you sure can be long. Modify your program so it only prints the top 10 words by score. Hint: The words are already organized in order by score, so you probably don’t have to do any extra work to make sure the order is correct. Hint 2: Remember you can use a counter and increment it to keep track of how many times the loop has run, and then break out of the loop when the counter reaches a certain number. But there are other ways to do this. ",
    "url": "/labs/requests.html#api-requests-with-parameters",
    "relUrl": "/labs/requests.html#api-requests-with-parameters"
  },"220": {
    "doc": "Lab",
    "title": "APIs with authentication",
    "content": "Both the Astronauts API and the Datamuse API can be used by anyone, without needing an account. Most APIs are not that open, though. Most APIs require you to have an account and to authenticate (prove who you are) before you are allowed to make queries. Some also require you to pay to be able to access data through the API. We’re only using free APIs for this class. Authentication is more complicated for APIs than it is on normal websites; they don’t just use a username and password. Instead, they use more complicated setups like OAuth or APIKey to do the authentication. Authenticating requires that you have a special key that you then put into your code so that every time your program makes a request, it’s logged under your username. For today’s lab, we are going to access the free API at The Movie Database (TMDB). TMDB uses an access key for access. You have to create an account on TMDB’s website, and ask it to generate an access key for you. Exercise 11: Sign up for TMDB, Create a new app, and retrieve the access key. In order to be able to access TMDB’s API, you need to have a TMDB account. If you do not already have a TMDB account, go to https://www.themoviedb.org/signup and sign up for an account now. You will need to verify your email address before you can move forward. Only one member of your pair needs to do this (you can both do it if you want, but you’ll only need one key). To access all of the TMDB developer features, use their developer portal: https://developers.themoviedb.org/3/getting-started/introduction. Once you have signed in to TMDB, you will see a profile icon next to the search icon in the upper right hand corner. Click on that profile icon and it will bring up a menu. Choose “Settings”. On the settings page, there is an option on the left called “API”. Click that. You will see a list of all “Apps” that you have created. For an API, an App is a program that you are writing that needs permission to access the API. As a developer, you can create more than one app (if you want). Most likely, you have no apps there right now. Click on “Create” to create a new “App” for the program we are writing, and then choose “Developer” option. Accept the terms of service, and then TMDB will then present you with a form about that app that asks you for a lot of information. Fill it the form – give your app a name, provide a description, etc. You can use this website (http://mi250.dev) for the required website. Make it a personal app. Once you create the app, you will be taken to the App page that shows the information you just submitted. On that page you should see the API key and the access token. These keys identify which app you are using, so TMDB (the company) can tell which program’s API access is being used. Copy and paste the API key into the appropriate place at the top of movies.py. Once you’ve done this, you have everything ready to start access TMDB’s API. Let’s test it. Run the program “movies.py” with your API key. If you get an API key error, then it didn’t work. If you get a bunch of information about a movie, then it worked! . Congrats! You now can access TMDB with a program! . Exercise 12: Pull out important movie information . When you run “movies.py”, the TMDB API returns a data structure – a complicated dictionary that contains lots of information about the movie. Right now, all the program does is print out the whole dictionary. While this has some useful information, it also prints out a ton of information that isn’t needed. Let’s improve our movie information program by only having it print out the important information. Modify “movies.py” to only print out the title, tagline, and overview (in that order): . Spider-Man: Across the Spider-Verse It's how you wear the mask that matters. -------------- After reuniting with Gwen Stacy, Brooklyn’s full-time, friendly neighborhood Spider-Man is catapulted across the Multiverse, where he encounters the Spider Society, a team of Spider-People charged with protecting the Multiverse’s very existence. But when the heroes clash on how to handle a new threat, Miles finds himself pitted against the other Spiders and must set out on his own to save those he loves most. Exercise 13: Print out the genres also . Now modify your movie program to also print out the movie’s genres. Notice that a movie can be in more than one genre, and that TMDB gives you the genre in a list. You’ll have to use a for loop to loop through that list and print out the name of each genre: . Spider-Man: Across the Spider-Verse It's how you wear the mask that matters. -------------- After reuniting with Gwen Stacy, Brooklyn’s full-time, friendly neighborhood Spider-Man is catapulted across the Multiverse, where he encounters the Spider Society, a team of Spider-People charged with protecting the Multiverse’s very existence. But when the heroes clash on how to handle a new threat, Miles finds himself pitted against the other Spiders and must set out on his own to save those he loves most. Genres: - Animation - Action - Adventure - Science Fiction . Exercise 14: Print out the stars also . Next, we are going to modify out movie program to get the list of people who starred in the movie and print out their names. Notice that the data we get back from TMDB doesn’t actually include the names of any of the actors (the ‘cast’) in the movie. Instead, we are going to need to make a second request of the API. Copy and paste the code that makes the API request and change the URL to instead use the movie_credits URL. Look closely at that URL; it is the word movie followed by the ID number of the movie (569094) we want, followed by the word credits. This should give you a second set of results. It has two entries: cast is a list of actors in the movie and crew is a list of the production crew of the movie. We only want to print out the cast for this exercise. Beneath the rest of the movie info, print the names of the cast members (at least the first 5 or 10): . Spider-Man: Across the Spider-Verse It's how you wear the mask that matters. -------------- After reuniting with Gwen Stacy, Brooklyn’s full-time, friendly neighborhood Spider-Man is catapulted across the Multiverse, where he encounters the Spider Society, a team of Spider-People charged with protecting the Multiverse’s very existence. But when the heroes clash on how to handle a new threat, Miles finds himself pitted against the other Spiders and must set out on his own to save those he loves most. Genres: - Animation - Action - Adventure - Science Fiction Cast: - Shameik Moore - Hailee Steinfeld - Jason Schwartzman - Oscar Isaac - Brian Tyree Henry ... Hint: You will probably need to change the printing code back to just pretty print the dictionary returned by the credits API so you can see what it looks like. Hint 2: The credits request returns a LOT of information. So much that PowerShell or Terminal might not be able to display it all; when you scroll back you might not get all the way back to the beginning. To deal with this, you can limit how deep into the data structure you pretty print. pprint(info, depth=1) only prints the top level dictionary. pprint(info, depth=2) prints the top level and one level underneath it. That can help you see parts of the dictionary when the data structure is REALLY big. Note also that PowerShell or Terminal will print more than the terminal inside VS Code will. Exercise 15: Change to a Different Movie . Let’s change our program to request information about a different movie. Hopefully this should be pretty easy. Let’s get information about the movie with TMDB ID number 438631. What movie is that? . Exercise 16: Searching the Database . For all of the previous exercises, you need to know the exact movie ID number in order to get information about a movie. That isn’t all that helpful if you don’t already know the ID numbers. So instead, we can search the database by name. To do that, we need to use the API slightly different. We need to specify a search query. We do that as a parameter to the API call. We are already passing one parameter – our api_key. We need to add a second parameter called query by adding it as an additional item in the parameter dictionary. We can then use it to search for a movie by name. parameter = {\"api_key\": api_key, \"query\": \"Spider-Man\"} result_json = requests.get(movie_search, parameter) . For this exercise, create a new program – call it search.py. Make your program to search TMDB for movies with the word “Spider-Man” in the title. You can and should copy code from your movies.py program as needed. Hint: You will probably need to change the printing code back to just pretty print the resulting dictionary so you can see what it looks like, since the search results dictionary looks different than the movie dictionary or the credits dictionary. ",
    "url": "/labs/requests.html#apis-with-authentication",
    "relUrl": "/labs/requests.html#apis-with-authentication"
  },"221": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "Challenge 1: Print Information About the Top Search Result . When you search for a movie by name using the search API, most likely the first result is the movie you were looking for. Let’s assume that it is. Combine the results of your last two programs / exercises. Search for the movie “Harry Potter”. The first movie in the list of results is probably the first Harry Potter movie. In the dictionary that you get back from the API, you should be able to find the ID number of that movie. Then fill that ID number in to the URLs to get the movie name, tagline, and overview, and also into the URL to get the cast. Print out all of that information in a human-readable form like you did in exercise 11. This program in total should make 3 API queries in total: search, movie, and credits. Challenge 2: Movie Search Program (aka user input) . Take the program you wrote for challenge 1, and modify it to accept the search query as an input. That is, your program should ask the user what movie they want to know about. It will then search TMDB for that movie. It will assume that the first result is the movie the user is looking for, and remember the ID number for that movie. Then it will use the API to get inforamtion about the movie such as its full name, tagline, overview, and list of stars, and print out all of that information. This is creating a movie search tool. You type in the name of a movie, and is prints out a bunch of information about that movie. Challenge 3: Better Movie Search Program . This builds on Challenge 2. Modify your program so that it prints out the movie titles for the top (5? 10? 20?) results of the search and allow the user to choose the movie they want. Then print out ,more information about the movie they choose. ",
    "url": "/labs/requests.html#challenges",
    "relUrl": "/labs/requests.html#challenges"
  },"222": {
    "doc": "Lab",
    "title": "Lab",
    "content": "So far, we’ve been creating our own content to use in programs. We’ve been writing out stories and storing them as strings, or storing structure data in dictionaries, or putting text data in files and bringing it in to Python. For structured data, we’ve been writing it ourselves. But you may want to write a program that uses large amounts of structured data that already exists out in the world. A large number of people, organizations, and companies that have their own data make their data available for public use. The U.S. government, for example, makes large amounts of data about the weather and the census and all sorts of things freely available to anyone who wants to use it. Some companies do this as well: Google Maps has a whole lot of map and location data that people can use to build their own map-based programs (though Google charges money in exchange for their data). How do people access this data? One way is to use an API, short for “application program interface”. An API is a middle man that sits between the data and programs that use the data. People or organizations or companies create the API so that people who want to use their data have a way to access it via a programming language like Python. Today we’re going to practice accessing data that’s out there in the world by using Python to talk to APIs. ",
    "url": "/labs/requests.html",
    "relUrl": "/labs/requests.html"
  },"223": {
    "doc": "Readings",
    "title": "Readings",
    "content": ". | Think Python: Functions | Automate the Boring Stuff: Functions – Stop reading at “Local and Global Scope” | . Yes, you read these a couple weeks ago. Now that you’ve had some practice with functions, you will learn new things when you read these articles again. Functions are one of the most important concepts in programming. This time through, specifically focus on the ideas of “parameters” and “return values”. Also read: . | Think Python: Fruitful Functions – Only read section 6.1 on return values | . ",
    "url": "/readings/revisiting_functions.html",
    "relUrl": "/readings/revisiting_functions.html"
  },"224": {
    "doc": "Readings",
    "title": "Summary",
    "content": "So far we’ve mainly used functions as a way to simplify code and to allow it to be easily repeated. But functions can be more interesting than that. They can accept parameters that change how the function works, and can also return values. As you read about these features of functions, try to understand how you might use them. Summary prompt: Summarize 1) what is a parameter to a function and when might you want to use one; and 2) what is a return value from a function and when might you want to use one? . ",
    "url": "/readings/revisiting_functions.html#summary",
    "relUrl": "/readings/revisiting_functions.html#summary"
  },"225": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Tuesday. ",
    "url": "/readings/revisiting_functions.html#question",
    "relUrl": "/readings/revisiting_functions.html#question"
  },"226": {
    "doc": "Schedule",
    "title": "Course Schedule",
    "content": "| Week | Topic / Readings | Lab | Studio | Homework | . | 1 (Jan 8 / 10) | Course Introduction | Intro to Class | Getting Started with Python | | . | 2 (Jan 15 / 17) | Variables, Flow | NO CLASS - MLK day | Control Flow (lab) | | . | 3 (Jan 22 / 24) | Version Control | Git and GitLab | Choose Your Own Adventure | | . | 4 (Jan 29 / 31) | Loops and Variables | Counting and Loops | Flashcards | 1 - Google Search | . | 5 (Feb 5 / 7) | Drawing | Turtle Graphics | Country Flag | | . | 6 (Feb 12 / 14) | Lists and Randomness | | | | . | 7 (Feb 19 / 21) | Functions | | | 2 - Error Messages | . | Break (Feb 26 / 28) | Spring Break | NO CLASS | NO CLASS | | . | 8 (Mar 4 / 6) | Dictionaries | | | | . | 9 (Mar 11 / 13) | Modules | | | | . | 10 (Mar 18 / 20) | Revisiting Functions | | | | . | 11 (Mar 25 / 27) | Reading Code | | | | . | 12 (Apr 1 / 3) | Files | | | | . | 13 (Apr 8 / 10) | APIs | | | | . | 14 (Apr 15 / 17) | Reflection | | | | . ",
    "url": "/schedule.html#course-schedule",
    "relUrl": "/schedule.html#course-schedule"
  },"227": {
    "doc": "Schedule",
    "title": "Schedule",
    "content": " ",
    "url": "/schedule.html",
    "relUrl": "/schedule.html"
  },"228": {
    "doc": "Taking screenshots",
    "title": "Mac OS",
    "content": "Full screen: cmd + shift + 3 Your screen will flash and the screenshot will automatically save. Portion of screen: cmd + shift + 5 Your cursor will look like a crosshair. Click and drag your mouse to select the part of the screen you want to screenshot. When you let go, the screenshot will save. Screenshots usually save to the desktop. ",
    "url": "/reference/screenshots.html#mac-os",
    "relUrl": "/reference/screenshots.html#mac-os"
  },"229": {
    "doc": "Taking screenshots",
    "title": "Windows",
    "content": "Full screen: Windows key + Print Screen (PrtScn) Your screen will flash and the screenshot will automatically save. Portion of screen: open the built-in Snipping Tool with Windows key + Shift + S. Your screen will go dark and your cursor will look like a plus sign (+). Click and drag your mouse to select the part of the screen you want to capture. Screenshots usually save to Pictures -&gt; Screenshots. You can also use the Snipping Tool to take full screen screenshots, to annotate screenshots, and to specify where you want your screenshot to be saved. Search for “snipping tool” using the search bar next to the Windows logo to find and open the application. ",
    "url": "/reference/screenshots.html#windows",
    "relUrl": "/reference/screenshots.html#windows"
  },"230": {
    "doc": "Taking screenshots",
    "title": "Taking screenshots",
    "content": "Each week, students will need to turn in screenshots of the work they’ve done in class. The best times to take screenshots are: . | For labs: after each completed exercise | For studios: at the end of the studio | . Screenshots should show the code working. If it’s just code, take a screenshot of the code running successfully in command line (Terminal on Mac or Powershell on Windows). If it’s visual (using Turtle), take a screenshot of the turtle window after the code has drawn. ",
    "url": "/reference/screenshots.html",
    "relUrl": "/reference/screenshots.html"
  },"231": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. One function per emoji . Functions work best when they comprise a logical, coherent thing. You want each function to make sense on its own, and to do one “logical” thing. When functions try to do too much in one function, it gets confusing. So, you can create a function smiley() that draws a smiley face emoji. It should do everything that is needed for the smiley face. Also, you don’t want it to do things other than what the name implies. So, a smiley() function should only draw a smiley face. It shouldn’t also move the turtle around to other places, or change the turtle colors, or anything like that. If the function has side effects, then it gets confusing when you should use the function and when you shouldn’t. Try to avoid your functions having side effects. Create your own emoji . Everyone knows the standard smiley face emoji. People have come up with hundreds of new emoji. I encourage you to create your own emoji that capture ideas or feelings that you have! You can use an existing emoji if you want, but it is much more fun to create your own emoji. Keep your emoji simple . Emoji are supposed to be simple pictograms. Work hard to keep them simple. Don’t spend hours tweaking your emoji to get it just right. Start simple and get the basic emoji working. You can always make it more complex later. Besides, sometimes simple things can convey ideas more effectively than complex things. Divide and conquer . Split up the emoji between team members. One of the nice things about functions is that it is really easy to divide up the work. One person can work on one function, and another person can work on the other. This makes it easy to divide up the work in a reasonable, logical way. Also, if you are each working on different functions, git can usually merge the changes easily. Just make sure that you are all working in a clone of the same git repository. If you want to avoid potential git conflicts, you can also each create your own file for each emoji and assign one team member to combine the code into a single file towards the end of class. Finish each emoji at the start . Remember for the bar() function in the lab, the code was set up to draw a bar, then move the turtle in advance of the next bar, then draw the next bar. But this only worked well if the turtle finished drawing the bar in the same place and orientation where it started from. So if the turtle started at the top left of the bar and facing to the right, it should be at the position both at the start of the bar() function and at the end. You’ll want to do something similar with emojis - draw an emoji, move in prep to draw the next emoji, then draw the next emoji. It’s much easier to do this if, in each emoji function, you include code so that the turtle ends up exactly where it started after the emoji is done drawing. Then the code to move to where the next emoji starts can be the same between every emoji. Following this principle makes it much easier to collaborate, too! If everyone in your group is working on a different emoji, it’s easier to put them together into one program at the end if you know that each emoji drawing will end where it started. Support functions . In addition to having a separate function for each emoji, you might want to create a function or two to help with other things that you need to do. For example, could you create a next() function that moves the turtle to the right and gets it ready to draw the next emoji? . Look for common features . As you work on your emoji, you might notice that you have common features. For example, if you are drawing both a smiley face and a frowning face, both of them will have the same circular face. That is an opportunity to create a support function. You could in this case create a function that draws a blank face (a circle of the appropriate color). Then your smiley function could call the blank face, and then draw the eyes and mouth. Your frowning face could also call the blank face function first, and then draw a different eyes and mouth. Creating support functions for common features like this is a great way to avoid lots of copy-and-pasting of code. It also makes it easier if you want to change something later on. If you want to change the skin color, for example, you only need to change it in the one place (blank face), rather than find all the places in your code that have a skin color. ",
    "url": "/studios/speak_in_emoji.html#advice",
    "relUrl": "/studios/speak_in_emoji.html#advice"
  },"232": {
    "doc": "Studio",
    "title": "Challenge",
    "content": "If you get the basic emoji sentence working and you have time left in the studio today, try this challenge: . The emoji sentence that your program draws is “hard-coded” – it always draws the same sentence (the same emoji in the same order) every time. Instead of hard coding a sentence, modify your program to allow the user to specify which emoji should be drawn in which order. For example, your program could work like this: . This program has the following emoji: 1. Smiley face 2. Frowney face 3. Winking face 4. Sticking out tongue (enter 0 to stop) Which emoji should be first? 1 Which emoji should be next? 1 Which emoji should be next? 2 Which emoji should be next? 4 Which emoji should be next? 3 Which emoji should be next? 0 . And then it prints out the emoji sentence specified by the user. ",
    "url": "/studios/speak_in_emoji.html#challenge",
    "relUrl": "/studios/speak_in_emoji.html#challenge"
  },"233": {
    "doc": "Studio",
    "title": "Studio",
    "content": "Emoji are graphical representations of ideas and concepts – basically, they are pictograms. It is possible to convey complex concepts and ideas using nothing but emoji. Smiley face emoji are particularly interesting because they often convey emotions better than words do. Emoji are especially powerful when you put one after the other to form emoji “sentences”. Your goal for today is to write a set of functions that draw emoji using turtle graphics. Each function should draw one emoji. Then use those functions to draw out an emoji “sentence” on the screen that conveys some complex feeling or idea. As usual, work in groups of 2-4 people. ",
    "url": "/studios/speak_in_emoji.html",
    "relUrl": "/studios/speak_in_emoji.html"
  },"234": {
    "doc": "Lab",
    "title": "Lab",
    "content": "This week is spring break. There are no classes this week. ",
    "url": "/labs/springbreak.html",
    "relUrl": "/labs/springbreak.html"
  },"235": {
    "doc": "Studio",
    "title": "Studio",
    "content": "This week is spring break. There are no classes this week. ",
    "url": "/studios/springbreak.html",
    "relUrl": "/studios/springbreak.html"
  },"236": {
    "doc": "Readings",
    "title": "Readings",
    "content": "This week is spring break. There are no classes this week. ",
    "url": "/readings/springbreak.html",
    "relUrl": "/readings/springbreak.html"
  },"237": {
    "doc": "Spring Break",
    "title": "Spring Break",
    "content": " ",
    "url": "/week/springbreak.html",
    "relUrl": "/week/springbreak.html"
  },"238": {
    "doc": "Studio",
    "title": "Advice",
    "content": "Here’s some advice that might help you out. But you don’t have to take my advice; do whatever you want. Take inspiration from existing designs . There are lots of social media platforms out there, and nearly all of them have the concept of a ‘post’. But posts on each platform have different kinds of data associated with them. Look at what posts look like and what kinds of data are displayed for each post on the platforms you use to get an idea of what kinds of data you might want to include. Also look at how posts are displayed – what size fonts are used for different things? Where is the post image displayed in relation to the text around it? How big is an average post in terms of width or height? . Design the UI on paper first . Wireframing is common technique in UX design to quickly sketch out how a webpage or app should look, or how a piece of it could look. On paper (or a whiteboard), wireframing is a quick and dirty way to figure out where elements should be placed relative to one another. It will probably be easier and faster to code the layout of your post in Turtle if you already have a visual guide for what the post should look like to refer to. Wireframes can also include information like how many pixels high or wide something should be - remember forward() using pixels to measure how far the Turtle should move. Font size also relates directly to pixels - a 12 point font is 12 pixels tall. Split up the work . There are two parts to this project: putting together a dictionary structure that works with different kinds of data, and drawing that data using Turtle. It might make sense to split your group up so that 1-2 people work on the data part and 1-2 people work on the Turtle part. The people working on the Turtle part can hard-code data that can then be replaced with data from the dictionary later on. Test with different data . Make sure that the structure you’ve created works with different sets of data. You’ll probably want to create multiple dictionaries for the purposes of testing. Each dictionary should have the same structure (the same keys), but different data (different keys). This can help you determine the data types you need associated with each key – for example, there can only be one post title, so you can use a string for the value. But there might be multiple hashtags associated with a post, which means you’d need a list to store them. It can help to write out a template of what the dictionary structure should look like so that when you create new dictionaries to store different sets of data, they’ll all have the same structure. For example: . post_title: string hashtags: list post_date: integer num_likes: integer . Use functions . Just like you used a function to print out pizza data in the lab, you could write a function that draws out post data using Turtle for this. Putting all of the Turtle code into a function can make it much easier to test your drawing with different sets of data – you can just replace the dictionary variable when you use the function with one that contains different data. For example, you could write a function called display_post() that does the work of drawing out the data using Turtle and takes one parameter, a dictionary. post_1 could be a dictionary containing the data for a post. post_2 could be a dictionary with the exact same structure, but with different data. To test your function with different sets of data, all you’d have to do is plug different dictionaries into the function – display_post(post_1) would display a post using the data in the post_1 dictionary. display_post(post_2) would do the same thing, but with the data in the post_2 dictionary. It’s very common to have different sets of data that you use to test to make sure a program works the way you expect; it’s good to have an easy way to do this. Functions can be very useful for testing purposes. Import images into Turtle . Turtle allows you to import existing images into the Turtle drawing window, so long as those images are in .gif format. You can convert most images to .gif using Paint (Windows) or Preview (Mac). Open the image, and then go to File &gt; Save As and choose GIF under Format. Note that Turtle won’t display the animation in animated gifs. Social media platforms do work behind the scenes to make sure all of the images that display in posts display at the same size. You might want to change the size of the images you use to specific pixel dimensions – like make all images 150x150 pixels – so that you can plan your post design around those specific dimensions. It’s harder to plan consistent designs when the design elements aren’t consistent. To display an image in Turtle, you need to add it as a shape first, and then call the shape. addshape(\"ship.gif\") shape(\"ship.gif\") . Make sure the image file is in the same folder as the Python program that’s trying to use it. Note: if you’re running the Python program directly through VS Code, you’ll need to navigate to the right folder in VS Code’s terminal first or the program won’t be able to find the image and will give you an error. What happens if data is missing? . For most types of social media posts, certain kinds of data are optional. For example, you can post on the platform formerly known as Twitter without including any images. The user interface adjusts the positioning of all of the elements of the post depending on whether there’s an image or not. You can use if statements to test for whether data exists. A very basic version might look like this: . if dict['image'] == \"\": &lt;don't move the turtle&gt; else: &lt;insert image&gt; &lt;move turtle so it's below the image&gt; . This code assumes that if there is no image associated with the image key in the dictionary, there will be an empty string (\"\") in its place. ",
    "url": "/studios/structured_UI.html#advice",
    "relUrl": "/studios/structured_UI.html#advice"
  },"239": {
    "doc": "Studio",
    "title": "Challenge",
    "content": "If you’ve created a good structure and can use Turtle to print out a nicely formatted user interface for the post each time, great! Next step: make it interactive. Instead of hard-coding the data for the post, collect it from the user. Exercises 6 and 7 from the dictionary lab might be useful. Also remember you can use textinput() in order to collect user input through the Turtle window rather than through command line. Remember when you collect user input, it all comes into Python as strings. You may need to convert the strings into other things so that they work with your dictionary structure. If you want the user to be able to enter multiple hashtags to associate with their post, for example, you could use a loop that keeps asking the user to enter a hashtag until the user tells it to stop and then put all of the hashtags then enter into a list with .append() . If your post structure uses images, there’s no easy way to upload images to Turtle like there is on a real social media platform. But you can ask the user to input the name of the image file they want to use for the post. ",
    "url": "/studios/structured_UI.html#challenge",
    "relUrl": "/studios/structured_UI.html#challenge"
  },"240": {
    "doc": "Studio",
    "title": "Studio",
    "content": "Imagine a post on social media, such as a Twitter (now X) post or an Instagram post. The post itself is actually a complex object that has a lot of information – who posted it, the text content of the post, an optional picture, hashtags, the date and time when it was posted, etc. Each post on a given platform has the same structure, and is displayed the same way. But the content of each post – the data that makes up the post – is different. Dictionaries work really well for structured objects like social media posts. For today’s studio, you’ll be designing your own social media post format with a UI (user interface) for displaying the post. Your program should: . | have a dictionary structure for a post that stores all of the data and metadata associated with that post. | use Turtle to visually display all of the information in a post in a nicely formatted way. (You only have to display one post.) | . It is up to you how you want the post to be structured, and what kinds of data it will have in it or associated with it. You can base your post design off of an existing social media platform, or you can create your own. Be creative! The only rule is that all of the data associated with a single post has to be stored in a single variable – which means in a dictionary. As per usual, work in groups of 2-4. ",
    "url": "/studios/structured_UI.html",
    "relUrl": "/studios/structured_UI.html"
  },"241": {
    "doc": "Syllabus",
    "title": "MI 250: Intro to Applied Programming - Syllabus",
    "content": ". | Spring 2024 Time and Location | Instructors | Course Description | Required Technology . | In-class technology usage | . | Course Structure . | Pair Programming | . | Coursework . | Summary + Questions | Labs | Studios | Homework | Final project | Turning in work | Honors option | . | Coursework Expectations and Grading . | Grading scale | . | Communication Policies . | Announcements | . | Attendance / Absence / Lateness Policy . | Late Homework | Illness | Exceptions | . | Other Policies . | Accommodations for disabilities | Spartan Code of Honor | Academic honesty | Mental health | Technical assistance | Tolerance and civility | . | . ",
    "url": "/syllabus.html#mi-250-intro-to-applied-programming---syllabus",
    "relUrl": "/syllabus.html#mi-250-intro-to-applied-programming---syllabus"
  },"242": {
    "doc": "Syllabus",
    "title": "Spring 2024 Time and Location",
    "content": "Mondays and Wednesdays, 3:00-4:50pm Holden Hall C131 Synchronous, in person – no hybrid options available . ",
    "url": "/syllabus.html#spring-2024-time-and-location",
    "relUrl": "/syllabus.html#spring-2024-time-and-location"
  },"243": {
    "doc": "Syllabus",
    "title": "Instructors",
    "content": "Instructor: Caitlin Geier (she/her/hers) Email: geierac@msu.edu Office hours: Drop-in Mondays from 1:30-2:30pm in office or on Zoom, or by appointment Office: Room 525, Communication Arts and Sciences . Course assistant: Jack Waier Email: waierjac@msu.edu Office hours: by appointment - email or talk to after class to find a time . ",
    "url": "/syllabus.html#instructors",
    "relUrl": "/syllabus.html#instructors"
  },"244": {
    "doc": "Syllabus",
    "title": "Course Description",
    "content": "This course is an undergraduate course aimed at students who have little to no programming experience and who don’t intend to be programmers. There are many roles in the tech industry today which don’t involve programming, but which work alongside programmers. The goals of this course are to teach students enough to be “dangerous” at programming, to learn about computers and programming environments, and to practice skills around talking about programming, co-learning, and collaboration. These skills are incredibly useful not only for programmers, but also for other media and technology roles, such as user experience, graphic design, game design, digital storytelling, data analytics, and more. This course is NOT appropriate for students with programming experience; for example, students who have taken CSE 231 or similar courses in the past. This is a required course for multiple majors and minors in media and information, but the requirement can be waived in many cases for students who have taken other programming courses or have demonstrated experience with programming. ",
    "url": "/syllabus.html#course-description",
    "relUrl": "/syllabus.html#course-description"
  },"245": {
    "doc": "Syllabus",
    "title": "Required Technology",
    "content": "All students are REQUIRED to bring a laptop computer to class running either MacOS or Windows. Linux is not supported in this class. Every student will be creating a development environment on their own computer in the first 2 weeks of class. Every student will be required to practice writing and running code on their own computers. If you need a new computer, the MSU Tech Store sells both Apple and Windows laptops at discounted prices for students. If your laptop breaks or is temporarily unavailable during the semester, talk with Caitlin about accommodations. MSU also has a Laptop Loan program which students who have a temporary need for a laptop can apply for. All course materials can be found on: . | The course website (this website, https://mi250.dev) | D2L (d2l.msu.edu) | Gitlab (gitlab.msu.edu) | . You will not be required to purchase any software for this course. The course will be using the Python programming language, Git, and related tools, all of which are open source and/or freely available. You do not need to install anything ahead of time – we will be doing all of that work in class. In-class technology usage . Students are expected to use their laptops in class for in-class work, and should bring their laptops to every class. Smartphone and tablet usage is fine so long as they are being used for class purposes (like taking notes, looking things up, etc). Phone calls in class are prohibited. If you need to make or receive a phone call, step outside of the classroom first. Talking on your phone in class is disrespectful to the instructors and to your classmates and will result in a lower grade for the day. ",
    "url": "/syllabus.html#required-technology",
    "relUrl": "/syllabus.html#required-technology"
  },"246": {
    "doc": "Syllabus",
    "title": "Course Structure",
    "content": "This course has 5 main elements: . | Summary+Questions: reading / watching content and summarizing / asking questions about content in ways that relate to students’ own lives (every week, due before the first class of the week). | Labs: set exercises for learning and practicing concepts in programming, done in class with partners (usually on Mondays) | Studios: open-ended creative exercises for practicing and applying programming concepts, done in class in groups of 2-3 (usually on Wednesdays) | Homework: larger homework assignments to learn/practice skills and think about programming in practice (every 2-3 weeks, 5 in total) | Final project: a two week project at the end of the semester started in class and due during the class’s final exam period (8pm, Wednesday April 24). | . This course does NOT have any quizzes or exams. Aside from the final project, which students have the option of working on outside of class, all programming work will be done IN CLASS. It’s therefore very important to attend class as much as possible. Pair Programming . Students in this course will practice a concept called pair programming, which originated with programmers at tech companies. Pair programming is based on the idea of “two programmers, one computer:” two programmers work together on the same code using one computer between them. One person is the driver: they are the person using the computer and typing the code. The other person is the observer, also known as the navigator: they do the bigger picture thinking, look up relevant information, and help spot mistakes. In this class, students will switch roles on a regular basis. Students who participate in pair programming get stuck and frustrated less often than students working by themselves and are also able to practice teamwork and communication – which is why we practice it in this class! . In labs: students will be randomly assigned in pairs at the beginning of class. You’ll likely work with someone different every week. You will practice pair programming for every lab. In studios: students can choose who they work with and can work in groups no smaller than 2 people and no larger than 3. We encourage you to practice pair programming in whatever way makes sense for your group rather than all working on your own computers. You should be talking with your group members frequently. ",
    "url": "/syllabus.html#course-structure",
    "relUrl": "/syllabus.html#course-structure"
  },"247": {
    "doc": "Syllabus",
    "title": "Coursework",
    "content": "Summary + Questions . Every week students will be asked to read or watch a few articles and videos about programming and to submit a “Summary + Question” on D2L which is due before the first class of that week (usually Monday). These are under Quizzes on D2L and are labeled by week and are graded based on the check/check-plus/check-minus rubric. This should take you between 30 minutes and 1 hour each week. All readings and videos are available for free and are linked on the readings page for each week (found in the Topics/Readings column on the course schedule). You will not be required to purchase any textbooks or other materials to complete the summary+questions. Summary: one paragraph max (at least 3 sentences). These will always be guided summaries rather than just repeating facts. There will be a prompt on the readings page for each week which will usually ask you to explain what you’ve learned in your own words and to apply it to your own experiences. If your summary is too short or too long, or doesn’t answer the prompt, you may be marked down for it. Question: one question relating to that week’s topic. The question can be about one of these things: . | Confusion: something you didn’t understand and want clarification on | Curiosity: something you want to learn more about | Connection: apply one of the concepts from the week’s topic to your own life or work (this might be a statement rather than a question; that’s okay) | . If your summary+question is missing either a summary or a question, OR if it’s turned in late (after class starts), you will get a 0. We use your summaries and questions to understand what students are having trouble with so we can talk about it at the beginning of class on Mondays, so it’s important to turn them in on time. Labs . Labs will usually be on Mondays. Labs cover one or more specific concepts relating to the topic of the week; their goal is to give you a chance to put the concepts in practice. Programming is very hard to learn through reading alone, which is why we practice it in class with partners. Each lab has a series of small, structured exercises that you and your partner will go through together using pair programming. Partners for labs are assigned randomly at the beginning of class. Labs are graded using the check/check-plus/check-minus system. Grades are based on: . | Effort (did you work on the lab for the entire class?) | Attendance (did you attend the whole class OR did you complete all of the exercises satisfactorily?) | Teamwork (did you help others?) | . Labs are NOT graded based on how much you complete or how “good” your code is. Studios . Studios will usually take place on Wednesdays. Unlike labs, studios are more open-ended exercises that allow you to practice – and be creative with – the concepts you learned in the lab that week and over the course of the semester. Studios are done in groups of 2-3 people. You can choose who you work with for studios. Studios are also graded using the check/check-plus/check-minus system. Grades are based on: . | Effort (did you work on the studio for the entire class?) | Attendance (did you attend the whole class?) | Teamwork (did you collaborate consistently with your group?) | . Studios are NOT graded on how “good” your code is or whether everything works as intended at the end of class. Homework . Throughout the semester (every 2 to 3 weeks), students will be asked to complete homework assignments in addition to the weekly summary+question. These are longer form assignments and will not generally involve writing code. The goal of them is to give you skills that will help you in the labs and studios, and to make you think more about how programming fits into your life and into the world more broadly. Homework assignment schedule: . | # | Topic | Due | . | HW 1 | Google Search | Week 4 | . | HW 2 | Error Messages | Week 6 | . | HW 3 | Jobs | Week 8 | . | HW 4 | ChatGPT | Week 11 | . | HW 5 | Ethics | Week 13 | . All homework assignments will be due on Wednesdays before the start of class. Instructions for each assignment will be on the course website and will be available at least 2 weeks before the due date. You’ll turn the assignments in on D2L. Each assignment will likely take 1-2 hours to complete. You will be required to complete 4 homework assignments throughout the semester. If you complete all 5, the assignment with the lowest grade will be counted as extra credit (between 1.75% and 2.25% added on top of your final grade). Homework is also graded using the check/check-plus/check-minus system. Grades are based on: . | Thoroughness (did you follow all of the instructions / do all of the tasks?) | Effort (did you make an honest attempt at doing the assignment?) | . Final project . The final project is a long-form studio done with a group starting the last week of the semester. Unlike a normal studio, students will be expected to work on the same project over multiple class periods (the full last week of class will be devoted to this project) and also outside of class if the project can’t be completed during class. Final projects are due at the end of the final exam period: 8pm Wednesday, April 24, 2024. There is no final exam for this class. Turning in work . In-class work will be turned in via a combination of D2L and Gitlab. You will turn in homework individually on D2L. Work from in class activities will be turned in by at least one person in each partnership/group through D2L (screenshots and other evidence of work) and Gitlab (code) at the end of each class. Honors option . This course does have an honors option for students in the honors college. If you want to do an honors option, talk with Caitlin within the first two weeks of class. ",
    "url": "/syllabus.html#coursework",
    "relUrl": "/syllabus.html#coursework"
  },"248": {
    "doc": "Syllabus",
    "title": "Coursework Expectations and Grading",
    "content": "Grades in this class are mostly based on attending class and making an honest effort to engage with the material, both in and outside of class. The final project is the only work in which students will be graded on the programming skills they’ve developed over the semester. Grades are broken down in this way: . | Summary + question | 15% | . | In class exercises (labs and studios) | 60% | . | Homework | 10% | . | Final project | 15% | . Grades will be input on D2L and are calculated continuously – you will always know where your grade stands for the class by looking at D2L. Most all grades (except for the final project) are based on a check / check plus / check minus rubric: . | Check = 9/10. You showed up and did the work. This is the base grade for everybody. (You didn’t do anything wrong if you get a check!) | Check plus = 10/10. You showed up, did the work, and impressed us: maybe you worked particularly well with your partner that day, had a particularly insightful question, or did a particularly thorough job on the homework. | Check minus = 7/10. You showed up, but didn’t honestly engage with the work. Maybe you were late to class with no excuse, or maybe you spent half the class cruising Insta or not talking with your partner or group at all. Maybe you put the bare minimum of effort into the summary+question or the homework. | . Final projects will be graded in two parts: . | Normal studio requirements – graded based on effort, attendance, and participation during the two class periods in the final week of class | The content of the project – graded based on whether the program works as intended, and on a combination of demonstrating programming skills and creativity. | . A rubric for the final project will be released at the beginning of the final week of class. Grading scale . | 90% | 4.0 | . | 85% | 3.5 | . | 80% | 3.0 | . | 75% | 2.5 | . | 70% | 2.0 | . | 65% | 1.5 | . | 60% | 1.0 | . | Below 60% | 0.0 | . ",
    "url": "/syllabus.html#coursework-expectations-and-grading",
    "relUrl": "/syllabus.html#coursework-expectations-and-grading"
  },"249": {
    "doc": "Syllabus",
    "title": "Communication Policies",
    "content": "Caitlin and Jack are happy to respond to student questions after class, or via email. Caitlin also holds office hours on a weekly basis, both in person and on Zoom. Jack can also meet with students outside of class as needed - email him or ask him in class. If you have questions about anything course-related, please get in touch! . Email policy: we will respond to email within 24 hours on weekdays, or within 72 hours on weekends. Don’t expect us to see any email sent before or during class until after class has ended. Announcements . Announcements about the course will be posted on D2L. Make sure you have allowed D2L to send announcements to your MSU email. You can also have D2L emails forwarded to different email accounts - see instructions to do this in the MSU D2L documentation. ",
    "url": "/syllabus.html#communication-policies",
    "relUrl": "/syllabus.html#communication-policies"
  },"250": {
    "doc": "Syllabus",
    "title": "Attendance / Absence / Lateness Policy",
    "content": "This class is very heavily based on attendance and participation – it’s very important that you attend class every week as each week’s content builds on the previous week. If you miss too many classes, you WILL fall behind. It’s also very important to attend the ENTIRE class – arriving late or leaving early means you will have less time to practice coding, and it will make class more difficult for your partner / groupmates for the day. Your grade for the class will be reduced if you are late or leave early. That said, life happens. The 4 lowest grades for in class activities (labs and studios) will be dropped, as will the 2 lowest grades for summary+questions. Only 4 of the 5 homework assignments are required. You can miss up to two weeks of class total without it affecting your grade at all. You do not have to explain why you’re missing class to us. This policy covers the vast majority of absences you might need to take. Late Homework . Late summary+questions will not be accepted except in extenuating circumstances. Late homework will not be accepted except in extenuating circumstances (see below) OR by prior arrangement with the instructor. Illness . If you are sick with something contagious (like COVID or the flu), PLEASE PLEASE PLEASE be considerate of your instructors and classmates and STAY HOME! Remember you can miss up to 4 classes with no penalty and no excuse needed. For long-lasting illnesses, see “exceptions” below. If you have or think you might have COVID and aren’t sure what to do, see MSU’s COVID guidance page. If the instructor is sick, class may be cancelled. Exceptions . The “drop 4” policy for in class activities will cover nearly all absences for nearly all students. It is meant to be flexible. If you find yourself needing to miss more classes than that, we will try to work with you to help you keep up with the class. IF you are beyond 4 absences already AND any of the below circumstances apply, we may be able to exempt you from certain classes or homework. Talk to Caitlin first and foremost! . Note that missing more than two weeks of class will make it harder for you to keep up, and also harder for you to earn good grades because you won’t be able to participate as much in class. If you need to miss extra class, talk with Caitlin or Jack and we will help you determine what you might need to do to keep up with the class. All of the exceptions below will be taken into account if you go beyond 4 absences. If you know in advance that you need to miss a class for any of the below reasons, contact Caitlin as soon as possible. The more advance notice we have, the easier it will be for us to work with you. Adding the class late – if you added this class to your schedule at the end of the first week of the semester, you may have missed the first graded homework and the first graded in class activity. Talk to Caitlin as soon as possible to catch up on the work, and to be exempted from those activities. Illness lasting more than 2 weeks – COVID is still a thing, and there are all sorts of other illnesses people can have that affect their ability to attend class. Contact Caitlin as soon as possible to discuss potential accommodations and what kind of documentation may be necessary. Grief absences – If you have experienced the death of a family member or someone close to you, or you are experiencing emotional distress from a similar tragedy, you may request a grief absence. To request a grief absence, visit the Grief Absence Request Form found on the Student Information System under Resources –&gt; Grief Absence. See the grief absence policy for more information. Once your grief absence is approved, we will exempt you from the in-class activities for the approved dates. This means those classes won’t count towards your grade at all, and also won’t count as part of your 4 dropped grades. Religious holidays – If you wish to be absent from class to observe a religious holiday, please make arrangements in advance - ideally at least two weeks in advances. Absences for religious holidays will be treated as exempt, within reason. See MSU’s religious observance policy for more detail. Student athletes – If you must miss a class to participate in an officially-sanctioned athletic game, you must provide adequate advanced notice beforehand, such as a team schedule or written authorization from a coach or a university administrator. Required activity – If you must miss a class to participate in a university-sanctioned event, you must provide the instructor with adequate advance notice and written authorization from a university administrator. ",
    "url": "/syllabus.html#attendance--absence--lateness-policy",
    "relUrl": "/syllabus.html#attendance--absence--lateness-policy"
  },"251": {
    "doc": "Syllabus",
    "title": "Other Policies",
    "content": "Accommodations for disabilities . Michigan State University is committed to providing equal opportunity for participation in all programs, services and activities. Requests for accommodations by persons with disabilities may be made by contacting the Resource Center for Persons with Disabilities at 517-884-RCPD or on the web at rcpd.msu.edu. Once your eligibility for an accommodation has been determined, you will be issued a verified individual services accommodation (“VISA”) form. Please present this form to Caitlin in the first two weeks of the semester and/or two weeks prior to the accommodation date (test, project, etc). Requests received after this date will be honored whenever possible. Spartan Code of Honor . As a student at MSU, you will be expected to abide by the Spartan Code of Honor Academic Pledge: . “As a Spartan, I will strive to uphold values of the highest ethical standard. I will practice honesty in my work, foster honesty in my peers, and take pride in knowing that honor in ownership is worth more than grades. I will carry these values beyond my time as a student at Michigan State University, continuing the endeavor to build personal integrity in all that I do.” . See the Spartan handbook for more details. Academic honesty . Michigan State University and the Department of Media and Information both have policies about academic dishonesty. Basically, make sure that everything you turn in with your name on it is your own work, and don’t cheat or lie. If it feels like cheating, it probably is; if you are unsure please ask. Students caught cheating or plagiarizing will receive a 0 for the assignment and be reported to the university. Working together with other students in this class and other classes, however, is encouraged. Make sure that everything you turn in with your name on it is original work of yours. For classes that involve complex thinking and no right answers like this, we strongly encourage you to work together and ask each other for help. Indeed, this course requires you to work with others. Often when you have a problem or something confuses you, the best place to go for help is your colleagues who are also working on similar things. The Internet is also a fantastic source of information when you are stuck. Use these resources! However, make sure that you personally write and understand all of the work that you turn in. Directly copying text that you don’t understand from the Internet or from others is academically dishonest. Mental health . Mental health concerns or stressful events may lead to diminished academic performance or reduce a student’s ability to participate in daily activities. If you’re struggling, we encourage you to seek support. Services are available to assist you with addressing these and other concerns you may be experiencing. You can learn more about the broad range of confidential mental health services available on campus on the Counseling &amp; Psychiatric Services (CAPS) website. Technical assistance . Asking your peers in class and your instructor is a great source for technical assistance. This is particularly true with the technologies we are learning in class (python, git, etc.). For MSU-provided technologies, you can visit the MSU Help site, the Desire2Learn Help Site or email the MSU IT Service Desk. Tolerance and civility . MSU strives to build an academic community with living and learning environments that expects tolerance of viewpoints and civility toward others, whether at public forums, athletic events, in residential communities, classrooms or laboratories. We call upon all who participate in university events to promote tolerance and civil behavior and to hold themselves to high standards that reflect the university’s commitment to respect viewpoints that may be different from their own. Only by respecting individuals with diverse perspectives and ideas can we build an environment of civility that is conducive to advancing knowledge and transforming lives. ",
    "url": "/syllabus.html#other-policies",
    "relUrl": "/syllabus.html#other-policies"
  },"252": {
    "doc": "Syllabus",
    "title": "Syllabus",
    "content": " ",
    "url": "/syllabus.html",
    "relUrl": "/syllabus.html"
  },"253": {
    "doc": "Software Testing",
    "title": "Software Testing",
    "content": " ",
    "url": "/testing.html",
    "relUrl": "/testing.html"
  },"254": {
    "doc": "Software Testing",
    "title": "Exercise: What is a bug?",
    "content": "Software testing is the process of finding and eliminating bugs in software. Take a minute and write down your answer to the question “What is a bug?”. Go ahead; I’ll wait. Computer programs are written with goals in mind; the program is supposed to do something specific. A bug is anytime that the program doesn’t do that. That is, a bug is anytime there is a difference between what the program is supposed to do and what the program actually does. As computer programs get more complicated, so do the bugs. A simple computer program often only does one thing. If it does that then, then great; it works. When you make computer programs more complicated, they have to work in a wider variety of different settings. Different people might enter in different inputs. The program has to work with different types of data. The program has to work on different computers (Mac vs. Windows) with different size screens and other differences. Bugs may appear only in some circumstances but not others – it may work fine for you on your computer, but not for me on my computer. But still, that’s a big problem for me! (AND, also, a problem for you if you want me to pay you for the computer program….) . Fixing Bugs . When people write programs, they often think that they should try to write programs that don’t have bugs. But, that’s impossible! They also think that programs aren’t done until they are bug-free. That’s also impossible! Microsoft Windows shipped with millions of known bugs that were not fixed. People still bought it and use it on a regular basis. Fixing every bug is hard, and often not worth the time and effort. If a bug is any time what the program actually does is different than what the program is supposed to do, then there are two ways to fix a bug: . | Change what the program actually does. Modify the code so that the program does what it is supposed to do. | Change what the program is supposed to do. Change your idea of what the program is supposed to do and what kinds of things it can and can’t do. (and, if applicable, change the written specification) | . Both are entirely reasonable ways to fix a bug. Also, it is reasonable to choose to not fix a bug; just acknowledge that it exists but that it isn’t worth fixing. ",
    "url": "/testing.html#exercise-what-is-a-bug",
    "relUrl": "/testing.html#exercise-what-is-a-bug"
  },"255": {
    "doc": "Software Testing",
    "title": "Why Test?",
    "content": "Computer programs do not always work as the programmer intends them to. Often, I write code that I think does one thing, and then when I run it, I find out that it does something else. This is a very normal thing to happen, and every programmer experiences it on a daily basis. Testing is really an attempt to understand what your program actually does. Testing is a way to better understand the program that you’ve written and what it can and cannot do. Testing is the process of trying to find bugs. Testing does not necessarily involve fixing bugs. Instead, you test your program to try to learn about the bugs that exist. This gives you the information you need to decide whether it is worth fixing the bugs or not. Automated vs. Manual testing . There are two major ways of doing testing: manually testing the program by running it and entering inputs on your own, and automated testing by writing a 2nd program that tests your 1st one. You are already familiar with manual testing. You do it all the time. You write code, and then you run the code and see what happens. You have some idea in your head about what the program should do, and then you run the program and see what the program actually does. Often, this isn’t a very structured or formalized process, but you still do it all the time. You run your program over and over, adding code and trying different inputs, to see what happens. This is manual testing. It is possible, and not uncommon, to do more structured manual testing. Rather than just ad-hoc running your program, you could think carefully about what kinds of inputs your program might get, and then write down a list of possible inputs. Then you could think about, for each input, what should the program do? Write that down next to the input. Rather than having some vague notion about what the program should do, you now have explicitly written down the expected output. Now you can run the program multiple times, and see if what the program does matches what you wrote down that it should do. This structured, manual testing is quite common in the real world. Large companies pay people to run these structured manual tests and figure out if the program does what it is supposed to do. Some things, like user interfaces, are difficult to test automatically, and mostly are tested this way. However, running through these tests manually is hard and boring work – especially if you have to do it frequently. So, programmers often do what they are good at – they write a computer program to automatically run tests and check if the program does what it is supposed to do. Automated testing invovles using one computer program to test another, and is an extremely common way to do testing. As programs get bigger and bigger, automated testing becomes more important. Regression bugs: bugs that appear later, breaking previously working code. As you work on writing computer programs, one thing that you notice is that you change things in one place, and it affects other parts of the program. That is, it is possible (and common) that one part of the program works fine NOW, but later on you change something else and now that part no longer works. When this happens, it is called a “regression bug”. Regression bugs are really nasty, because they mean that you tested the program and it worked, but then later on it stopped working. The only way to catch regression bugs is to re-run all of your tests again, to make sure that the program still does everything it is supposed to. But doing that is a real pain. That’s one of the big reasons that we automate tests; it is much easier to re-run tests if they are automated and can be run with a single keystroke. ",
    "url": "/testing.html#why-test",
    "relUrl": "/testing.html#why-test"
  },"256": {
    "doc": "Software Testing",
    "title": "Test Cases and Automating Tests",
    "content": "In order to think about how to test software, we break our program down into test cases. Each case tests one specific feature or function of a program, and a single input to that part of the program. To test a program you’ve written, you will normally have many different test cases that test different parts of the program with different inputs. Basically, test cases break the job of software testing into discrete, managable parts. What is a test case? . A test case is a well-specified set of inputs and expected outputs. Above, I talked about how you could write down an input to your program, and then also specify what the output should be. That is a single test case. The trick with test cases is to be very specific. You are testing a very specific, logical piece of functionality of your code with a well-defined input and well-defined expected output. If your test case is specific enough, then it should be easy for anyone to tell whether the actual output matches the expected output; that is, you can tell whether the test case “passes” or “fails”. Automated test cases: Easy to run over and over . When we are writing automated tests, we usually break our tests into test cases. One function executes exactly one test case, and then decides whether that test passes or fails. For example, let’s pretend we have a really simple function called add() that takes two numbers and adds them together. If I add 1 and 2 together, I would expect to get 3, right? We can make that into a test case – if I call add(1,2), then I would expect the result to be 3. To do testing, we use the assert command in Python. Assert means to test and see if the result is what is expected. So, a really simple automated test case for the add() function would be: . def test_add(): result = add(1,2) assert result == 3 . In this case, the code is a test because the function name starts with test_. It runs the add() function with 1 and 2 as parameters, and then stores the actual result that is calculated in a variable called result. Then it checks (asserts) that this result is equal to 3 – the expected output. If it is equal, then we say that the test case “passes”, and the result is what we expect. If it is not equal, then we say that the test “fails” because it is not what we expected. This is a single test case. If I wanted to test a different set of inputs, that would be a separate test case. So if I also wanted to check that adding 0 and 0 results in 0, here is a second test case: . def test_add_zero(): result = add(0,0) assert result == 0 . Testing harness: runs a collection of test cases and produce output reports . Now we have more than one automated test case. What if we want to run all of these tests, and collect the results into a single output that is easy to read? That is the job of a test harness: a program that runs automated tests for us and reports on their results. In python, a common test harness that is built in is called UnitTest. There are other ones that are commonly used also, such as pytest or nose. ",
    "url": "/testing.html#test-cases-and-automating-tests",
    "relUrl": "/testing.html#test-cases-and-automating-tests"
  },"257": {
    "doc": "Software Testing",
    "title": "Types of Tests",
    "content": "Most software has a large number of tests associated with it. It is not uncommon for the test code to be more lines of code than the code that is being tested. Now, the next question is what kinds of test cases should we create? How do we think about what to test? . What follows is one way to think about what to test. It is not the best way, and it is certainly not the only way. But it is a useful way to organize your thinking. To help illustrate, I will be writing tests for a function that generate Fibonacci numbers – a sequence of numbers that goes 1, 1, 2, 3, 5, 8, 13, 21, 34… Each number in the sequence is the sum of the two previous numbers. The function takes as a parameter which number in the sequence it should generate (the 1st number, or 3rd number, or what), and it returns that number. Here is an implementation of that function: . def fib(n): if n &lt;= 2: return 1 return (fib(n-1) + fib(n-2)) . For the first two numbers (n=1 and n=2), it returns a hard coded 1. For each number after that, it calculates the two previous numbers and adds them together. This is just an example function. We could write tests for almost any function we create. Level 0: Basic Functionality . The first types of test cases that I write are called “Level 0” tests. These test the most basic functionality; if these fail then the function is hopelessly broken and needs to be fixed. Level 0 tests should test the one or two most common use cases of a function to make sure that it works correctly with completely normal input. For the Fibonacci function, a very normal use is to ask it for the 3rd or 4th number. Let’s pick one – the 4th number. Looking at the Wikipedia page for Fibonacci nunbers, it looks like 4th number is 3. So we would expect fib(4) to result in 3. We can write this as a test case: . ### Level 0 tests def test_fib_3(): assert fib(4) == 3 . Usually we don’t have many level 0 tests. We write level 0 tests just to check and make sure that the most basic funcationality works. If there is a syntax error, or if fib() does something unrelated to Fibonacci numbers, or if I forgot to write the code for fib(), then this test will catch that. All it does it make sure that the most normal, basic way of using the function works. Level 1: Full Range of Functionality and Edge Cases . Once the Level 0 tests are passing, we know that the basic function works. The next thing I do is write Level 1 tests. These tests look at the full range of functionality to try to identify what are the edge cases and different types of inputs that the function should handle. We should use our knowledge of the function to try to identify tricky cases, and test those to make sure they work. However, all of the Level 1 test cases should be valid cases, in that they ask the function to do things that it normally would be expected to do. For the fib() function, what are some tricky cases that it needs to handle? Well, the first two Fibonacci numbers are always tricky, because they are different than the others. The first number should be 1, and the second number should also be 1. Let’s write a couple of tests for those: . # Level 1 tests def test_fib_1: assert fib(1) == 1 def test_fib_2: assert fib(2) == 1 . Are there any other trick cases? Let’s pick a higher nunber, and make sure that it does calculations accurately. Looking at the Wikipedia page for Fibonacci numbers, the 10th number is 55. So let’s check that to make sure it calculates larger and more complicated numbers correctly: . def test_fib_10(): assert fib(10) == 55 . Ideally, you want to keep writing Level 1 tests until you’ve tests the full range of valid inputs – long inputs, short inputs, big numbers, small numbers, blanks, etc. Everything that is valid, you should write a test for to make sure that it works. Level 2: Error conditions . Almost all programs have invalid inputs – inputs that are considered to not be legitimate. However, sometimes the user ends up providing an invalid input. Good programs detect that the input is invalid, and handle it appropriately (for example, by displaying an error message). Level 2 tests test these invalid inputs. They intentionally provide invalid inputs to the program, and then check to make sure that the program does something reasonable with that input. For example, the fib() function only really produces sensible outputs for positve, whole numbers. If you enter a negative number, or if you give it a fraction, it doesn’t know what to do. What should it do? Often, when writing test cases, you realize that you don’t know what a program should do. If a bug is when what the program actually does is different than what the program should do, then it is a problem if you don’t know what the program should do! . This is surprisingly common, to not know what the program should do. This is another benefit of testing – it forces us to think through all of the things that can happen, and try to figure out what we want to the program to do in each of these situations. For the Fibonacci function, what do we want the program to do if it gets an invalid input? Let’s say that is should throw an IndexError any time it gets an invalid input. Now that we know what it should do, we can write some tests for some invalid inputs. We can use pytest.raises() to check and make sure that that error is raised. The test fails if it does NOT raise that error, and it passes if it does create that error: . # Level 2 tests def test_fib_negative(): with pytest.raises(IndexError): fib(-1) def test_fib_fraction(): with pytest.raises(IndexError): fib(2.5) def test_fib_string(): with pytest.raises(IndexError): fib(\"hi\") . If you run these tests with our fib() code above, you’ll see that these Level 2 tests fail! Uh oh! We have found some bugs in our code – it doesn’t handle error conditions very well. First, we need to decide if we care – is this a bug that is worth our time fixing? If it is, then we need to change our fib() code to make it do the right thing. Level 3: Performance and Scalability . Once all of the tests for Levels 0, 1 and 2 are passing, then the program mostly works correctly – it does what it is supposed to do. However, that’s not quite enough. There are usually other goals that programs have – for example, running fast enough that the user doesn’t get bored. Level 3 tests test these other, non-correctness features of programs. For example, it is a problem if it takes minutes to calculate our Fibonacci number. That’s not good. The computer should be able to calculate it in less than 10 seconds. So let’s write a test to check this: . # Level 3 tests def test_fib_speed(): start = datetime.datetime.now() out = fib(40) end = datetime.datetime.now() assert (end-start).total_seconds() &lt; 10 # It should take less than 10 seconds to compute . Example . You can download these examples here. This file contains the basic fib() function, and all of the tests listed above. To run it, use the command: . pytest fib.py . OR, alternatively, you can run it with . python3 -m pytest fib.py . When you run it, you should see that four of the test fail! Our fib() function only passes half of the tests. As an exercise, can you fix it so that all the tests pass? (Solution) . ",
    "url": "/testing.html#types-of-tests",
    "relUrl": "/testing.html#types-of-tests"
  },"258": {
    "doc": "Software Testing",
    "title": "Testing an Application",
    "content": "When testing a whole program or large application, there are some additional considerations. Specifically, it is really valuable to distinguish between unit tests and integration tests. Unit tests . Most programs are split up into smaller, logical units of functionality. A unit test tests a single, small unit of functionality. Often, we do this with functions; a unit test can test that a function works correctly. All of the tests we wrote above for the fib() function are unit tests – they test a small unit of functionality that is (most likely) part of a larger program. Unit tests are very common, and the majority of automated tests that are written are unit tests. Unit tests are great for catching regression bugs and for helping us to think through program and make sure that we cover everything it is supposed to be able to do. Integration tests . However, it is possible that all of the individual pieces work correctly on their own, but that they don’t fit together properly. That is where integration tests come in. Integration tests look at the program as a whole, and make sure that the pieces all fit together properly in a way that works. The most common way to create an integration test is a user script – write a script of what the user would do when using the application as a whole, and then annotate the script with what is expected to happen at each stage. User scripts can capture the overall functionality of a program in a way that unit tests don’t. Integration tests can be automated, and many good integration tests are. But often, we also do integration tests as manual tests, running through the application and making sure that it works as a whole. Exercise . Choose an application you wrote recently. Write an integration test case – a script for a user going through a process, and the detailed output expected. ",
    "url": "/testing.html#testing-an-application",
    "relUrl": "/testing.html#testing-an-application"
  },"259": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. Work as a team . There are lots of parts of tic-tac-toe. There’s the user input side – asking for where to move next. There is the drawing side. There is the figuring out of someone has won. Spread out the work across the team. Have different people do different parts. Use functions to capture the different parts of the program. Use modules to break apart your code among group members. Use git to share code. This project is much easier if you break it into parts, and then do the parts separately, and then put them together. Make sure to leave time towards the end of class to put everything together; its not as easy as it sounds. Think about program structure . Think about how you want to structure your program. At a high level, what are the logical things that the program needs to do? How do they fit together in the program? What information needs to be send from one logical thing to the next? As you get started, it can be helpful draw out a diagram that describes what those pieces are, and what information need to move from one to the next. Break the program into pieces (functions) . This type of program is MUCH easier if you can write some functions to do it. It really helps if you can think ahead of time about what functions you will want in your program. This is called “organizing” your program. Once you figure out the logical structure of your program, then use that to break the program into functions. If you try to write one big program that does the whole game, you will find it is really difficult. Each time you find yourself thinking you need the program to do something, write a function for that something. Need it to draw a symbol? Write a function for that. Need it to move the turtle to a new place? Write a function for that. Need to do the same thing more than once? Write a function! . For example, you could write a draw_board() function that draws the intiial board. You could write a draw_x function and a draw_o function that draws either an X or an O at the correct place. And you could write a function to get user input of a location and draw the appropriate symbol on the board. Use code you’ve written before . You’ve done a lot of programming already in this class.Use that! If you’ve already written code to draw a smiley face for a previous lab or studio, then go find that code and modify it. If you’ve already written code to ask for user input, go look it up and use it. There is no reason to write things from scratch when you’ve already written a lot of code. Test each function as you go . It is MUCH easier to figure out if a single function works than if the whole program works. As you write each function, write some throwaway code to see if it works. WHen you write the draw board function, run it and see if the board looks right. When you write a function to draw an X on the board, run it to see if it works. Run it to draw X’s in different places. Challenge 1: New Symbols . This is the easier challenge. X’s and Os are very boring. Instead of using X’s and O’s, draw different symbols. Maybe do a game of pizza-and-sandwiches? Or a game of smileys and frowns? Be creative (and/or use your emojis from the emoji studio). In addition to different symbols, can you change the board up to make it more interesting? Create a theme for the board? Use colors? . Challenge 2: When is the game done? . Your goal for this studio is just to allow users to play tic-tac-toe. Your program doesn’t need to detect when someone has won the game (3 X’s or O’s in a row) or when the game has ended in a stalemate. This is actually not easy to do. As a challenge, if you finish your tic-tac-toe game early, try to figure out how you can tell if someone has won the game. To do this, you’ll have to figure out how to store moves in a variable (like a list or a dictionary), and then you’ll have to figure out how to look through that variable to see if there are 3 in a row. Detecting a stalemate (tie) is easy – if there have been 9 valid moves, but no one has won yet, then the game is a stalemate. Don’t work on this until you get the main tic-tac-toe program working successfully. ",
    "url": "/studios/tic_tac_toe.html#advice",
    "relUrl": "/studios/tic_tac_toe.html#advice"
  },"260": {
    "doc": "Studio",
    "title": "Studio",
    "content": "For the studio today, you are going to make a game of Tic Tac Toe. You should draw an initial board (two vertical lines and two horizontal lines). Then ask the user where they want to move. Draw either an X or an O in the place they say. Let the user(s) continue until the whole board is full, or until the user decides someone has won. That’s all of the instructions. Form a group (of 2 to 4 people) and write a tic-tac-toe program. Have fun with it! . ",
    "url": "/studios/tic_tac_toe.html",
    "relUrl": "/studios/tic_tac_toe.html"
  },"261": {
    "doc": "Turning in work",
    "title": "Homework",
    "content": "Every week, you will have a small amount of homework. Homework consists of: . | completing readings (articles and/or videos) | responding to what you’ve read / watched | . Readings for each week are located on the schedule in the ‘readings’ column. They shouldn’t take more than 30 minutes to go through each week. Responses take the form of a summary+question, to be turned in each week under ‘Quizzes’ on D2L. They have two parts: . | Summary: follow the prompt on the readings page for that week to summarize what you’ve read | Question: ask a question about what you’ve read See the syllabus[link] for more details. | . Make sure to turn this in before the first class of each week. ",
    "url": "/reference/turning_in_work.html#homework",
    "relUrl": "/reference/turning_in_work.html#homework"
  },"262": {
    "doc": "Turning in work",
    "title": "Code and screenshots for labs",
    "content": "Every week, usually on Mondays, we’ll have a lab. Labs are done in pairs. At least one person in each pair will need to turn in: . | code | screenshots showing code working | . Screenshots are turned in on D2L under ‘assignments’ - the assignment will be marked as a lab with the appropriate week (like “Week 1 Lab”). Rule of thumb: every time you complete an exercise, take a screenshot of the code you wrote working. In the first two weeks, everyone (including code files) will be turned in on D2L. Starting in week 3, code is turned in on Gitlab. Both partners should be members of the Gitlab repository for the lab. Using Gitlab for labs . Each lab has an associated Gitlab repository. Starting in the 3rd week of class, you’ll be using Git to clone (make a copy of) the repository on your own computer, which you can then use to send changes back up to the repository in Gitlab. For every lab, follow these steps before you start working: . | one person will fork the lab, which creates new version in Gitlab under their username | the person who forked the lab should add their partner and also Caitlin (geierac) and Jack (waierjac) as administrators to the newly forked repository | the person who will be driving first clones the repository onto their own computer using git | . When trading places between driver and navigator: . | the driver should push all of the code they changed to the Gitlab repo before the navigator becomes the driver | the new driver (who used to be the navigator) either clones the repository onto their computer OR uses git pull to bring all of their partner’s changes down onto their own computer. Only use git pull if there’s already a cloned repository on your computer | . ",
    "url": "/reference/turning_in_work.html#code-and-screenshots-for-labs",
    "relUrl": "/reference/turning_in_work.html#code-and-screenshots-for-labs"
  },"263": {
    "doc": "Turning in work",
    "title": "Code and screenshots for studios",
    "content": "Most weeks on Wednesdays, we’ll have a studio. Studios are done in groups of 2-4. At least one person in the group will need to turn in: . | code | screenshot(s) showing code working | . Screenshots are turned in on D2L under ‘assignments’ - the assignment will be marked as a studio with the appropriate week (like “Week 3 Studio”). The best time to take screenshots is at the end of the studio when everything is working. If you’re not sure you’ll be able to get something working, take screenshots as you go. Using Gitlab for studios . For every studio, follow these steps before you start working: . | one person in the group will create a new repository in Gitlab, named the same as a the studio | the person who created the repository should add everyone in their group and also Caitlin (geierac) and Jack (waierjac) as administrators to the newly forked repository | . ",
    "url": "/reference/turning_in_work.html#code-and-screenshots-for-studios",
    "relUrl": "/reference/turning_in_work.html#code-and-screenshots-for-studios"
  },"264": {
    "doc": "Turning in work",
    "title": "Avoiding Git conflicts",
    "content": "If multiple people are making changes to a repository at the same time, sometimes there can be conflicts. This especially happens in studios, where different people might be working on different aspects of the studio at the same time. A few tips for avoiding conflicts: . | Always use git pull before you start working on a file to make sure you have the most updated version. | When you’re done working on a file, always add, commit, and push your code to Gitlab. | For studios, talk at the beginning of class about how you might split up the work. If it makes sense to have multiple people writing code at the same time, try each using different files to work on small pieces and combining your code into one file later. Keep talking with everyone in your group so that everyone knows what the others are working on and in what files. | . Don’t worry if you run into a conflict; Caitlin and Jack are always around to help you resolve them! . ",
    "url": "/reference/turning_in_work.html#avoiding-git-conflicts",
    "relUrl": "/reference/turning_in_work.html#avoiding-git-conflicts"
  },"265": {
    "doc": "Turning in work",
    "title": "Turning in work",
    "content": "This course uses D2L and Gitlab for turning in work. Almost every week, students will be responsible for three turn-ins: . | Homework (individual) | Code and screenshots for labs (partners) | Code and screenshots for studios (group) | . ",
    "url": "/reference/turning_in_work.html",
    "relUrl": "/reference/turning_in_work.html"
  },"266": {
    "doc": "Lab",
    "title": "Draw some things",
    "content": "When I refer to “the turtle” in these exercises, I mean the arrow in the Turtle drawing window. Think of it as a small turtle that crawls around on the screen, leaving a trail behind it. Exercise 1: Finish the square . In the Git repository, you should see a program called square,py. This program is supposed to draw a square on the screen that looks like this: . However, the program isn’t finished! Run the program with python square.py (or python3 square.py on Mac) and see what happens. Edit the program to finish drawing the square. Remember that the right() and left() commands turn the turtle in degrees – 360 degrees turns the turtle all the way around so it is facing the same way it started. 90 degrees is a quarter of the way around (a right angle). 180 degrees turns the turtle around to face the opposite direction. Exercise 2: Finish the stick figure . In the Git repository you should see a program called person.py. This program begins to draw a stick figure using Turtle. Run the program to see what it does. It should start to draw a stick figure, and then wait for you to close the window. Python will keep running the program (even if it’s not doing anything) until you close the Turtle drawing window. Write the code to finish drawing the stick figure. The person.py file contains some comments (text with # in front of it) for what code you’ll need to write to finish it. Don’t try to do this all at once. Start by drawing on a piece of paper without lifting up your pen: what do you need to do with the pen? (You can use the whiteboard in the classroom for this too, if you want.) Next, write one or two commands, and then run the program to see what happens. Write more commands, and see what happens. Once it is finished the person should look something like this: . Note: Pay attention to the direction the arrow is facing. After drawing the code that I wrote, it is facing down. That means if you turn right, it will end up facing left (because if you facing down and turn right, that’s where you end up). Exercise 3: Pen Up and Down . Next, we are going to do a bit of writing with our turtle. Create a new program, called MI.py, that writes the two capital letters “MI” next to each other. The two letters should not be touching each other. It should probably look something like this: . To get the gap between the “M” and the “I”, you can use the penup() and pendown() functions to lift up the pen after drawing the “M” and put it back down before starting the “I”. Before you can use any of the Turtle commands, you need to remember to import the Turtle library. Importing brings in additional functionality into python that it normally doesn’t have. The Turtle library doesn’t come preloaded into Python, so we have to import it to be able to use it. To import the Turtle library, put this line at the top of your program: . from turtle import * . Note both of the previous programs did that, too. Also, for Turtle programs, it helps to end the program with done() - put it in the last line of the program. This causes the program to keep the Turtle window open after it’s done drawing so you can see what the drawing looks like. Don’t forget to save this file into the Git repo on your computer, so you can then add, commit, and push it to your Git repository on GitLab. If you haven’t switched drivers already, now might be a good time to do that. Exercise 4: Names, squared . For the next exercise, create a new program called names.py. This program should use the write() function to print out both your name and the name of your partner for the lab. It should also draw a red box around those names. Here is mine: . Note: you can change the color of the pen with pencolor(\"red\"). You can also change the font and size if you want to. If you want to try this, look through the Turtle documentation (linked at the top of this lab) to figure out how to do it. (Hint: you can add more things inside the write() function!) . Hint: Remember to add from turtle import * to the beginning of your names.py program and done() to the end. ",
    "url": "/labs/turtle.html#draw-some-things",
    "relUrl": "/labs/turtle.html#draw-some-things"
  },"267": {
    "doc": "Lab",
    "title": "Interactive Drawing!",
    "content": "The program guestbook.py is a simple guest book app that prints out a name on the screen using Turtle. If you run it, it should print my name and move the turtle a bit. Exercise 5: Input name from user . Turtle has a function called textinput() that allows you to ask the user for a text input, which you can then save to a variable and use elsewhere. Modify the guestbook program to ask the user for their name, and then use Turtle to write the user’s name on the screen underneath my name. textinput() works similarly to input(), which we’ve used in the past. But there are two main differences: . | Unlike input(), which prompts the user in the terminal, textinput() causes a window to pop up asking the user for information | Also unlike input(), textinput() needs two pieces of information: the title of the window (text that shows up at the top of the input window), and the prompt that is displayed to the user. | . For example, the code: . name2 = textinput(\"Name\", \"Please enter your name\") . would pop up a window titled “Name” and ask the user to “Please enter your name”. Whatever the user enters in the window would be saved into the name2 variable. Exercise 6: Third Name . The guestbook should have two names in it now - my name, and then a name captured via textinput() underneath it. Now modify the guest book to ask the user for a third name, and display the third name below the second one. You’ll have to move the pen down again before writing the third name to make sure the names aren’t on top of each other. Hint: You’ll likely want to have three different variables at this point, each storing a different name. Exercise 7: Looped Guestbook . Now you should have three names in your guestbook, with the turtle moving between each name. You might have noticed that you had to repeat the move code and the input code to get it to work. When you see repeated code, that can be a good time to use a loop instead. Put the code that asks for a name, draws it, and then moves the turtle down into a loop so it will keep asking for names and then printing them out, one after the other. Hint: a while loop will probably work better than a for loop for this. Go back to the Guessing Game exercises in the Counting and Loops lab if you need a reminder on how to use while loops. Note you can end the program anytime by closing the Turtle window, so you don’t need to worry if the loop is infinite. ",
    "url": "/labs/turtle.html#interactive-drawing",
    "relUrl": "/labs/turtle.html#interactive-drawing"
  },"268": {
    "doc": "Lab",
    "title": "Seeing Stars",
    "content": "Exercise 8: Star . Create a new program called stars.py. For this program, write a program that draws a 5 pointed star. Here’s the catch: you must use a for loop to draw the star. If you do it right, the star can be drawn using only 3 lines of code. Note: The angle at a point of a star is 144 degrees. Note 2: Drawing a star should just involve moving forward, turning 144 degrees, moving forward, turning again, and so on until the star is finished. One finished, it should look like this: . Hint: Remember to add from turtle import * to the beginning of your stars.py program and done() to the end. Exercise 9: Row of stars . Next, modify your program to use a for loop to create a row of 5 stars next to each other. You should use the same code you wrote above to draw a single star, but put it inside a loop with some additional code between the stars so that the turtle moves to the right to get ready to draw the next star. Hint: It is possible to have a for loop inside of another for loop - this is called having a nested loop. Exercise 10: Fill In the Stars . Modify your program to fill in the stars with a color. You can specify the fill color using the color() command. Use begin_fill() when you start drawing to begin filling in the stars, and end_fill() when you are done with what you want filled. For this exercise, fill the stars so they’re all black (color(\"black\")). Note: For some reason, on Macs, it doesn’t actually fill in the center of the star. That’s fine! . Hollow star, on a Mac . Filled star, on Windows . Exercise 11: Brightly Colored Stars . Black is boring. Make the stars brightly colored. Here’s a handy resource for colors you can use in Turtle. If you want an even broader range of colors, you can also use HTML color codes, also known as hex codes. Here’s a good color picker. Google can help you figure out how to use hex codes with Turtle. Play around and find a color you and your partner both like, and make all the stars that color. Bonus: can you make the stars multiple colors? . Exercise 12: Lots of Stars . Now that you have the commands to draw a star, let’s draw lots of stars. Using nexts for loops, modify your previous program to draw 50 stars in a 10 by 5 grid. Hint: the command speed(0) will speed up the Turtle drawing so you don’t have to wait as long. Hint 2: You’ll need to move the turtle in between each row of stars so it starts in the right place to draw the next row. ",
    "url": "/labs/turtle.html#seeing-stars",
    "relUrl": "/labs/turtle.html#seeing-stars"
  },"269": {
    "doc": "Lab",
    "title": "Challenges",
    "content": "If you finish all of the exercises before the end of class, try at least one of the challenges below. Challenge 1: Draw more shapes . You’ve drawn a square and a star so far. Use Turtle to draw these shapes as well: . | Pentagon (5 sides) | Hexagon (6 sides) | Octagon (8 sides) | . If you aren’t sure of the angles you need to turn the turtle in order to draw these shapes, use Google to look it up! . Challenge 2: Quit the Guestbook . Right now you can quit the guestbook by closing the Turtle window. Change the code so that the guestbook program stops taking new names when the user types “quit”. The Turtle window should still stay open. Hint: remember you can use if statements inside of while loops to check for a condition. Challenge 3: Stars on the U.S. Flag . Modify the program to create a blue background, and change the stars to be solid white. You can set the background color using bgcolor(), or by drawing a large square and filling it in with the color you want before you draw the stars. Bonus: draw the 50 stars in the pattern they appear on the US Flag. Challenge 4: Random Number of Stars . Instead of drawing a set number of stars in a set number of rows, draw a grid of stars with random dimensions using the random library. You’ll probably want to provide boundaries to the range of random numbers that are generated so you don’t accidentally draw a million rows (that would take forever!). Bonus: also make each star be a random size. Hint: If you need a refresher on the random library, look at the first few exercises in Lab 4. Also remember to add import random at the top of your program. ",
    "url": "/labs/turtle.html#challenges",
    "relUrl": "/labs/turtle.html#challenges"
  },"270": {
    "doc": "Lab",
    "title": "Lab",
    "content": "For this lab, we are going to use a Git repository like we did for last week. The first thing you should do is fork the turtles repository (link above), add your partner, Caitlin (geierac) and Jack (waierjac) to the repository, and then clone the repository onto your computer. Refer to the Git reference if you’ve forgotten how to do this. For this lab, we will be working with Turtle Graphics all day. There are a LOT of commands you can use for Turtle, and you don’t have to memorize them all. Instead, you can refer to the documentation: . | Turtle Documentation | . I’d recommend that the navigator (the person who isn’t driving) keep the documentation open to refer to while you work. I also strongly advise you to write your code in small chunks and test it frequently. Add one or two lines of code, and then run it to see what happens. If it’s not working, tinker with it until it does. Then add one or two more lines, run it again. And so on. The more often you run it, the more you’ll understand what it is doing and the easier it will be to troubleshoot when things go wrong. ",
    "url": "/labs/turtle.html",
    "relUrl": "/labs/turtle.html"
  },"271": {
    "doc": "Using Git",
    "title": "Forking a repository",
    "content": "For every lab, a repository will already exist with code files in it that you will use for lab exercises. You will need to make a copy of it so you can work with the files inside: only one person per pair needs to do this step. | On the GitLab repo for the lab, find the Fork button - it should be on the top right of the page. Click it. | It will ask you for a ‘namespace’: there should be only one option, with your username. If you have multiple options, make sure you choose your username as the name space. | Leave everything else on the page as-is and click the blue “Fork project” button at the bottom. | Be patient - it might take a few moments. Once the fork is complete, it will take you to the project page for your newly forked project. You’ll be able to tell because if you look at the breadcrumbs above the project name, instead of saying “MI 250 &gt; Name of Lab”, it should say your username instead of MI 250. | Add your groupmates to the project. Also add Caitlin (geierac) and Jack (waierjac). (For a reminder of how to do this, see sharing a repository with other people.) | . Note: if you get a 404 error, it’s because GitLab tried to load the repository page for your new forked repo before the fork was complete. Wait a few seconds and try reloading the page. If that doesn’t work, go to your main projects page by clicking the fox icon in the upper left and see if the project you created is in the list. ",
    "url": "/reference/using_git.html#forking-a-repository",
    "relUrl": "/reference/using_git.html#forking-a-repository"
  },"272": {
    "doc": "Using Git",
    "title": "Creating a new repository",
    "content": "For every studio, one member of your group will need to create a new repository. | From your projects page in GitLab (this is the main landing page when you first log into Gitlab), click the blue “New Project” button | Choose the “Create blank project” option | On the Create blank project page, give your project a name (Studio 3 works fine, but you can name it whatever you want). Keep all the other options on that page as-is and click the blue “Create project” button at the bottom. | Add your groupmates to the project. Also add Caitlin (geierac) and Jack (waierjac). (For a reminder of how to do this, see sharing a repository with other people.) | . ",
    "url": "/reference/using_git.html#creating-a-new-repository",
    "relUrl": "/reference/using_git.html#creating-a-new-repository"
  },"273": {
    "doc": "Using Git",
    "title": "Sharing a repository with other people",
    "content": "If you want other people to be able to see your code, you need to share the repository with them. This includes your partner or groupmates in class, and Caitlin and Jack. To share a repo, you need to add the people you want to share with as members of that repo. | Go to the main page for your project in Gitlab | In the left hand menu, find Manage (it should be near the top.) Hover over it and you’ll see a smaller menu - choose “Members” in that menu. | On the Members page, click the blue “Invite Members” button on the top right. | In the window that pops up, add each of your partners / groupmates - you can search for them using their MSU NetID (same as their MSU email). Also add Caitlin (geierac) and Jack (waierjac). Make sure to select the Maintainer role before clicking Invite at the bottom! | Everyone you added should show up on the list on the Project Members page - double check that they all have the Maintainer role. Everyone in that list will be able to see and edit your project. | . ",
    "url": "/reference/using_git.html#sharing-a-repository-with-other-people",
    "relUrl": "/reference/using_git.html#sharing-a-repository-with-other-people"
  },"274": {
    "doc": "Using Git",
    "title": "Git clone: Getting a repository onto your computer for the first time",
    "content": "Cloning a repository is always done in three steps: . | Fork the repository (you will do this for every lab) or create a new repository (for studios) | In command line, use cd to navigate to the place on your computer where you want the repository to live | Copy the https link for the respository you want to clone | Use git clone followed by the respository link to clone your repository onto your computer | . A clone command might look like this: . git clone https://gitlab.msu.edu/geierac/git-and-gitlab.git . Make sure the last part of the link matches the name of the repository you want to clone! Also make sure it’s your or your partner’s username in the middle of the link, and not MI-250. ",
    "url": "/reference/using_git.html#git-clone-getting-a-repository-onto-your-computer-for-the-first-time",
    "relUrl": "/reference/using_git.html#git-clone-getting-a-repository-onto-your-computer-for-the-first-time"
  },"275": {
    "doc": "Using Git",
    "title": "Git add, commit, push: Pushing code from your computer to GitLab",
    "content": "There are three steps to getting your code from your computer up to GitLab (or any Git repository in the cloud) - staging (add), committing, and pushing. | git add &lt;filename&gt; will add a file to the staging area - when it’s staged, it means you’ve decided you want to save those changes to the cloud version of the repository. If you made changes to a lot of files and want to save them all at once, use git add -A. | git commit -m \"&lt;your commit message&gt;\" is what you run once all the files you want to save have been staged. The commit message should say, very briefly, what changes you made and why. | git push is the final step - this command takes all of your changes and pushes them up to the cloud version of the repo. | . If any issues happen while you’re giving these commands, errors usually will show in red text in command line. You can also get an idea of where you are in the process and what you need to do next by using git status. ",
    "url": "/reference/using_git.html#git-add-commit-push-pushing-code-from-your-computer-to-gitlab",
    "relUrl": "/reference/using_git.html#git-add-commit-push-pushing-code-from-your-computer-to-gitlab"
  },"276": {
    "doc": "Using Git",
    "title": "Git pull: Pulling changes from GitLab onto your computer",
    "content": "Other people might change the code in the repository after you’ve cloned it. git clone captures a snapshot in time and saves that snapshot to your computer - it represents the state of the project at the exact time you cloned it, and it doesn’t update automatically when changes are made to GitLab. You have to pull down those changes manually. To do that, use this command: . git pull . This will pull all of the new stuff from GitLab into the version of the repo on your computer. This should be the first thing you do before you start editing. ",
    "url": "/reference/using_git.html#git-pull-pulling-changes-from-gitlab-onto-your-computer",
    "relUrl": "/reference/using_git.html#git-pull-pulling-changes-from-gitlab-onto-your-computer"
  },"277": {
    "doc": "Using Git",
    "title": "Avoiding Git conflicts",
    "content": "If multiple people are making changes to a repository at the same time, sometimes there can be conflicts. This especially happens in studios, where different people might be working on different aspects of the studio at the same time. A few tips for avoiding conflicts: . | Always use git pull before you start working on a file to make sure you have the most updated version. | When you’re done working on a file, always add, commit, and push your code to Gitlab. | For studios, talk at the beginning of class about how you might split up the work. If it makes sense to have multiple people writing code at the same time, try each using different files to work on small pieces and combining your code into one file later. Keep talking with everyone in your group so that everyone knows what the others are working on and in what files. | . Dealing with conflicts . If two people have edited the same file at the same time, this is where you will likely get a merge conflict when trying to save changes to GitLab. The person experiencing the conflict should follow these steps to merge the changes together: . | use git pull to make sure all of the latest changes are on your computer | open up the file with the conflict in your text editor. If it’s already open, close it and open it again to make sure you’re in the latest version of the file. | In the file, you should see conflict markers: these look like &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD, ========, and &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;. The code inside the markers is what’s in conflict. Edit this code to make sure it’s what you and your partner want it to look like. When you’re done, delete the conflict markers and save the file. | Use add, commit, and push like usual on the file. This should complete the merge. | . For more details, see Resolving a merge conflict using the command line. If you’ve tried to fix the conflict but it’s not working, git restore and git reset are two options to get your repository back in working order. These options will delete any changes you’ve made since the last commit. If you want to save those changes, create a new file as a temporary place to keep your code and copy and paste your changes into that file. You can move them back in later, once Git is back in order. | git restore &lt;filename&gt;: use this if you forgot to pull your partner’s changes before starting to make your own changes. This will restore the file to the last time it was committed, which will undo any changes made to it. | git reset --hard: use this if you’ve tried to commit changes already. This command will reset the local version of your repository to the last commit that went through, and will delete any changes you’ve made since then. | . If you do either of these, make sure to use git pull immediately after to make sure the respository is up to date. For more details, see Git restore and Git reset. Don’t worry if you run into a conflict; Caitlin and Jack are always around to help you resolve them! . ",
    "url": "/reference/using_git.html#avoiding-git-conflicts",
    "relUrl": "/reference/using_git.html#avoiding-git-conflicts"
  },"278": {
    "doc": "Using Git",
    "title": "Using Git",
    "content": "Working with Git and GitLab allows you to easily share your code with your partner or groupmates in labs and studio. GitLab works as cloud storage for your project, which every member of the project can then pull down onto their own computers using Git. When you’ve made the edits you want on your own version of the code, you can then push it back up to GitLab so your teammates can access it. | Forking a repository | Creating a new repository | Sharing a repository with other people | Git clone: Getting a repository onto your computer for the first time | Git add, commit, push: Pushing code from your computer to GitLab | Git pull: Pulling changes from GitLab onto your computer | Avoiding Git conflicts . | Dealing with conflicts | . | . ",
    "url": "/reference/using_git.html",
    "relUrl": "/reference/using_git.html"
  },"279": {
    "doc": "Readings",
    "title": "Readings",
    "content": "This week, the readings cover initially how to get Python to do some things, including using it as a calculator and getting it to output things. To understand the concepts, read these online book chapters: . | Think Python: The Way of the Program | Think Python: Variables, Expressions, and Statements | Automate the Boring Stuff: Python Basics | Automate the Boring Stuff: Flow Control – only the first half, stop before “For loops and the range() function” | . There is overlap in these chapters; they sometimes talk about the same things. Please read all of them. This won’t take long, and having heard the concepts in different places and in different ways will help them make more sense to you. Don’t worry if you don’t quite understand what you’ve read yet. That’s normal. Below are some short lessons where you can run and edit code to see how it works. I would recommend going through these as well, as it can help some of the concepts explained in the book chapters make more sense. We will also be practicing these concepts in class. | Learn Python: Hello World! | Learn Python: Variables and Types | Learn Python: Conditions | . ",
    "url": "/readings/variables.html#readings",
    "relUrl": "/readings/variables.html#readings"
  },"280": {
    "doc": "Readings",
    "title": "Summary",
    "content": "When writing your summary this week, think about what you learned from the readings and what did and didn’t make sense to you. In particular, think about the idea of variables. Think about things you already have experience with - classes you’ve taken, or hobbies or jobs you’ve had - and whether you’ve encountered anything similar before. Summary prompt: How would you explain what a variable is and how they are used? . ",
    "url": "/readings/variables.html#summary",
    "relUrl": "/readings/variables.html#summary"
  },"281": {
    "doc": "Readings",
    "title": "Question",
    "content": "Your question this week, and for most future weeks, can be one of three “types” of question: . | A confusion question: what are you still confused about after going through the readings? It can be confusion about a specific point or a more general confusion about the topic overall. | A curiosity question: what would you like to learn more about? The readings and/or videos may have gotten you to think about something else that is related, but not really discussed in the material that you don’t understand; that is, it got you to be curious about something else. This is a great chance to express that curiousity. | A connection might not be a question; instead, it is an example that applies the concept that your are learning to some other aspect of your life or some other interesting thing in the world. | . After reading the material, come up with one question. Caitlin will read through the questions before class starts and answer the most interesting ones at the beginning of class. NOTE: You do have to ask a question for it to count. “I have no questions” is not a question. If you can’t think of a question, think of a connection instead. Submit your summary+question on D2L under Quizzes. Since there’s no class on Monday this week (due to MLK Day), turn it in before class starts on Wednesday. ",
    "url": "/readings/variables.html#question",
    "relUrl": "/readings/variables.html#question"
  },"282": {
    "doc": "Readings",
    "title": "Readings",
    "content": "In class this week we’ll be practicing using variables, and controlling the flow of programs. The readings below will help you learn about the concepts, which we’ll practice in class. Don’t worry if you don’t understand everything yet - it will start to make more sense once you get a chance to practice. ",
    "url": "/readings/variables.html",
    "relUrl": "/readings/variables.html"
  },"283": {
    "doc": "Readings",
    "title": "Readings",
    "content": "Some of these readings get in the weeds about using Git - don’t worry if you don’t understand everything. We’ll be practicing in class this week. | What is Version Control? | Git Handbook | Saving Changes in Git | Getting Changes from a Remote Repository | . ",
    "url": "/readings/version_control.html#readings",
    "relUrl": "/readings/version_control.html#readings"
  },"284": {
    "doc": "Readings",
    "title": "Summary",
    "content": "When writing your summary this week, think about the kinds of tools you’ve used to collaborate with classmates in the past. What did you read about version control that sounded similar to other tools you’ve used? What was new to you about it? . Summary prompt: Why do we need version control? How is it different from how you’ve shared work with group members in the past? . ",
    "url": "/readings/version_control.html#summary",
    "relUrl": "/readings/version_control.html#summary"
  },"285": {
    "doc": "Readings",
    "title": "Question",
    "content": "As per usual, your question can be one of three types: . | Confusion: what didn’t you understand in the readings? | Curiousity: what do you want to know more about? | Connection: how does this topic connect to your own experiences? | . Submit your summary+question on D2L under Quizzes before class starts on Monday. ",
    "url": "/readings/version_control.html#question",
    "relUrl": "/readings/version_control.html#question"
  },"286": {
    "doc": "Readings",
    "title": "Readings",
    "content": "From here on out, you’ll be using something called version control to collaborate with partners in class and to turn in code. Version control allows programmers to keep track of changes to their code and to collaborate with other programmers more easily. The type of version control we’ll be using is called Git. We’ll be using it alongsize Gitlab, which is kind of like Google Docs except specifically for storing code. Gitlab is where you’ll turn in your code from now on. Note: Some of these readings talk about Github, which we won’t be using. We’re using Gitlab instead. Gitlab and Github are two different variations on the same thing - they’re run by different companies, but they do the same thing, which is allow people to store programming projects in the cloud. We use Gitlab for this class because MSU runs an MSU-specific Gitlab server that all students can use for free. ",
    "url": "/readings/version_control.html",
    "relUrl": "/readings/version_control.html"
  },"287": {
    "doc": "Studio",
    "title": "Advice",
    "content": "What follows is just advice for doing it. You don’t have to follow my advice. Do whatever you want. This is just my experience in doing this, and you might want to do it differently. Create text files . Most of the text you find online are in Word files or Google docs or web pages or ebook formats. Your program only needs to work with text files – files that contain nothing but plain text. No formatting, no colors, no pages, nothing but text. Your code that you edit in Atom is a text file. I recommend you start by finding a couple of things that you want to look at a word cloud for. Copy-and-paste the texts into files in your text editor (like Atom, or Notepad) and save it as a plain text file (.txt), in the same directory as your word cloud program. That way, you can easily run your program on these different files to try it out. A great place to start is song lyrics. Pick a song you like, Google for the lyrics, and then save those lyrics into a text file. Another alternative is to pick an old book or play. You can find plain text copies of Shakespeare’s plays on Project Gutenberg. Read in Whole Files . In this week’s lab, you learned how to read in a file one line at a time. You can read in a single line of a file using f.readline(), or you can do it in a loop by using for line in f:. However, sometimes, you don’t want to read it in one line at a time. Instead, you want to read the whole file in at once and store its contents in a string. You can do this with f.read(). f.read() reads the whole file in at once, and stores it in a Python string. You’ll want to remember to save that string to a variable: str = f.read(). Also, remember that this only works after you’ve already opened the file with open(). Count words . We have worked with code that counts letters or words in a string multiple times. You wrote word counting code in this week’s lab. I wrote some code to do this back in the reading code lab as well. Basically, you create a dictionary where words are the keys and the count – the number of times the word appears – is the value. You split the string into words using .split(), and then you look up each word you find and add 1 to the count as you loop through each word. If you didn’t finish this week’s lab, I recommend going back through with your group and trying to get through as much as you can. OR, alternatively, you can use the code I wrote for the reading code lab, but you’ll need to understand how it works to use it. Sort words . The first challenge from this week’s lab describes how to sort dictionaries. Actually, you can’t sort a dictionary, but you can loop through the dictionary in sorted order. You can use this to go through the dictionary with the most frequent words first (or last, depending on what you want). Just do a word list to start . There are many ways to display your word cloud. A cloud-like representation is pretty normal, but it is hard to know where to put the words. You don’t need to get something that complicated working immediately. Instead, try something simpler. You could just display words in order. That visualization just puts common words in alphabetical order, and makes the words bigger that appear more often. You can even go simpler than that, and start with a single list of words, with more common words bigger: . A word is as big vertically as you tell it . When you use write() with turtle graphics, you can tell it a font size. That font size is approximately how big, vertically, the word is. So if you tell it to write the word with a size of 20, then you can go down one line by moving the turtle down 20 steps. This is really handy to know when making the word list, and it is what I did to make that word list above. Note that you already have a number associated with each word – the word count! What if you made the font size the same as that number? . You can tell write to move the pen horizontally . By default, when you use write() to put some text on the screen, the turtle doesn’t move. It stays right where it is, and puts the text there. However, you can tell the turtle to move with the text, so the turtle ends up to the right of the text instead of where it started on the left. To do so, you just say move=True: . write(\"Hello\", font=(\"Arial\", 20, \"normal\"), move=True) . This is really useful if you want to put the words horizontally next to each other. ",
    "url": "/studios/wordcloud.html#advice",
    "relUrl": "/studios/wordcloud.html#advice"
  },"288": {
    "doc": "Studio",
    "title": "Challenges",
    "content": "If you get a basic word cloud display working, first try it on different texts. See what works well and what doesn’t. Remove stopwords . It won’t surprise you that the most common words in English are really boring – “the”, “a”, “is”, etc. It isn’t very interesting to have a word cloud where the biggest words are those really common words. It is much more interesting to see which of the less common words appear frequently in a text. Make a list of “stopwords” – common words that aren’t interesting that you want to remove. Then modify your program to remove stopwords from your list so they don’t get displayed, and it only displays the more interesting words. Note that you can use not in with a for loop, if you only want to deal with words that are not in a list: for word not in stop_list: . Layout and functions . Try different ways of laying things out. You can make things a vertical list. You can move around in a circle. You can put words horizontally, and then wrap when it gets past a certain part of the screen. You can put words in alphabetical order. You can sort the words and put the most common one first. You can put longer words first and shorter words later (len(word) will calculate the length of a word). Try making the words different colors. Try different layouts and and see which one(s) you like better. There is no right answer; different layouts might be useful in different situations. As you create more than one layout, make each layout a separate function. That way, you can just call a different function to get a different layout, and it is easy to go back to a previous layout. Automatic rescaling . As you try your word cloud program on different texts, you will find that some longer texts end up with really big words, and some shorter texts have only small words. Try to add a calculation that figures out what the most common word is, and then figures out how big that word should be. Then rescale all of the words relative to that, so that what is important is not how many times a word was mentioned, but how much more or less often a word was mentioned. Add visual design . A word cloud frequently only has words on it – but it doesn’t have to. You can put other designs on the word cloud. Circle the biggest word? Underline words with more than 20 mentions? Draw a cloud around the whole thing? Make it look interesting. Fonts . You can also vary the fonts. You can use the same font for everything, to make it look nice. Or you can change words into different fonts to emphasize some words over others. Here is a program that you can run to get a list of all the fonts available on your computer. Color . You can also vary the colors used. For example, many word clouds use different shades of the same color to indicate different ranges of frequencies. Instead of using the same color for everything, can you make different words have different colors? What might the colors mean? . ",
    "url": "/studios/wordcloud.html#challenges",
    "relUrl": "/studios/wordcloud.html#challenges"
  },"289": {
    "doc": "Studio",
    "title": "Studio",
    "content": "A word cloud is a way of visualizing text – it shows how frequently different words are used by varying the size of the text. Words that have a larger font size appear more frequently than words that are smaller. If you have some text – like a song, a speech, or a document – you can use the word cloud to see approximately what that text is about and what kinds of things are being talked about. Here’s an example word cloud: . And another showing the world population by country: . Your goal today is to write a program that reads in a text file, calculates how often each word appears in that file, and then finds an intersting way to display the most common words in the file on the screen using Turtle graphics. Try to make sure your program works with different kinds of input files. As per usual, work in teams of 2-4 people. ",
    "url": "/studios/wordcloud.html",
    "relUrl": "/studios/wordcloud.html"
  }
}
